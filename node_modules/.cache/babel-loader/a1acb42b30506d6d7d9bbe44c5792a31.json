{"ast":null,"code":"import * as encoding from \"@walletconnect/encoding\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { ERROR, generateKeyPair, deriveSharedKey, encrypt, decrypt, sha256 } from \"@walletconnect/utils\";\nimport { CRYPTO_CONTEXT, KEYCHAIN_CONTEXT } from \"../constants\";\nexport class KeyChain {\n  constructor(client, logger) {\n    this.client = client;\n    this.logger = logger;\n    this.keychain = new Map();\n    this.name = KEYCHAIN_CONTEXT;\n    this.client = client;\n    this.logger = generateChildLogger(logger, this.name);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  async init() {\n    await this.restore();\n  }\n\n  async has(tag, opts) {\n    return this.keychain.has(tag);\n  }\n\n  async set(tag, key, opts) {\n    this.keychain.set(tag, key);\n    await this.persist();\n  }\n\n  async get(tag, opts) {\n    const key = this.keychain.get(tag);\n\n    if (typeof key === \"undefined\") {\n      throw new Error(ERROR.NO_MATCHING_KEY.format({\n        tag\n      }).message);\n    }\n\n    return key;\n  }\n\n  async del(tag, opts) {\n    this.keychain.delete(tag);\n    await this.persist();\n  }\n\n  async restore() {\n    const keychain = await this.client.storage.getKeyChain(this.context);\n\n    if (typeof keychain !== \"undefined\") {\n      this.keychain = keychain;\n    }\n  }\n\n  async persist() {\n    await this.client.storage.setKeyChain(this.context, this.keychain);\n  }\n\n}\nexport class Crypto {\n  constructor(client, logger, keychain) {\n    this.client = client;\n    this.logger = logger;\n    this.name = CRYPTO_CONTEXT;\n    this.client = client;\n    this.logger = generateChildLogger(logger, this.name);\n    this.keychain = keychain || new KeyChain(this.client, this.logger);\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  async init() {\n    await this.keychain.init();\n  }\n\n  async hasKeys(tag) {\n    return this.keychain.has(tag);\n  }\n\n  async generateKeyPair() {\n    const keyPair = generateKeyPair();\n    return this.setKeyPair(keyPair);\n  }\n\n  async generateSharedKey(self, peer, overrideTopic) {\n    const keyPair = await this.getKeyPair(self.publicKey);\n    const sharedKey = deriveSharedKey(keyPair.privateKey, peer.publicKey);\n    return this.setEncryptionKeys({\n      sharedKey,\n      publicKey: keyPair.publicKey\n    }, overrideTopic);\n  }\n\n  async encrypt(topic, message) {\n    const {\n      sharedKey,\n      publicKey\n    } = await this.getEncryptionKeys(topic);\n    const result = await encrypt({\n      message,\n      sharedKey,\n      publicKey\n    });\n    return result;\n  }\n\n  async decrypt(topic, encrypted) {\n    const {\n      sharedKey\n    } = await this.getEncryptionKeys(topic);\n    const result = await decrypt({\n      encrypted,\n      sharedKey\n    });\n    return result;\n  }\n\n  async encodeJsonRpc(topic, payload) {\n    const message = safeJsonStringify(payload);\n    const hasKeys = await this.hasKeys(topic);\n    const result = hasKeys ? await this.encrypt(topic, message) : encoding.utf8ToHex(message);\n    return result;\n  }\n\n  async decodeJsonRpc(topic, encrypted) {\n    const hasKeys = await this.hasKeys(topic);\n    const message = hasKeys ? await this.decrypt(topic, encrypted) : encoding.hexToUtf8(encrypted);\n    const payload = safeJsonParse(message);\n    return payload;\n  }\n\n  concatKeys(keyA, keyB) {\n    return encoding.arrayToHex(encoding.concatArrays(encoding.hexToArray(keyA), encoding.hexToArray(keyB)));\n  }\n\n  splitKeys(keys) {\n    const arr = encoding.hexToArray(keys);\n    return [encoding.arrayToHex(arr.slice(0, 32)), encoding.arrayToHex(arr.slice(32, 64))];\n  }\n\n  async setKeyPair(keyPair) {\n    const keys = this.concatKeys(keyPair.publicKey, keyPair.privateKey);\n    await this.keychain.set(keyPair.publicKey, keys);\n    return keyPair.publicKey;\n  }\n\n  async getKeyPair(publicKey) {\n    const [_, privateKey] = this.splitKeys(await this.keychain.get(publicKey));\n    return {\n      publicKey,\n      privateKey\n    };\n  }\n\n  async setEncryptionKeys(encryptionKeys, overrideTopic) {\n    const topic = overrideTopic || (await sha256(encryptionKeys.sharedKey));\n    const keys = this.concatKeys(encryptionKeys.sharedKey, encryptionKeys.publicKey);\n    await this.keychain.set(topic, keys);\n    return topic;\n  }\n\n  async getEncryptionKeys(topic) {\n    const [sharedKey, publicKey] = this.splitKeys(await this.keychain.get(topic));\n    return {\n      sharedKey,\n      publicKey\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/crypto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as encoding from \"@walletconnect/encoding\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { safeJsonParse, safeJsonStringify } from \"@walletconnect/safe-json\";\nimport { ERROR, generateKeyPair, deriveSharedKey, encrypt, decrypt, sha256, } from \"@walletconnect/utils\";\nimport { CRYPTO_CONTEXT, KEYCHAIN_CONTEXT } from \"../constants\";\nexport class KeyChain {\n    constructor(client, logger) {\n        this.client = client;\n        this.logger = logger;\n        this.keychain = new Map();\n        this.name = KEYCHAIN_CONTEXT;\n        this.client = client;\n        this.logger = generateChildLogger(logger, this.name);\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    async init() {\n        await this.restore();\n    }\n    async has(tag, opts) {\n        return this.keychain.has(tag);\n    }\n    async set(tag, key, opts) {\n        this.keychain.set(tag, key);\n        await this.persist();\n    }\n    async get(tag, opts) {\n        const key = this.keychain.get(tag);\n        if (typeof key === \"undefined\") {\n            throw new Error(ERROR.NO_MATCHING_KEY.format({ tag }).message);\n        }\n        return key;\n    }\n    async del(tag, opts) {\n        this.keychain.delete(tag);\n        await this.persist();\n    }\n    async restore() {\n        const keychain = await this.client.storage.getKeyChain(this.context);\n        if (typeof keychain !== \"undefined\") {\n            this.keychain = keychain;\n        }\n    }\n    async persist() {\n        await this.client.storage.setKeyChain(this.context, this.keychain);\n    }\n}\nexport class Crypto {\n    constructor(client, logger, keychain) {\n        this.client = client;\n        this.logger = logger;\n        this.name = CRYPTO_CONTEXT;\n        this.client = client;\n        this.logger = generateChildLogger(logger, this.name);\n        this.keychain = keychain || new KeyChain(this.client, this.logger);\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    async init() {\n        await this.keychain.init();\n    }\n    async hasKeys(tag) {\n        return this.keychain.has(tag);\n    }\n    async generateKeyPair() {\n        const keyPair = generateKeyPair();\n        return this.setKeyPair(keyPair);\n    }\n    async generateSharedKey(self, peer, overrideTopic) {\n        const keyPair = await this.getKeyPair(self.publicKey);\n        const sharedKey = deriveSharedKey(keyPair.privateKey, peer.publicKey);\n        return this.setEncryptionKeys({ sharedKey, publicKey: keyPair.publicKey }, overrideTopic);\n    }\n    async encrypt(topic, message) {\n        const { sharedKey, publicKey } = await this.getEncryptionKeys(topic);\n        const result = await encrypt({ message, sharedKey, publicKey });\n        return result;\n    }\n    async decrypt(topic, encrypted) {\n        const { sharedKey } = await this.getEncryptionKeys(topic);\n        const result = await decrypt({ encrypted, sharedKey });\n        return result;\n    }\n    async encodeJsonRpc(topic, payload) {\n        const message = safeJsonStringify(payload);\n        const hasKeys = await this.hasKeys(topic);\n        const result = hasKeys ? await this.encrypt(topic, message) : encoding.utf8ToHex(message);\n        return result;\n    }\n    async decodeJsonRpc(topic, encrypted) {\n        const hasKeys = await this.hasKeys(topic);\n        const message = hasKeys ? await this.decrypt(topic, encrypted) : encoding.hexToUtf8(encrypted);\n        const payload = safeJsonParse(message);\n        return payload;\n    }\n    concatKeys(keyA, keyB) {\n        return encoding.arrayToHex(encoding.concatArrays(encoding.hexToArray(keyA), encoding.hexToArray(keyB)));\n    }\n    splitKeys(keys) {\n        const arr = encoding.hexToArray(keys);\n        return [encoding.arrayToHex(arr.slice(0, 32)), encoding.arrayToHex(arr.slice(32, 64))];\n    }\n    async setKeyPair(keyPair) {\n        const keys = this.concatKeys(keyPair.publicKey, keyPair.privateKey);\n        await this.keychain.set(keyPair.publicKey, keys);\n        return keyPair.publicKey;\n    }\n    async getKeyPair(publicKey) {\n        const [_, privateKey] = this.splitKeys(await this.keychain.get(publicKey));\n        return { publicKey, privateKey };\n    }\n    async setEncryptionKeys(encryptionKeys, overrideTopic) {\n        const topic = overrideTopic || (await sha256(encryptionKeys.sharedKey));\n        const keys = this.concatKeys(encryptionKeys.sharedKey, encryptionKeys.publicKey);\n        await this.keychain.set(topic, keys);\n        return topic;\n    }\n    async getEncryptionKeys(topic) {\n        const [sharedKey, publicKey] = this.splitKeys(await this.keychain.get(topic));\n        return { sharedKey, publicKey };\n    }\n}\n//# sourceMappingURL=crypto.js.map"]},"metadata":{},"sourceType":"module"}