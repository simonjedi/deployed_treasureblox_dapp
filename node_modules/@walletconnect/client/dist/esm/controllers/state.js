import { EventEmitter } from "events";
import { IState } from "@walletconnect/types";
import { ERROR, formatMessageContext } from "@walletconnect/utils";
import { STATE_EVENTS } from "../constants";
import { generateChildLogger, getLoggerContext } from "@walletconnect/logger";
export class State extends IState {
    constructor(client, logger, name) {
        super(client, logger, name);
        this.client = client;
        this.logger = logger;
        this.name = name;
        this.sequences = new Map();
        this.events = new EventEmitter();
        this.cached = [];
        this.logger = generateChildLogger(logger, this.name);
        this.registerEventListeners();
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.initialize();
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    get length() {
        return this.sequences.size;
    }
    get topics() {
        return Array.from(this.sequences.keys());
    }
    get values() {
        return Array.from(this.sequences.values());
    }
    async set(topic, sequence) {
        await this.isInitialized();
        if (this.sequences.has(topic)) {
            this.update(topic, sequence);
        }
        else {
            this.logger.debug(`Setting sequence`);
            this.logger.trace({ type: "method", method: "set", topic, sequence });
            this.sequences.set(topic, sequence);
            this.events.emit(STATE_EVENTS.created, {
                topic,
                sequence,
            });
        }
    }
    async get(topic) {
        await this.isInitialized();
        this.logger.debug(`Getting sequence`);
        this.logger.trace({ type: "method", method: "get", topic });
        const sequence = await this.getState(topic);
        return sequence;
    }
    async update(topic, update) {
        await this.isInitialized();
        this.logger.debug(`Updating sequence`);
        this.logger.trace({ type: "method", method: "update", topic, update });
        const sequence = Object.assign(Object.assign({}, (await this.getState(topic))), update);
        this.sequences.set(topic, sequence);
        this.events.emit(STATE_EVENTS.updated, {
            topic,
            sequence,
            update,
        });
    }
    async delete(topic, reason) {
        await this.isInitialized();
        if (!this.sequences.has(topic))
            return;
        this.logger.debug(`Deleting sequence`);
        this.logger.trace({ type: "method", method: "delete", topic, reason });
        const sequence = await this.getState(topic);
        this.sequences.delete(topic);
        this.events.emit(STATE_EVENTS.deleted, {
            topic,
            sequence,
            reason,
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async getState(topic) {
        await this.isInitialized();
        const sequence = this.sequences.get(topic);
        if (!sequence) {
            const error = ERROR.NO_MATCHING_TOPIC.format({
                context: formatMessageContext(this.context),
                topic,
            });
            this.logger.error(error.message);
            throw new Error(error.message);
        }
        return sequence;
    }
    async persist() {
        await this.client.storage.setSequenceState(this.context, this.values);
        this.events.emit(STATE_EVENTS.sync);
    }
    async restore() {
        try {
            const persisted = await this.client.storage.getSequenceState(this.context);
            if (typeof persisted === "undefined")
                return;
            if (!persisted.length)
                return;
            if (this.sequences.size) {
                const error = ERROR.RESTORE_WILL_OVERRIDE.format({
                    context: formatMessageContext(this.context),
                });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            this.cached = persisted;
            this.logger.debug(`Successfully Restored sequences for ${formatMessageContext(this.context)}`);
            this.logger.trace({ type: "method", method: "restore", sequences: this.values });
        }
        catch (e) {
            this.logger.debug(`Failed to Restore sequences for ${formatMessageContext(this.context)}`);
            this.logger.error(e);
        }
    }
    async initialize() {
        await this.restore();
        this.reset();
        this.onInit();
    }
    reset() {
        this.cached.forEach(sequence => this.sequences.set(sequence.topic, sequence));
    }
    onInit() {
        this.cached = [];
        this.events.emit(STATE_EVENTS.init);
    }
    async isInitialized() {
        if (!this.cached.length)
            return;
        return new Promise(resolve => {
            this.events.once(STATE_EVENTS.init, () => resolve());
        });
    }
    registerEventListeners() {
        this.events.on(STATE_EVENTS.created, (createdEvent) => {
            const eventName = STATE_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: createdEvent });
            this.persist();
        });
        this.events.on(STATE_EVENTS.updated, (updatedEvent) => {
            const eventName = STATE_EVENTS.updated;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: updatedEvent });
            this.persist();
        });
        this.events.on(STATE_EVENTS.deleted, (deletedEvent) => {
            const eventName = STATE_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
            this.persist();
        });
    }
}
//# sourceMappingURL=state.js.map