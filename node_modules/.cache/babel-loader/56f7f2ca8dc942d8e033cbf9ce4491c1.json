{"ast":null,"code":"var _toConsumableArray = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/toConsumableArray\");\n\nvar _regeneratorRuntime = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events');\n\nvar EthereumProvider = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(EthereumProvider, _EventEmitter);\n\n  var _super = _createSuper(EthereumProvider);\n\n  function EthereumProvider(connection) {\n    var _this;\n\n    _classCallCheck(this, EthereumProvider);\n\n    _this = _super.call(this);\n    _this.connected = false;\n    _this.nextId = 0;\n    _this.promises = {};\n    _this.subscriptions = [];\n    _this.connection = connection;\n\n    _this.connection.on('connect', function () {\n      return _this.checkConnection();\n    });\n\n    _this.connection.on('close', function () {\n      return _this.emit('close');\n    });\n\n    _this.connection.on('payload', function (payload) {\n      var id = payload.id,\n          method = payload.method,\n          error = payload.error,\n          result = payload.result;\n\n      if (typeof id !== 'undefined') {\n        if (_this.promises[id]) {\n          // Fulfill promise\n          payload.error ? _this.promises[id].reject(error) : _this.promises[id].resolve(result);\n          delete _this.promises[id];\n        }\n      } else if (method && method.indexOf('_subscription') > -1) {\n        // Emit subscription result\n        _this.emit(payload.params.subscription, payload.params.result);\n\n        _this.emit(method, payload.params); // Latest EIP-1193\n\n\n        _this.emit('data', payload); // Backwards Compatibility\n\n      }\n    });\n\n    _this.on('newListener', function (event, listener) {\n      if (event === 'networkChanged') {\n        if (!_this.attemptedNetworkSubscription && _this.connected) _this.startNetworkSubscription();\n      } else if (event === 'accountsChanged') {\n        if (!_this.attemptedAccountsSubscription && _this.connected) _this.startAccountsSubscription();\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(EthereumProvider, [{\n    key: \"checkConnection\",\n    value: function () {\n      var _checkConnection = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                _context.prev = 0;\n                _context.t0 = this;\n                _context.next = 4;\n                return this._send('net_version');\n\n              case 4:\n                _context.t1 = _context.sent;\n\n                _context.t0.emit.call(_context.t0, 'connect', _context.t1);\n\n                this.connected = true;\n                if (this.listenerCount('networkChanged') && !this.attemptedNetworkSubscription) this.startNetworkSubscription();\n                if (this.listenerCount('accountsChanged') && !this.attemptedAccountsSubscription) this.startAccountsSubscription();\n                _context.next = 14;\n                break;\n\n              case 11:\n                _context.prev = 11;\n                _context.t2 = _context[\"catch\"](0);\n                this.connected = false;\n\n              case 14:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[0, 11]]);\n      }));\n\n      function checkConnection() {\n        return _checkConnection.apply(this, arguments);\n      }\n\n      return checkConnection;\n    }()\n  }, {\n    key: \"startNetworkSubscription\",\n    value: function () {\n      var _startNetworkSubscription = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        var _this2 = this;\n\n        var networkChanged;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                this.attemptedNetworkSubscription = true;\n                _context2.prev = 1;\n                _context2.next = 4;\n                return this.subscribe('eth_subscribe', 'networkChanged');\n\n              case 4:\n                networkChanged = _context2.sent;\n                this.on(networkChanged, function (netId) {\n                  return _this2.emit('networkChanged', netId);\n                });\n                _context2.next = 11;\n                break;\n\n              case 8:\n                _context2.prev = 8;\n                _context2.t0 = _context2[\"catch\"](1);\n                console.warn('Unable to subscribe to networkChanged', _context2.t0);\n\n              case 11:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[1, 8]]);\n      }));\n\n      function startNetworkSubscription() {\n        return _startNetworkSubscription.apply(this, arguments);\n      }\n\n      return startNetworkSubscription;\n    }()\n  }, {\n    key: \"startAccountsSubscription\",\n    value: function () {\n      var _startAccountsSubscription = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this3 = this;\n\n        var accountsChanged;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                this.attemptedAccountsSubscription = true;\n                _context3.prev = 1;\n                _context3.next = 4;\n                return this.subscribe('eth_subscribe', 'accountsChanged');\n\n              case 4:\n                accountsChanged = _context3.sent;\n                this.on(accountsChanged, function (accounts) {\n                  return _this3.emit('accountsChanged', accounts);\n                });\n                _context3.next = 11;\n                break;\n\n              case 8:\n                _context3.prev = 8;\n                _context3.t0 = _context3[\"catch\"](1);\n                console.warn('Unable to subscribe to accountsChanged', _context3.t0);\n\n              case 11:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[1, 8]]);\n      }));\n\n      function startAccountsSubscription() {\n        return _startAccountsSubscription.apply(this, arguments);\n      }\n\n      return startAccountsSubscription;\n    }()\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      var _this4 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this4._send('eth_accounts').then(function (accounts) {\n          if (accounts.length > 0) {\n            _this4.accounts = accounts;\n            _this4.coinbase = accounts[0];\n\n            _this4.emit('enable');\n\n            resolve(accounts);\n          } else {\n            var err = new Error('User Denied Full Provider');\n            err.code = 4001;\n            reject(err);\n          }\n        }).catch(reject);\n      });\n    }\n  }, {\n    key: \"_send\",\n    value: function _send(method) {\n      var _this5 = this;\n\n      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      if (!method || typeof method !== 'string') return new Error('Method is not a valid string.');\n      if (!(params instanceof Array)) return new Error('Params is not a valid array.');\n      var payload = {\n        jsonrpc: '2.0',\n        id: this.nextId++,\n        method: method,\n        params: params\n      };\n      var promise = new Promise(function (resolve, reject) {\n        _this5.promises[payload.id] = {\n          resolve: resolve,\n          reject: reject\n        };\n      });\n      this.connection.send(payload);\n      return promise;\n    }\n  }, {\n    key: \"send\",\n    value: function send() {\n      // Send can be clobbered, proxy sendPromise for backwards compatibility\n      return this._send.apply(this, arguments);\n    }\n  }, {\n    key: \"_sendBatch\",\n    value: function _sendBatch(requests) {\n      var _this6 = this;\n\n      return Promise.all(requests.map(function (payload) {\n        return _this6._send(payload.method, payload.params);\n      }));\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(type, method) {\n      var _this7 = this;\n\n      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return this._send(type, [method].concat(_toConsumableArray(params))).then(function (id) {\n        _this7.subscriptions.push(id);\n\n        return id;\n      });\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(type, id) {\n      var _this8 = this;\n\n      return this._send(type, [id]).then(function (success) {\n        if (success) {\n          _this8.subscriptions = _this8.subscriptions.filter(function (_id) {\n            return _id !== id;\n          }); // Remove subscription\n\n          _this8.removeAllListeners(id); // Remove listeners\n\n\n          return success;\n        }\n      });\n    }\n  }, {\n    key: \"sendAsync\",\n    value: function sendAsync(payload, cb) {\n      // Backwards Compatibility\n      if (!cb || typeof cb !== 'function') return cb(new Error('Invalid or undefined callback provided to sendAsync'));\n      if (!payload) return cb(new Error('Invalid Payload')); // sendAsync can be called with an array for batch requests used by web3.js 0.x\n      // this is not part of EIP-1193's backwards compatibility but we still want to support it\n\n      if (payload instanceof Array) {\n        return this.sendAsyncBatch(payload, cb);\n      } else {\n        return this._send(payload.method, payload.params).then(function (result) {\n          cb(null, {\n            id: payload.id,\n            jsonrpc: payload.jsonrpc,\n            result: result\n          });\n        }).catch(function (err) {\n          cb(err);\n        });\n      }\n    }\n  }, {\n    key: \"sendAsyncBatch\",\n    value: function sendAsyncBatch(payload, cb) {\n      return this._sendBatch(payload).then(function (results) {\n        var result = results.map(function (entry, index) {\n          return {\n            id: payload[index].id,\n            jsonrpc: payload[index].jsonrpc,\n            result: entry\n          };\n        });\n        cb(null, result);\n      }).catch(function (err) {\n        cb(err);\n      });\n    }\n  }, {\n    key: \"isConnected\",\n    value: function isConnected() {\n      // Backwards Compatibility\n      return this.connected;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      var _this9 = this;\n\n      this.connection.close();\n      this.connected = false;\n      var error = new Error(\"Provider closed, subscription lost, please subscribe again.\");\n      this.subscriptions.forEach(function (id) {\n        return _this9.emit(id, error);\n      }); // Send Error objects to any open subscriptions\n\n      this.subscriptions = []; // Clear subscriptions\n    }\n  }]);\n\n  return EthereumProvider;\n}(EventEmitter);\n\nmodule.exports = EthereumProvider;","map":{"version":3,"sources":["/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/ethereum-provider/index.js"],"names":["EventEmitter","require","EthereumProvider","connection","connected","nextId","promises","subscriptions","on","checkConnection","emit","payload","id","method","error","result","reject","resolve","indexOf","params","subscription","event","listener","attemptedNetworkSubscription","startNetworkSubscription","attemptedAccountsSubscription","startAccountsSubscription","_send","listenerCount","subscribe","networkChanged","netId","console","warn","accountsChanged","accounts","Promise","then","length","coinbase","err","Error","code","catch","Array","jsonrpc","promise","send","requests","all","map","type","push","success","filter","_id","removeAllListeners","cb","sendAsyncBatch","_sendBatch","results","entry","index","close","forEach","module","exports"],"mappings":";;;;;;;;;;;;;;AAAA,IAAMA,YAAY,GAAGC,OAAO,CAAC,QAAD,CAA5B;;IAEMC,gB;;;;;;;AACJ,4BAAaC,UAAb,EAAyB;AAAA;;AAAA;;AACvB;AACA,UAAKC,SAAL,GAAiB,KAAjB;AACA,UAAKC,MAAL,GAAc,CAAd;AACA,UAAKC,QAAL,GAAgB,EAAhB;AACA,UAAKC,aAAL,GAAqB,EAArB;AACA,UAAKJ,UAAL,GAAkBA,UAAlB;;AACA,UAAKA,UAAL,CAAgBK,EAAhB,CAAmB,SAAnB,EAA8B;AAAA,aAAM,MAAKC,eAAL,EAAN;AAAA,KAA9B;;AACA,UAAKN,UAAL,CAAgBK,EAAhB,CAAmB,OAAnB,EAA4B;AAAA,aAAM,MAAKE,IAAL,CAAU,OAAV,CAAN;AAAA,KAA5B;;AACA,UAAKP,UAAL,CAAgBK,EAAhB,CAAmB,SAAnB,EAA8B,UAAAG,OAAO,EAAI;AACvC,UAAQC,EAAR,GAAsCD,OAAtC,CAAQC,EAAR;AAAA,UAAYC,MAAZ,GAAsCF,OAAtC,CAAYE,MAAZ;AAAA,UAAoBC,KAApB,GAAsCH,OAAtC,CAAoBG,KAApB;AAAA,UAA2BC,MAA3B,GAAsCJ,OAAtC,CAA2BI,MAA3B;;AACA,UAAI,OAAOH,EAAP,KAAc,WAAlB,EAA+B;AAC7B,YAAI,MAAKN,QAAL,CAAcM,EAAd,CAAJ,EAAuB;AAAE;AACvBD,UAAAA,OAAO,CAACG,KAAR,GAAgB,MAAKR,QAAL,CAAcM,EAAd,EAAkBI,MAAlB,CAAyBF,KAAzB,CAAhB,GAAkD,MAAKR,QAAL,CAAcM,EAAd,EAAkBK,OAAlB,CAA0BF,MAA1B,CAAlD;AACA,iBAAO,MAAKT,QAAL,CAAcM,EAAd,CAAP;AACD;AACF,OALD,MAKO,IAAIC,MAAM,IAAIA,MAAM,CAACK,OAAP,CAAe,eAAf,IAAkC,CAAC,CAAjD,EAAoD;AAAE;AAC3D,cAAKR,IAAL,CAAUC,OAAO,CAACQ,MAAR,CAAeC,YAAzB,EAAuCT,OAAO,CAACQ,MAAR,CAAeJ,MAAtD;;AACA,cAAKL,IAAL,CAAUG,MAAV,EAAkBF,OAAO,CAACQ,MAA1B,EAFyD,CAEvB;;;AAClC,cAAKT,IAAL,CAAU,MAAV,EAAkBC,OAAlB,EAHyD,CAG9B;;AAC5B;AACF,KAZD;;AAaA,UAAKH,EAAL,CAAQ,aAAR,EAAuB,UAACa,KAAD,EAAQC,QAAR,EAAqB;AAC1C,UAAID,KAAK,KAAK,gBAAd,EAAgC;AAC9B,YAAI,CAAC,MAAKE,4BAAN,IAAsC,MAAKnB,SAA/C,EAA0D,MAAKoB,wBAAL;AAC3D,OAFD,MAEO,IAAIH,KAAK,KAAK,iBAAd,EAAiC;AACtC,YAAI,CAAC,MAAKI,6BAAN,IAAuC,MAAKrB,SAAhD,EAA2D,MAAKsB,yBAAL;AAC5D;AACF,KAND;;AAtBuB;AA6BxB;;;;;sFACD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,8BAEI,IAFJ;AAAA;AAAA,uBAE+B,KAAKC,KAAL,CAAW,aAAX,CAF/B;;AAAA;AAAA;;AAAA,4BAESjB,IAFT,mBAEc,SAFd;;AAGI,qBAAKN,SAAL,GAAiB,IAAjB;AACA,oBAAI,KAAKwB,aAAL,CAAmB,gBAAnB,KAAwC,CAAC,KAAKL,4BAAlD,EAAgF,KAAKC,wBAAL;AAChF,oBAAI,KAAKI,aAAL,CAAmB,iBAAnB,KAAyC,CAAC,KAAKH,6BAAnD,EAAkF,KAAKC,yBAAL;AALtF;AAAA;;AAAA;AAAA;AAAA;AAOI,qBAAKtB,SAAL,GAAiB,KAAjB;;AAPJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;+FAUA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,qBAAKmB,4BAAL,GAAoC,IAApC;AADF;AAAA;AAAA,uBAG+B,KAAKM,SAAL,CAAe,eAAf,EAAgC,gBAAhC,CAH/B;;AAAA;AAGQC,gBAAAA,cAHR;AAII,qBAAKtB,EAAL,CAAQsB,cAAR,EAAwB,UAAAC,KAAK;AAAA,yBAAI,MAAI,CAACrB,IAAL,CAAU,gBAAV,EAA4BqB,KAA5B,CAAJ;AAAA,iBAA7B;AAJJ;AAAA;;AAAA;AAAA;AAAA;AAMIC,gBAAAA,OAAO,CAACC,IAAR,CAAa,uCAAb;;AANJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;;gGASA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AACE,qBAAKR,6BAAL,GAAqC,IAArC;AADF;AAAA;AAAA,uBAGgC,KAAKI,SAAL,CAAe,eAAf,EAAgC,iBAAhC,CAHhC;;AAAA;AAGQK,gBAAAA,eAHR;AAII,qBAAK1B,EAAL,CAAQ0B,eAAR,EAAyB,UAAAC,QAAQ;AAAA,yBAAI,MAAI,CAACzB,IAAL,CAAU,iBAAV,EAA6ByB,QAA7B,CAAJ;AAAA,iBAAjC;AAJJ;AAAA;;AAAA;AAAA;AAAA;AAMIH,gBAAAA,OAAO,CAACC,IAAR,CAAa,wCAAb;;AANJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,O;;;;;;;;;;WASA,kBAAU;AAAA;;AACR,aAAO,IAAIG,OAAJ,CAAY,UAACnB,OAAD,EAAUD,MAAV,EAAqB;AACtC,QAAA,MAAI,CAACW,KAAL,CAAW,cAAX,EAA2BU,IAA3B,CAAgC,UAAAF,QAAQ,EAAI;AAC1C,cAAIA,QAAQ,CAACG,MAAT,GAAkB,CAAtB,EAAyB;AACvB,YAAA,MAAI,CAACH,QAAL,GAAgBA,QAAhB;AACA,YAAA,MAAI,CAACI,QAAL,GAAgBJ,QAAQ,CAAC,CAAD,CAAxB;;AACA,YAAA,MAAI,CAACzB,IAAL,CAAU,QAAV;;AACAO,YAAAA,OAAO,CAACkB,QAAD,CAAP;AACD,WALD,MAKO;AACL,gBAAMK,GAAG,GAAG,IAAIC,KAAJ,CAAU,2BAAV,CAAZ;AACAD,YAAAA,GAAG,CAACE,IAAJ,GAAW,IAAX;AACA1B,YAAAA,MAAM,CAACwB,GAAD,CAAN;AACD;AACF,SAXD,EAWGG,KAXH,CAWS3B,MAXT;AAYD,OAbM,CAAP;AAcD;;;WACD,eAAOH,MAAP,EAA4B;AAAA;;AAAA,UAAbM,MAAa,uEAAJ,EAAI;AAC1B,UAAI,CAACN,MAAD,IAAW,OAAOA,MAAP,KAAkB,QAAjC,EAA2C,OAAO,IAAI4B,KAAJ,CAAU,+BAAV,CAAP;AAC3C,UAAI,EAAEtB,MAAM,YAAYyB,KAApB,CAAJ,EAAgC,OAAO,IAAIH,KAAJ,CAAU,8BAAV,CAAP;AAChC,UAAM9B,OAAO,GAAG;AAAEkC,QAAAA,OAAO,EAAE,KAAX;AAAkBjC,QAAAA,EAAE,EAAE,KAAKP,MAAL,EAAtB;AAAqCQ,QAAAA,MAAM,EAANA,MAArC;AAA6CM,QAAAA,MAAM,EAANA;AAA7C,OAAhB;AACA,UAAM2B,OAAO,GAAG,IAAIV,OAAJ,CAAY,UAACnB,OAAD,EAAUD,MAAV,EAAqB;AAAE,QAAA,MAAI,CAACV,QAAL,CAAcK,OAAO,CAACC,EAAtB,IAA4B;AAAEK,UAAAA,OAAO,EAAPA,OAAF;AAAWD,UAAAA,MAAM,EAANA;AAAX,SAA5B;AAAiD,OAApF,CAAhB;AACA,WAAKb,UAAL,CAAgB4C,IAAhB,CAAqBpC,OAArB;AACA,aAAOmC,OAAP;AACD;;;WACD,gBAAe;AAAE;AACf,aAAO,KAAKnB,KAAL,uBAAP;AACD;;;WACD,oBAAYqB,QAAZ,EAAsB;AAAA;;AACpB,aAAOZ,OAAO,CAACa,GAAR,CAAYD,QAAQ,CAACE,GAAT,CAAa,UAAAvC,OAAO;AAAA,eAAI,MAAI,CAACgB,KAAL,CAAWhB,OAAO,CAACE,MAAnB,EAA2BF,OAAO,CAACQ,MAAnC,CAAJ;AAAA,OAApB,CAAZ,CAAP;AACD;;;WACD,mBAAWgC,IAAX,EAAiBtC,MAAjB,EAAsC;AAAA;;AAAA,UAAbM,MAAa,uEAAJ,EAAI;AACpC,aAAO,KAAKQ,KAAL,CAAWwB,IAAX,GAAkBtC,MAAlB,4BAA6BM,MAA7B,IAAsCkB,IAAtC,CAA2C,UAAAzB,EAAE,EAAI;AACtD,QAAA,MAAI,CAACL,aAAL,CAAmB6C,IAAnB,CAAwBxC,EAAxB;;AACA,eAAOA,EAAP;AACD,OAHM,CAAP;AAID;;;WACD,qBAAauC,IAAb,EAAmBvC,EAAnB,EAAuB;AAAA;;AACrB,aAAO,KAAKe,KAAL,CAAWwB,IAAX,EAAiB,CAACvC,EAAD,CAAjB,EAAuByB,IAAvB,CAA4B,UAAAgB,OAAO,EAAI;AAC5C,YAAIA,OAAJ,EAAa;AACX,UAAA,MAAI,CAAC9C,aAAL,GAAqB,MAAI,CAACA,aAAL,CAAmB+C,MAAnB,CAA0B,UAAAC,GAAG;AAAA,mBAAIA,GAAG,KAAK3C,EAAZ;AAAA,WAA7B,CAArB,CADW,CACuD;;AAClE,UAAA,MAAI,CAAC4C,kBAAL,CAAwB5C,EAAxB,EAFW,CAEiB;;;AAC5B,iBAAOyC,OAAP;AACD;AACF,OANM,CAAP;AAOD;;;WACD,mBAAW1C,OAAX,EAAoB8C,EAApB,EAAwB;AAAE;AACxB,UAAI,CAACA,EAAD,IAAO,OAAOA,EAAP,KAAc,UAAzB,EAAqC,OAAOA,EAAE,CAAC,IAAIhB,KAAJ,CAAU,qDAAV,CAAD,CAAT;AACrC,UAAI,CAAC9B,OAAL,EAAc,OAAO8C,EAAE,CAAC,IAAIhB,KAAJ,CAAU,iBAAV,CAAD,CAAT,CAFQ,CAGtB;AACA;;AACA,UAAI9B,OAAO,YAAYiC,KAAvB,EAA8B;AAC5B,eAAO,KAAKc,cAAL,CAAoB/C,OAApB,EAA6B8C,EAA7B,CAAP;AACD,OAFD,MAEO;AACL,eAAO,KAAK9B,KAAL,CAAWhB,OAAO,CAACE,MAAnB,EAA2BF,OAAO,CAACQ,MAAnC,EAA2CkB,IAA3C,CAAgD,UAAAtB,MAAM,EAAI;AAC/D0C,UAAAA,EAAE,CAAC,IAAD,EAAO;AAAE7C,YAAAA,EAAE,EAAED,OAAO,CAACC,EAAd;AAAkBiC,YAAAA,OAAO,EAAElC,OAAO,CAACkC,OAAnC;AAA4C9B,YAAAA,MAAM,EAANA;AAA5C,WAAP,CAAF;AACD,SAFM,EAEJ4B,KAFI,CAEE,UAAAH,GAAG,EAAI;AACdiB,UAAAA,EAAE,CAACjB,GAAD,CAAF;AACD,SAJM,CAAP;AAKD;AACF;;;WACD,wBAAgB7B,OAAhB,EAAyB8C,EAAzB,EAA6B;AAC3B,aAAO,KAAKE,UAAL,CAAgBhD,OAAhB,EAAyB0B,IAAzB,CAA8B,UAACuB,OAAD,EAAa;AAChD,YAAI7C,MAAM,GAAG6C,OAAO,CAACV,GAAR,CAAY,UAACW,KAAD,EAAQC,KAAR,EAAkB;AACzC,iBAAO;AAAElD,YAAAA,EAAE,EAAED,OAAO,CAACmD,KAAD,CAAP,CAAelD,EAArB;AAAyBiC,YAAAA,OAAO,EAAElC,OAAO,CAACmD,KAAD,CAAP,CAAejB,OAAjD;AAA0D9B,YAAAA,MAAM,EAAE8C;AAAlE,WAAP;AACD,SAFY,CAAb;AAGAJ,QAAAA,EAAE,CAAC,IAAD,EAAO1C,MAAP,CAAF;AACD,OALM,EAKJ4B,KALI,CAKE,UAAAH,GAAG,EAAI;AACdiB,QAAAA,EAAE,CAACjB,GAAD,CAAF;AACD,OAPM,CAAP;AAQD;;;WACD,uBAAe;AAAE;AACf,aAAO,KAAKpC,SAAZ;AACD;;;WACD,iBAAS;AAAA;;AACP,WAAKD,UAAL,CAAgB4D,KAAhB;AACA,WAAK3D,SAAL,GAAiB,KAAjB;AACA,UAAIU,KAAK,GAAG,IAAI2B,KAAJ,+DAAZ;AACA,WAAKlC,aAAL,CAAmByD,OAAnB,CAA2B,UAAApD,EAAE;AAAA,eAAI,MAAI,CAACF,IAAL,CAAUE,EAAV,EAAcE,KAAd,CAAJ;AAAA,OAA7B,EAJO,CAIgD;;AACvD,WAAKP,aAAL,GAAqB,EAArB,CALO,CAKiB;AACzB;;;;EA1I4BP,Y;;AA6I/BiE,MAAM,CAACC,OAAP,GAAiBhE,gBAAjB","sourcesContent":["const EventEmitter = require('events')\n\nclass EthereumProvider extends EventEmitter {\n  constructor (connection) {\n    super()\n    this.connected = false\n    this.nextId = 0\n    this.promises = {}\n    this.subscriptions = []\n    this.connection = connection\n    this.connection.on('connect', () => this.checkConnection())\n    this.connection.on('close', () => this.emit('close'))\n    this.connection.on('payload', payload => {\n      const { id, method, error, result } = payload\n      if (typeof id !== 'undefined') {\n        if (this.promises[id]) { // Fulfill promise\n          payload.error ? this.promises[id].reject(error) : this.promises[id].resolve(result)\n          delete this.promises[id]\n        }\n      } else if (method && method.indexOf('_subscription') > -1) { // Emit subscription result\n        this.emit(payload.params.subscription, payload.params.result)\n        this.emit(method, payload.params) // Latest EIP-1193\n        this.emit('data', payload) // Backwards Compatibility\n      }\n    })\n    this.on('newListener', (event, listener) => {\n      if (event === 'networkChanged') {\n        if (!this.attemptedNetworkSubscription && this.connected) this.startNetworkSubscription()\n      } else if (event === 'accountsChanged') {\n        if (!this.attemptedAccountsSubscription && this.connected) this.startAccountsSubscription()\n      }\n    })\n  }\n  async checkConnection () {\n    try {\n      this.emit('connect', await this._send('net_version'))\n      this.connected = true\n      if (this.listenerCount('networkChanged') && !this.attemptedNetworkSubscription) this.startNetworkSubscription()\n      if (this.listenerCount('accountsChanged') && !this.attemptedAccountsSubscription) this.startAccountsSubscription()\n    } catch (e) {\n      this.connected = false\n    }\n  }\n  async startNetworkSubscription () {\n    this.attemptedNetworkSubscription = true\n    try {\n      let networkChanged = await this.subscribe('eth_subscribe', 'networkChanged')\n      this.on(networkChanged, netId => this.emit('networkChanged', netId))\n    } catch (e) {\n      console.warn('Unable to subscribe to networkChanged', e)\n    }\n  }\n  async startAccountsSubscription () {\n    this.attemptedAccountsSubscription = true\n    try {\n      let accountsChanged = await this.subscribe('eth_subscribe', 'accountsChanged')\n      this.on(accountsChanged, accounts => this.emit('accountsChanged', accounts))\n    } catch (e) {\n      console.warn('Unable to subscribe to accountsChanged', e)\n    }\n  }\n  enable () {\n    return new Promise((resolve, reject) => {\n      this._send('eth_accounts').then(accounts => {\n        if (accounts.length > 0) {\n          this.accounts = accounts\n          this.coinbase = accounts[0]\n          this.emit('enable')\n          resolve(accounts)\n        } else {\n          const err = new Error('User Denied Full Provider')\n          err.code = 4001\n          reject(err)\n        }\n      }).catch(reject)\n    })\n  }\n  _send (method, params = []) {\n    if (!method || typeof method !== 'string') return new Error('Method is not a valid string.')\n    if (!(params instanceof Array)) return new Error('Params is not a valid array.')\n    const payload = { jsonrpc: '2.0', id: this.nextId++, method, params }\n    const promise = new Promise((resolve, reject) => { this.promises[payload.id] = { resolve, reject } })\n    this.connection.send(payload)\n    return promise\n  }\n  send (...args) { // Send can be clobbered, proxy sendPromise for backwards compatibility\n    return this._send(...args)\n  }\n  _sendBatch (requests) {\n    return Promise.all(requests.map(payload => this._send(payload.method, payload.params)))\n  }\n  subscribe (type, method, params = []) {\n    return this._send(type, [method, ...params]).then(id => {\n      this.subscriptions.push(id)\n      return id\n    })\n  }\n  unsubscribe (type, id) {\n    return this._send(type, [id]).then(success => {\n      if (success) {\n        this.subscriptions = this.subscriptions.filter(_id => _id !== id) // Remove subscription\n        this.removeAllListeners(id) // Remove listeners\n        return success\n      }\n    })\n  }\n  sendAsync (payload, cb) { // Backwards Compatibility\n    if (!cb || typeof cb !== 'function') return cb(new Error('Invalid or undefined callback provided to sendAsync'))\n    if (!payload) return cb(new Error('Invalid Payload'))\n    // sendAsync can be called with an array for batch requests used by web3.js 0.x\n    // this is not part of EIP-1193's backwards compatibility but we still want to support it\n    if (payload instanceof Array) {\n      return this.sendAsyncBatch(payload, cb)\n    } else {\n      return this._send(payload.method, payload.params).then(result => {\n        cb(null, { id: payload.id, jsonrpc: payload.jsonrpc, result })\n      }).catch(err => {\n        cb(err)\n      })\n    }\n  }\n  sendAsyncBatch (payload, cb) {\n    return this._sendBatch(payload).then((results) => {\n      let result = results.map((entry, index) => {\n        return { id: payload[index].id, jsonrpc: payload[index].jsonrpc, result: entry }\n      })\n      cb(null, result)\n    }).catch(err => {\n      cb(err)\n    })\n  }\n  isConnected () { // Backwards Compatibility\n    return this.connected\n  }\n  close () {\n    this.connection.close()\n    this.connected = false\n    let error = new Error(`Provider closed, subscription lost, please subscribe again.`)\n    this.subscriptions.forEach(id => this.emit(id, error)) // Send Error objects to any open subscriptions\n    this.subscriptions = [] // Clear subscriptions\n  }\n}\n\nmodule.exports = EthereumProvider\n"]},"metadata":{},"sourceType":"script"}