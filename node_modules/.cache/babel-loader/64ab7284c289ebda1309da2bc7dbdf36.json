{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CommentEncryptionUtils = exports.decryptComment = exports.encryptComment = exports.decryptData = exports.encryptData = void 0;\n\nvar crypto_1 = require(\"crypto\");\n\nvar dataEncryptionKey_1 = require(\"./dataEncryptionKey\");\n\nvar ecies_1 = require(\"./ecies\");\n\nvar ECIES_SESSION_KEY_LEN = 129;\nvar MIN_COMMENT_KEY_LENGTH = 33;\nvar TAG = 'CommentEncryption';\n/**\n * Encrypts a buffer to two recipients. Throws on error.\n *\n * @param {Buffer} data Data to encrypt\n * @param {Buffer} pubKeyRecipient Public key of the recipient. Uncompressed without leading 0x04.\n * @param {Buffer} pubKeySelf Public key of the sender. Uncompressed without leading 0x04.\n * @returns {Buffer} Encrypted data to sender and recipient.\n */\n\nfunction encryptData(data, pubKeyRecipient, pubKeySelf) {\n  var sessionKey = (0, crypto_1.randomBytes)(16);\n  var sessionKeyToSelf = (0, ecies_1.Encrypt)(pubKeySelf, sessionKey);\n  var sessionKeyToOther = (0, ecies_1.Encrypt)(pubKeyRecipient, sessionKey);\n  var ciphertext = (0, ecies_1.AES128EncryptAndHMAC)(sessionKey, sessionKey, data);\n  return Buffer.concat([sessionKeyToOther, sessionKeyToSelf, ciphertext]);\n}\n\nexports.encryptData = encryptData;\n/**\n * Decrypts raw data that was encrypted by encryptData. Throws on error.\n *\n * @param {Buffer} data Data to decrypt.\n * @param {Buffer} key Private key to decrypt the message with.\n * @param {boolean} sender If the decryptor is the sender of the message.\n * @returns {Buffer} Decrypted data.\n */\n\nfunction decryptData(data, key, sender) {\n  // Deal with presumably enencrypted comments\n  if (data.length < ECIES_SESSION_KEY_LEN * 2 + 48) {\n    throw new Error('Buffer length too short');\n  }\n\n  var sessionKeyEncrypted = sender ? data.slice(ECIES_SESSION_KEY_LEN, ECIES_SESSION_KEY_LEN * 2) : data.slice(0, ECIES_SESSION_KEY_LEN);\n  var sessionKey = (0, ecies_1.Decrypt)(key, sessionKeyEncrypted);\n  var encryptedMessage = data.slice(ECIES_SESSION_KEY_LEN * 2);\n  return (0, ecies_1.AES128DecryptAndHMAC)(sessionKey, sessionKey, encryptedMessage);\n}\n\nexports.decryptData = decryptData;\n/**\n * Encrypts a comment. If it can encrypt, it returns a base64 string with the following:\n *    ECIES(session key to other) + ECIES(session key to self) + AES(comment)\n * If it fails to encrypt, it returns the comment without any changes.\n *\n * @param {string} comment Comment to encrypt.\n * @param {Buffer} pubKeyRecipient Public key of the recipient. May be compressed.\n * @param {Buffer} pubKeySelf Public key of the sender. May be compressed.\n * @returns {string} base64 string of encrypted comment if can encrypt, otherwise comment.\n */\n\nfunction encryptComment(comment, pubKeyRecipient, pubKeySelf) {\n  try {\n    if (pubKeyRecipient.length < MIN_COMMENT_KEY_LENGTH || pubKeySelf.length < MIN_COMMENT_KEY_LENGTH) {\n      throw new Error('Comment key too short');\n    } // Uncompress public keys & strip out the leading 0x04\n\n\n    var pubRecip = (0, dataEncryptionKey_1.decompressPublicKey)(pubKeyRecipient);\n    var pubSelf = (0, dataEncryptionKey_1.decompressPublicKey)(pubKeySelf);\n    var data = encryptData(Buffer.from(comment, 'ucs2'), pubRecip, pubSelf).toString('base64');\n    return {\n      success: true,\n      comment: data\n    };\n  } catch (e) {\n    console.info(TAG + \"/Error encrypting comment: \" + e);\n    return {\n      success: false,\n      comment: comment\n    };\n  }\n}\n\nexports.encryptComment = encryptComment;\n/**\n * Decrypts a comments encrypted by encryptComment. If it cannot decrypt the comment (i.e. comment was\n * never encrypted in the first place), it returns the comments without any changes.\n *\n * @param {string} comment Comment to decrypt. If encrypted, base64 encoded. May be plaintext.\n * @param {Buffer} key Private key to decrypt the message with.\n * @param {boolean} sender If the decryptor is the sender of the message.\n * @returns {string} Decrypted comment if can decrypt, otherwise comment.\n */\n\nfunction decryptComment(comment, key, sender) {\n  try {\n    var buf = Buffer.from(comment, 'base64');\n    var data = decryptData(buf, key, sender).toString('ucs2');\n    return {\n      success: true,\n      comment: data\n    };\n  } catch (error) {\n    console.info(TAG + \"/Could not decrypt: \" + error.message);\n    return {\n      success: false,\n      comment: comment\n    };\n  }\n}\n\nexports.decryptComment = decryptComment;\nexports.CommentEncryptionUtils = {\n  encryptComment: encryptComment,\n  decryptComment: decryptComment\n};","map":{"version":3,"sources":["../src/commentEncryption.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,QAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AACA,IAAA,mBAAA,GAAA,OAAA,CAAA,qBAAA,CAAA;;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,SAAA,CAAA;;AAOA,IAAM,qBAAqB,GAAG,GAA9B;AACA,IAAM,sBAAsB,GAAG,EAA/B;AACA,IAAM,GAAG,GAAG,mBAAZ;AAOA;;;;;;;AAOG;;AACH,SAAgB,WAAhB,CAA4B,IAA5B,EAA0C,eAA1C,EAAmE,UAAnE,EAAqF;AACnF,MAAM,UAAU,GAAW,CAAA,GAAA,QAAA,CAAA,WAAA,EAAY,EAAZ,CAA3B;AACA,MAAM,gBAAgB,GAAW,CAAA,GAAA,OAAA,CAAA,OAAA,EAAa,UAAb,EAAyB,UAAzB,CAAjC;AACA,MAAM,iBAAiB,GAAW,CAAA,GAAA,OAAA,CAAA,OAAA,EAAa,eAAb,EAA8B,UAA9B,CAAlC;AACA,MAAM,UAAU,GAAG,CAAA,GAAA,OAAA,CAAA,oBAAA,EAAqB,UAArB,EAAiC,UAAjC,EAA6C,IAA7C,CAAnB;AAEA,SAAO,MAAM,CAAC,MAAP,CAAc,CAAC,iBAAD,EAAoB,gBAApB,EAAsC,UAAtC,CAAd,CAAP;AACD;;AAPD,OAAA,CAAA,WAAA,GAAA,WAAA;AASA;;;;;;;AAOG;;AAEH,SAAgB,WAAhB,CAA4B,IAA5B,EAA0C,GAA1C,EAAuD,MAAvD,EAAsE;AACpE;AACA,MAAI,IAAI,CAAC,MAAL,GAAc,qBAAqB,GAAG,CAAxB,GAA4B,EAA9C,EAAkD;AAChD,UAAM,IAAI,KAAJ,CAAU,yBAAV,CAAN;AACD;;AACD,MAAM,mBAAmB,GAAG,MAAM,GAC9B,IAAI,CAAC,KAAL,CAAW,qBAAX,EAAkC,qBAAqB,GAAG,CAA1D,CAD8B,GAE9B,IAAI,CAAC,KAAL,CAAW,CAAX,EAAc,qBAAd,CAFJ;AAGA,MAAM,UAAU,GAAG,CAAA,GAAA,OAAA,CAAA,OAAA,EAAa,GAAb,EAAkB,mBAAlB,CAAnB;AAEA,MAAM,gBAAgB,GAAG,IAAI,CAAC,KAAL,CAAW,qBAAqB,GAAG,CAAnC,CAAzB;AACA,SAAO,CAAA,GAAA,OAAA,CAAA,oBAAA,EAAqB,UAArB,EAAiC,UAAjC,EAA6C,gBAA7C,CAAP;AACD;;AAZD,OAAA,CAAA,WAAA,GAAA,WAAA;AAcA;;;;;;;;;AASG;;AACH,SAAgB,cAAhB,CACE,OADF,EAEE,eAFF,EAGE,UAHF,EAGoB;AAElB,MAAI;AACF,QACE,eAAe,CAAC,MAAhB,GAAyB,sBAAzB,IACA,UAAU,CAAC,MAAX,GAAoB,sBAFtB,EAGE;AACA,YAAM,IAAI,KAAJ,CAAU,uBAAV,CAAN;AACD,KANC,CAOF;;;AACA,QAAM,QAAQ,GAAG,CAAA,GAAA,mBAAA,CAAA,mBAAA,EAAoB,eAApB,CAAjB;AACA,QAAM,OAAO,GAAG,CAAA,GAAA,mBAAA,CAAA,mBAAA,EAAoB,UAApB,CAAhB;AACA,QAAM,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,MAArB,CAAD,EAA+B,QAA/B,EAAyC,OAAzC,CAAX,CAA6D,QAA7D,CAAsE,QAAtE,CAAb;AACA,WAAO;AACL,MAAA,OAAO,EAAE,IADJ;AAEL,MAAA,OAAO,EAAE;AAFJ,KAAP;AAID,GAfD,CAeE,OAAO,CAAP,EAAU;AACV,IAAA,OAAO,CAAC,IAAR,CAAgB,GAAG,GAAA,6BAAH,GAAiC,CAAjD;AACA,WAAO;AAAE,MAAA,OAAO,EAAE,KAAX;AAAkB,MAAA,OAAO,EAAA;AAAzB,KAAP;AACD;AACF;;AAxBD,OAAA,CAAA,cAAA,GAAA,cAAA;AA0BA;;;;;;;;AAQG;;AACH,SAAgB,cAAhB,CAA+B,OAA/B,EAAgD,GAAhD,EAA6D,MAA7D,EAA4E;AAC1E,MAAI;AACF,QAAM,GAAG,GAAG,MAAM,CAAC,IAAP,CAAY,OAAZ,EAAqB,QAArB,CAAZ;AACA,QAAM,IAAI,GAAG,WAAW,CAAC,GAAD,EAAM,GAAN,EAAW,MAAX,CAAX,CAA8B,QAA9B,CAAuC,MAAvC,CAAb;AACA,WAAO;AAAE,MAAA,OAAO,EAAE,IAAX;AAAiB,MAAA,OAAO,EAAE;AAA1B,KAAP;AACD,GAJD,CAIE,OAAO,KAAP,EAAmB;AACnB,IAAA,OAAO,CAAC,IAAR,CAAgB,GAAG,GAAA,sBAAH,GAA0B,KAAK,CAAC,OAAhD;AACA,WAAO;AAAE,MAAA,OAAO,EAAE,KAAX;AAAkB,MAAA,OAAO,EAAA;AAAzB,KAAP;AACD;AACF;;AATD,OAAA,CAAA,cAAA,GAAA,cAAA;AAWa,OAAA,CAAA,sBAAA,GAAyB;AACpC,EAAA,cAAc,EAAA,cADsB;AAEpC,EAAA,cAAc,EAAA;AAFsB,CAAzB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CommentEncryptionUtils = exports.decryptComment = exports.encryptComment = exports.decryptData = exports.encryptData = void 0;\nvar crypto_1 = require(\"crypto\");\nvar dataEncryptionKey_1 = require(\"./dataEncryptionKey\");\nvar ecies_1 = require(\"./ecies\");\nvar ECIES_SESSION_KEY_LEN = 129;\nvar MIN_COMMENT_KEY_LENGTH = 33;\nvar TAG = 'CommentEncryption';\n/**\n * Encrypts a buffer to two recipients. Throws on error.\n *\n * @param {Buffer} data Data to encrypt\n * @param {Buffer} pubKeyRecipient Public key of the recipient. Uncompressed without leading 0x04.\n * @param {Buffer} pubKeySelf Public key of the sender. Uncompressed without leading 0x04.\n * @returns {Buffer} Encrypted data to sender and recipient.\n */\nfunction encryptData(data, pubKeyRecipient, pubKeySelf) {\n    var sessionKey = (0, crypto_1.randomBytes)(16);\n    var sessionKeyToSelf = (0, ecies_1.Encrypt)(pubKeySelf, sessionKey);\n    var sessionKeyToOther = (0, ecies_1.Encrypt)(pubKeyRecipient, sessionKey);\n    var ciphertext = (0, ecies_1.AES128EncryptAndHMAC)(sessionKey, sessionKey, data);\n    return Buffer.concat([sessionKeyToOther, sessionKeyToSelf, ciphertext]);\n}\nexports.encryptData = encryptData;\n/**\n * Decrypts raw data that was encrypted by encryptData. Throws on error.\n *\n * @param {Buffer} data Data to decrypt.\n * @param {Buffer} key Private key to decrypt the message with.\n * @param {boolean} sender If the decryptor is the sender of the message.\n * @returns {Buffer} Decrypted data.\n */\nfunction decryptData(data, key, sender) {\n    // Deal with presumably enencrypted comments\n    if (data.length < ECIES_SESSION_KEY_LEN * 2 + 48) {\n        throw new Error('Buffer length too short');\n    }\n    var sessionKeyEncrypted = sender\n        ? data.slice(ECIES_SESSION_KEY_LEN, ECIES_SESSION_KEY_LEN * 2)\n        : data.slice(0, ECIES_SESSION_KEY_LEN);\n    var sessionKey = (0, ecies_1.Decrypt)(key, sessionKeyEncrypted);\n    var encryptedMessage = data.slice(ECIES_SESSION_KEY_LEN * 2);\n    return (0, ecies_1.AES128DecryptAndHMAC)(sessionKey, sessionKey, encryptedMessage);\n}\nexports.decryptData = decryptData;\n/**\n * Encrypts a comment. If it can encrypt, it returns a base64 string with the following:\n *    ECIES(session key to other) + ECIES(session key to self) + AES(comment)\n * If it fails to encrypt, it returns the comment without any changes.\n *\n * @param {string} comment Comment to encrypt.\n * @param {Buffer} pubKeyRecipient Public key of the recipient. May be compressed.\n * @param {Buffer} pubKeySelf Public key of the sender. May be compressed.\n * @returns {string} base64 string of encrypted comment if can encrypt, otherwise comment.\n */\nfunction encryptComment(comment, pubKeyRecipient, pubKeySelf) {\n    try {\n        if (pubKeyRecipient.length < MIN_COMMENT_KEY_LENGTH ||\n            pubKeySelf.length < MIN_COMMENT_KEY_LENGTH) {\n            throw new Error('Comment key too short');\n        }\n        // Uncompress public keys & strip out the leading 0x04\n        var pubRecip = (0, dataEncryptionKey_1.decompressPublicKey)(pubKeyRecipient);\n        var pubSelf = (0, dataEncryptionKey_1.decompressPublicKey)(pubKeySelf);\n        var data = encryptData(Buffer.from(comment, 'ucs2'), pubRecip, pubSelf).toString('base64');\n        return {\n            success: true,\n            comment: data,\n        };\n    }\n    catch (e) {\n        console.info(TAG + \"/Error encrypting comment: \" + e);\n        return { success: false, comment: comment };\n    }\n}\nexports.encryptComment = encryptComment;\n/**\n * Decrypts a comments encrypted by encryptComment. If it cannot decrypt the comment (i.e. comment was\n * never encrypted in the first place), it returns the comments without any changes.\n *\n * @param {string} comment Comment to decrypt. If encrypted, base64 encoded. May be plaintext.\n * @param {Buffer} key Private key to decrypt the message with.\n * @param {boolean} sender If the decryptor is the sender of the message.\n * @returns {string} Decrypted comment if can decrypt, otherwise comment.\n */\nfunction decryptComment(comment, key, sender) {\n    try {\n        var buf = Buffer.from(comment, 'base64');\n        var data = decryptData(buf, key, sender).toString('ucs2');\n        return { success: true, comment: data };\n    }\n    catch (error) {\n        console.info(TAG + \"/Could not decrypt: \" + error.message);\n        return { success: false, comment: comment };\n    }\n}\nexports.decryptComment = decryptComment;\nexports.CommentEncryptionUtils = {\n    encryptComment: encryptComment,\n    decryptComment: decryptComment,\n};\n//# sourceMappingURL=commentEncryption.js.map"]},"metadata":{},"sourceType":"script"}