"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calcExpiry = exports.fromMiliseconds = exports.toMiliseconds = exports.capitalize = exports.capitalizeWord = exports.enumify = exports.mapEntries = exports.objToMap = exports.mapToObj = exports.mergeArrays = exports.getLastItems = exports.hasOverlap = exports.formatStorageKeyName = exports.formatMessageContext = exports.parseContextNames = exports.assertType = exports.formatRelayRpcUrl = exports.getRelayClientMetadata = exports.getAppMetadata = exports.appendToQueryString = exports.getEnvironment = exports.isBrowser = exports.isReactNative = exports.isNode = exports.ONE_THOUSAND = exports.DEFAULT_DEPTH = exports.SLASH = exports.COLON = exports.EMPTY_SPACE = exports.ENV_MAP = exports.REACT_NATIVE_PRODUCT = void 0;
const tslib_1 = require("tslib");
const lodash_union_1 = tslib_1.__importDefault(require("lodash.union"));
const qs = tslib_1.__importStar(require("query-string"));
const window_metadata_1 = require("@walletconnect/window-metadata");
const window_getters_1 = require("@walletconnect/window-getters");
exports.REACT_NATIVE_PRODUCT = "ReactNative";
exports.ENV_MAP = {
    reactNative: "react-native",
    node: "node",
    browser: "browser",
    unknown: "unknown",
};
exports.EMPTY_SPACE = " ";
exports.COLON = ":";
exports.SLASH = "/";
exports.DEFAULT_DEPTH = 2;
exports.ONE_THOUSAND = 1000;
function isNode() {
    return (typeof process !== "undefined" &&
        typeof process.versions !== "undefined" &&
        typeof process.versions.node !== "undefined");
}
exports.isNode = isNode;
function isReactNative() {
    return !window_getters_1.getDocument() && !!window_getters_1.getNavigator() && navigator.product === exports.REACT_NATIVE_PRODUCT;
}
exports.isReactNative = isReactNative;
function isBrowser() {
    return !isNode() && !!window_getters_1.getNavigator();
}
exports.isBrowser = isBrowser;
function getEnvironment() {
    if (isReactNative())
        return exports.ENV_MAP.reactNative;
    if (isNode())
        return exports.ENV_MAP.node;
    if (isBrowser())
        return exports.ENV_MAP.browser;
    return exports.ENV_MAP.unknown;
}
exports.getEnvironment = getEnvironment;
function appendToQueryString(queryString, newQueryParams) {
    let queryParams = qs.parse(queryString);
    queryParams = Object.assign(Object.assign({}, queryParams), newQueryParams);
    queryString = qs.stringify(queryParams);
    return queryString;
}
exports.appendToQueryString = appendToQueryString;
function getAppMetadata() {
    return window_metadata_1.getWindowMetadata() || undefined;
}
exports.getAppMetadata = getAppMetadata;
function getRelayClientMetadata(protocol, version) {
    var _a;
    const env = getEnvironment();
    const metadata = { protocol, version, env };
    if (env === "browser") {
        metadata.host = ((_a = window_getters_1.getLocation()) === null || _a === void 0 ? void 0 : _a.host) || "";
    }
    return metadata;
}
exports.getRelayClientMetadata = getRelayClientMetadata;
function formatRelayRpcUrl(protocol, version, url, apiKey) {
    const splitUrl = url.split("?");
    const metadata = getRelayClientMetadata(protocol, version);
    const params = apiKey ? Object.assign(Object.assign({}, metadata), { apiKey }) : metadata;
    const queryString = appendToQueryString(splitUrl[1] || "", params);
    return splitUrl[0] + "?" + queryString;
}
exports.formatRelayRpcUrl = formatRelayRpcUrl;
function assertType(obj, key, type) {
    if (!obj[key] || typeof obj[key] !== type) {
        throw new Error(`Missing or invalid "${key}" param`);
    }
}
exports.assertType = assertType;
function parseContextNames(context, depth = exports.DEFAULT_DEPTH) {
    return getLastItems(context.split(exports.SLASH), depth);
}
exports.parseContextNames = parseContextNames;
function formatMessageContext(context) {
    return parseContextNames(context).join(exports.EMPTY_SPACE);
}
exports.formatMessageContext = formatMessageContext;
function formatStorageKeyName(context) {
    return parseContextNames(context).join(exports.COLON);
}
exports.formatStorageKeyName = formatStorageKeyName;
function hasOverlap(a, b) {
    const matches = a.filter(x => b.includes(x));
    return matches.length === a.length;
}
exports.hasOverlap = hasOverlap;
function getLastItems(arr, depth = exports.DEFAULT_DEPTH) {
    return arr.slice(Math.max(arr.length - depth, 0));
}
exports.getLastItems = getLastItems;
function mergeArrays(a, b) {
    return lodash_union_1.default(a, b);
}
exports.mergeArrays = mergeArrays;
function mapToObj(map) {
    return Object.fromEntries(map.entries());
}
exports.mapToObj = mapToObj;
function objToMap(obj) {
    return new Map(Object.entries(obj));
}
exports.objToMap = objToMap;
function mapEntries(obj, cb) {
    const res = {};
    Object.keys(obj).forEach(key => {
        res[key] = cb(obj[key]);
    });
    return res;
}
exports.mapEntries = mapEntries;
exports.enumify = (x) => x;
function capitalizeWord(word) {
    return word.trim().replace(/^\w/, c => c.toUpperCase());
}
exports.capitalizeWord = capitalizeWord;
function capitalize(str) {
    return str
        .split(exports.EMPTY_SPACE)
        .map(w => capitalizeWord(w))
        .join(exports.EMPTY_SPACE);
}
exports.capitalize = capitalize;
function toMiliseconds(seconds) {
    return seconds * exports.ONE_THOUSAND;
}
exports.toMiliseconds = toMiliseconds;
function fromMiliseconds(miliseconds) {
    return Math.floor(miliseconds / exports.ONE_THOUSAND);
}
exports.fromMiliseconds = fromMiliseconds;
function calcExpiry(ttl, now) {
    return fromMiliseconds((now || Date.now()) + toMiliseconds(ttl));
}
exports.calcExpiry = calcExpiry;
//# sourceMappingURL=misc.js.map