{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { IRelayer } from \"@walletconnect/types\";\nimport { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { ERROR, formatRelayRpcUrl, formatMessageContext } from \"@walletconnect/utils\";\nimport { isJsonRpcRequest, formatJsonRpcResult } from \"@walletconnect/jsonrpc-utils\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport { WsConnection } from \"@walletconnect/jsonrpc-ws-connection\";\nimport { Subscription } from \"./subscription\";\nimport { RELAYER_CONTEXT, RELAYER_DEFAULT_PROTOCOL, RELAYER_DEFAULT_RPC_URL, RELAYER_DEFAULT_PUBLISH_TTL, RELAYER_EVENTS, RELAYER_PROVIDER_EVENTS, RELAYER_SUBSCRIPTION_SUFFIX, RELAYER_RECONNECT_TIMEOUT, SUBSCRIPTION_EVENTS } from \"../constants\";\nimport { JsonRpcHistory } from \"./history\";\nexport class Relayer extends IRelayer {\n  constructor(client, logger, provider) {\n    super(client, logger);\n    this.client = client;\n    this.logger = logger;\n    this.events = new EventEmitter();\n    this.name = RELAYER_CONTEXT;\n    this.logger = generateChildLogger(logger, this.name);\n    this.subscriptions = new Subscription(client, this.logger);\n    this.history = new JsonRpcHistory(client, this.logger);\n    this.provider = this.setProvider(provider);\n    this.registerEventListeners();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get connected() {\n    return this.provider.connection.connected;\n  }\n\n  get connecting() {\n    return this.provider.connection.connecting;\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.history.init();\n    await this.provider.connect();\n    await this.subscriptions.init();\n    await this.resubscribe();\n  }\n\n  async publish(topic, payload, opts) {\n    this.logger.debug(`Publishing Payload`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"publish\",\n      params: {\n        topic,\n        payload,\n        opts\n      }\n    });\n\n    try {\n      const message = await this.client.crypto.encodeJsonRpc(topic, payload);\n      const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || RELAYER_DEFAULT_PUBLISH_TTL;\n      const relay = this.getRelayProtocol(opts);\n      await this.rpcPublish(topic, message, ttl, relay);\n      this.logger.debug(`Successfully Published Payload`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        params: {\n          topic,\n          payload,\n          opts\n        }\n      });\n      await this.recordPayloadEvent({\n        topic,\n        payload\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  async subscribe(topic, expiry, opts) {\n    this.logger.debug(`Subscribing Topic`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"subscribe\",\n      params: {\n        topic,\n        expiry,\n        opts\n      }\n    });\n\n    try {\n      const relay = this.getRelayProtocol(opts);\n      const id = await this.rpcSubscribe(topic, relay);\n      const subscription = {\n        id,\n        topic,\n        expiry,\n        relay\n      };\n      await this.subscriptions.set(id, subscription);\n      this.logger.debug(`Successfully Subscribed Topic`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        params: {\n          topic,\n          expiry,\n          opts\n        }\n      });\n      return id;\n    } catch (e) {\n      this.logger.debug(`Failed to Subscribe Topic`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  async unsubscribe(topic, id, opts) {\n    this.logger.debug(`Unsubscribing Topic`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        topic,\n        id,\n        opts\n      }\n    });\n\n    try {\n      const relay = this.getRelayProtocol(opts);\n      await this.rpcUnsubscribe(topic, id, relay);\n      const reason = ERROR.DELETED.format({\n        context: formatMessageContext(this.context)\n      });\n      await this.onUnsubscribe(topic, id, reason);\n      this.logger.debug(`Successfully Unsubscribed Topic`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        params: {\n          topic,\n          id,\n          opts\n        }\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Unsubscribe Topic`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  async unsubscribeByTopic(topic, opts) {\n    const ids = this.subscriptions.topicMap.get(topic);\n    await Promise.all(ids.map(async id => await this.unsubscribe(topic, id, opts)));\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  getRelayProtocol(opts) {\n    return (opts === null || opts === void 0 ? void 0 : opts.relay) || {\n      protocol: RELAYER_DEFAULT_PROTOCOL\n    };\n  }\n\n  async rpcPublish(topic, message, ttl, relay) {\n    const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);\n    const request = {\n      method: jsonRpc.publish,\n      params: {\n        topic,\n        message,\n        ttl\n      }\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request\n    });\n    return this.provider.request(request);\n  }\n\n  async rpcSubscribe(topic, relay) {\n    const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);\n    const request = {\n      method: jsonRpc.subscribe,\n      params: {\n        topic\n      }\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request\n    });\n    return this.provider.request(request);\n  }\n\n  async rpcUnsubscribe(topic, id, relay) {\n    const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);\n    const request = {\n      method: jsonRpc.unsubscribe,\n      params: {\n        topic,\n        id\n      }\n    };\n    this.logger.debug(`Outgoing Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"outgoing\",\n      request\n    });\n    return this.provider.request(request);\n  }\n\n  async onUnsubscribe(topic, id, reason) {\n    this.events.removeAllListeners(id);\n\n    if (await this.subscriptions.exists(id, topic)) {\n      await this.subscriptions.delete(id, reason);\n    }\n\n    await this.history.delete(topic);\n  }\n\n  async recordPayloadEvent(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n\n    if (isJsonRpcRequest(payload)) {\n      await this.history.set(topic, payload);\n    } else {\n      await this.history.resolve(payload);\n    }\n  }\n\n  async shouldIgnorePayloadEvent(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n    if (!this.subscriptions.topics.includes(topic)) return true;\n    let exists = false;\n\n    try {\n      if (isJsonRpcRequest(payload)) {\n        exists = await this.history.exists(topic, payload.id);\n      } else {\n        let record;\n\n        try {\n          record = await this.history.get(topic, payload.id);\n        } catch (e) {}\n\n        exists = typeof record !== \"undefined\" && typeof record.response !== \"undefined\";\n      }\n    } catch (e) {}\n\n    return exists;\n  }\n\n  async onPayload(payload) {\n    this.logger.debug(`Incoming Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload\n    });\n\n    if (isJsonRpcRequest(payload)) {\n      if (!payload.method.endsWith(RELAYER_SUBSCRIPTION_SUFFIX)) return;\n      const event = payload.params;\n      const {\n        topic,\n        message\n      } = event.data;\n      const payloadEvent = {\n        topic,\n        payload: await this.client.crypto.decodeJsonRpc(topic, message)\n      };\n      if (await this.shouldIgnorePayloadEvent(payloadEvent)) return;\n      this.logger.debug(`Emitting Relayer Payload`);\n      this.logger.trace(Object.assign({\n        type: \"event\",\n        event: event.id\n      }, payloadEvent));\n      this.events.emit(event.id, payloadEvent);\n      this.events.emit(RELAYER_EVENTS.payload, payloadEvent);\n      await this.acknowledgePayload(payload);\n      await this.recordPayloadEvent(payloadEvent);\n    }\n  }\n\n  async acknowledgePayload(payload) {\n    const response = formatJsonRpcResult(payload.id, true);\n    await this.provider.connection.send(response);\n  }\n\n  async resubscribe() {\n    await Promise.all(this.subscriptions.values.map(async subscription => {\n      const id = await this.rpcSubscribe(subscription.topic, subscription.relay);\n      await this.subscriptions.set(id, Object.assign(Object.assign({}, subscription), {\n        id\n      }));\n      const reason = ERROR.RESUBSCRIBED.format({\n        topic: subscription.topic\n      });\n      await this.subscriptions.delete(subscription.id, reason);\n    }));\n  }\n\n  async onConnect() {\n    await this.subscriptions.enable();\n    await this.resubscribe();\n  }\n\n  async onDisconnect() {\n    await this.subscriptions.disable();\n    setTimeout(() => {\n      this.provider.connect();\n    }, RELAYER_RECONNECT_TIMEOUT);\n  }\n\n  setProvider(provider) {\n    this.logger.debug(`Setting Relay Provider`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"setProvider\",\n      provider: provider === null || provider === void 0 ? void 0 : provider.toString()\n    });\n    const rpcUrl = formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === \"string\" ? provider : RELAYER_DEFAULT_RPC_URL, this.client.apiKey);\n    return typeof provider !== \"string\" && typeof provider !== \"undefined\" ? provider : new JsonRpcProvider(new WsConnection(rpcUrl));\n  }\n\n  registerEventListeners() {\n    this.provider.on(RELAYER_PROVIDER_EVENTS.payload, payload => this.onPayload(payload));\n    this.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {\n      await this.onConnect();\n      this.events.emit(RELAYER_EVENTS.connect);\n    });\n    this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, async () => {\n      await this.onDisconnect();\n      this.events.emit(RELAYER_EVENTS.disconnect);\n    });\n    this.provider.on(RELAYER_PROVIDER_EVENTS.error, e => this.events.emit(RELAYER_EVENTS.error, e));\n    this.subscriptions.on(SUBSCRIPTION_EVENTS.expired, async expiredEvent => {\n      const {\n        topic,\n        id,\n        relay\n      } = expiredEvent;\n      await this.rpcUnsubscribe(topic, id, relay);\n      await this.onUnsubscribe(topic, id, expiredEvent.reason);\n    });\n  }\n\n}\n\nfunction getRelayProtocolJsonRpc(protocol) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n\n  return jsonrpc;\n}","map":{"version":3,"sources":["../../../src/controllers/relayer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { IRelayer, } from \"@walletconnect/types\";\nimport { RELAY_JSONRPC } from \"@walletconnect/relay-api\";\nimport { ERROR, formatRelayRpcUrl, formatMessageContext } from \"@walletconnect/utils\";\nimport { isJsonRpcRequest, formatJsonRpcResult, } from \"@walletconnect/jsonrpc-utils\";\nimport { JsonRpcProvider } from \"@walletconnect/jsonrpc-provider\";\nimport { WsConnection } from \"@walletconnect/jsonrpc-ws-connection\";\nimport { Subscription } from \"./subscription\";\nimport { RELAYER_CONTEXT, RELAYER_DEFAULT_PROTOCOL, RELAYER_DEFAULT_RPC_URL, RELAYER_DEFAULT_PUBLISH_TTL, RELAYER_EVENTS, RELAYER_PROVIDER_EVENTS, RELAYER_SUBSCRIPTION_SUFFIX, RELAYER_RECONNECT_TIMEOUT, SUBSCRIPTION_EVENTS, } from \"../constants\";\nimport { JsonRpcHistory } from \"./history\";\nexport class Relayer extends IRelayer {\n    constructor(client, logger, provider) {\n        super(client, logger);\n        this.client = client;\n        this.logger = logger;\n        this.events = new EventEmitter();\n        this.name = RELAYER_CONTEXT;\n        this.logger = generateChildLogger(logger, this.name);\n        this.subscriptions = new Subscription(client, this.logger);\n        this.history = new JsonRpcHistory(client, this.logger);\n        this.provider = this.setProvider(provider);\n        this.registerEventListeners();\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    get connected() {\n        return this.provider.connection.connected;\n    }\n    get connecting() {\n        return this.provider.connection.connecting;\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.history.init();\n        await this.provider.connect();\n        await this.subscriptions.init();\n        await this.resubscribe();\n    }\n    async publish(topic, payload, opts) {\n        this.logger.debug(`Publishing Payload`);\n        this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, payload, opts } });\n        try {\n            const message = await this.client.crypto.encodeJsonRpc(topic, payload);\n            const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || RELAYER_DEFAULT_PUBLISH_TTL;\n            const relay = this.getRelayProtocol(opts);\n            await this.rpcPublish(topic, message, ttl, relay);\n            this.logger.debug(`Successfully Published Payload`);\n            this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, payload, opts } });\n            await this.recordPayloadEvent({ topic, payload });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Publish Payload`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    async subscribe(topic, expiry, opts) {\n        this.logger.debug(`Subscribing Topic`);\n        this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, expiry, opts } });\n        try {\n            const relay = this.getRelayProtocol(opts);\n            const id = await this.rpcSubscribe(topic, relay);\n            const subscription = { id, topic, expiry, relay };\n            await this.subscriptions.set(id, subscription);\n            this.logger.debug(`Successfully Subscribed Topic`);\n            this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, expiry, opts } });\n            return id;\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Subscribe Topic`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    async unsubscribe(topic, id, opts) {\n        this.logger.debug(`Unsubscribing Topic`);\n        this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n        try {\n            const relay = this.getRelayProtocol(opts);\n            await this.rpcUnsubscribe(topic, id, relay);\n            const reason = ERROR.DELETED.format({ context: formatMessageContext(this.context) });\n            await this.onUnsubscribe(topic, id, reason);\n            this.logger.debug(`Successfully Unsubscribed Topic`);\n            this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { topic, id, opts } });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Unsubscribe Topic`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    async unsubscribeByTopic(topic, opts) {\n        const ids = this.subscriptions.topicMap.get(topic);\n        await Promise.all(ids.map(async (id) => await this.unsubscribe(topic, id, opts)));\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    getRelayProtocol(opts) {\n        return (opts === null || opts === void 0 ? void 0 : opts.relay) || { protocol: RELAYER_DEFAULT_PROTOCOL };\n    }\n    async rpcPublish(topic, message, ttl, relay) {\n        const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);\n        const request = {\n            method: jsonRpc.publish,\n            params: {\n                topic,\n                message,\n                ttl,\n            },\n        };\n        this.logger.debug(`Outgoing Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n        return this.provider.request(request);\n    }\n    async rpcSubscribe(topic, relay) {\n        const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);\n        const request = {\n            method: jsonRpc.subscribe,\n            params: {\n                topic,\n            },\n        };\n        this.logger.debug(`Outgoing Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n        return this.provider.request(request);\n    }\n    async rpcUnsubscribe(topic, id, relay) {\n        const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);\n        const request = {\n            method: jsonRpc.unsubscribe,\n            params: {\n                topic,\n                id,\n            },\n        };\n        this.logger.debug(`Outgoing Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n        return this.provider.request(request);\n    }\n    async onUnsubscribe(topic, id, reason) {\n        this.events.removeAllListeners(id);\n        if (await this.subscriptions.exists(id, topic)) {\n            await this.subscriptions.delete(id, reason);\n        }\n        await this.history.delete(topic);\n    }\n    async recordPayloadEvent(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        if (isJsonRpcRequest(payload)) {\n            await this.history.set(topic, payload);\n        }\n        else {\n            await this.history.resolve(payload);\n        }\n    }\n    async shouldIgnorePayloadEvent(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        if (!this.subscriptions.topics.includes(topic))\n            return true;\n        let exists = false;\n        try {\n            if (isJsonRpcRequest(payload)) {\n                exists = await this.history.exists(topic, payload.id);\n            }\n            else {\n                let record;\n                try {\n                    record = await this.history.get(topic, payload.id);\n                }\n                catch (e) {\n                }\n                exists = typeof record !== \"undefined\" && typeof record.response !== \"undefined\";\n            }\n        }\n        catch (e) {\n        }\n        return exists;\n    }\n    async onPayload(payload) {\n        this.logger.debug(`Incoming Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"incoming\", payload });\n        if (isJsonRpcRequest(payload)) {\n            if (!payload.method.endsWith(RELAYER_SUBSCRIPTION_SUFFIX))\n                return;\n            const event = payload.params;\n            const { topic, message } = event.data;\n            const payloadEvent = {\n                topic,\n                payload: await this.client.crypto.decodeJsonRpc(topic, message),\n            };\n            if (await this.shouldIgnorePayloadEvent(payloadEvent))\n                return;\n            this.logger.debug(`Emitting Relayer Payload`);\n            this.logger.trace(Object.assign({ type: \"event\", event: event.id }, payloadEvent));\n            this.events.emit(event.id, payloadEvent);\n            this.events.emit(RELAYER_EVENTS.payload, payloadEvent);\n            await this.acknowledgePayload(payload);\n            await this.recordPayloadEvent(payloadEvent);\n        }\n    }\n    async acknowledgePayload(payload) {\n        const response = formatJsonRpcResult(payload.id, true);\n        await this.provider.connection.send(response);\n    }\n    async resubscribe() {\n        await Promise.all(this.subscriptions.values.map(async (subscription) => {\n            const id = await this.rpcSubscribe(subscription.topic, subscription.relay);\n            await this.subscriptions.set(id, Object.assign(Object.assign({}, subscription), { id }));\n            const reason = ERROR.RESUBSCRIBED.format({ topic: subscription.topic });\n            await this.subscriptions.delete(subscription.id, reason);\n        }));\n    }\n    async onConnect() {\n        await this.subscriptions.enable();\n        await this.resubscribe();\n    }\n    async onDisconnect() {\n        await this.subscriptions.disable();\n        setTimeout(() => {\n            this.provider.connect();\n        }, RELAYER_RECONNECT_TIMEOUT);\n    }\n    setProvider(provider) {\n        this.logger.debug(`Setting Relay Provider`);\n        this.logger.trace({ type: \"method\", method: \"setProvider\", provider: provider === null || provider === void 0 ? void 0 : provider.toString() });\n        const rpcUrl = formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === \"string\" ? provider : RELAYER_DEFAULT_RPC_URL, this.client.apiKey);\n        return typeof provider !== \"string\" && typeof provider !== \"undefined\"\n            ? provider\n            : new JsonRpcProvider(new WsConnection(rpcUrl));\n    }\n    registerEventListeners() {\n        this.provider.on(RELAYER_PROVIDER_EVENTS.payload, (payload) => this.onPayload(payload));\n        this.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {\n            await this.onConnect();\n            this.events.emit(RELAYER_EVENTS.connect);\n        });\n        this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, async () => {\n            await this.onDisconnect();\n            this.events.emit(RELAYER_EVENTS.disconnect);\n        });\n        this.provider.on(RELAYER_PROVIDER_EVENTS.error, e => this.events.emit(RELAYER_EVENTS.error, e));\n        this.subscriptions.on(SUBSCRIPTION_EVENTS.expired, async (expiredEvent) => {\n            const { topic, id, relay } = expiredEvent;\n            await this.rpcUnsubscribe(topic, id, relay);\n            await this.onUnsubscribe(topic, id, expiredEvent.reason);\n        });\n    }\n}\nfunction getRelayProtocolJsonRpc(protocol) {\n    const jsonrpc = RELAY_JSONRPC[protocol];\n    if (typeof jsonrpc === \"undefined\") {\n        throw new Error(`Relay Protocol not supported: ${protocol}`);\n    }\n    return jsonrpc;\n}\n//# sourceMappingURL=relayer.js.map"]},"metadata":{},"sourceType":"module"}