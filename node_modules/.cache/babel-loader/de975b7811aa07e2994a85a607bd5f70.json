{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst keccak_1 = require(\"./keccak\");\n/**\n * derive Address from public key\n * @param pubKey the public key\n */\n\n\nfunction publicKeyToAddress(pubKey) {\n  return keccak_1.keccak256(pubKey.slice(1)).slice(12);\n}\n\nexports.publicKeyToAddress = publicKeyToAddress;\n/**\n * to check if a value presents an address\n * @param v the value to be checked\n */\n\nfunction isAddress(v) {\n  return typeof v === 'string' && /^0x[0-9a-f]{40}$/i.test(v);\n}\n\nexports.isAddress = isAddress;\n/**\n * encode the address to checksum address that is compatible with eip-55\n * @param address input address\n */\n\nfunction toChecksumAddress(address) {\n  if (!isAddress(address)) {\n    throw new Error('invalid address');\n  }\n\n  address = address.slice(2).toLowerCase();\n  const hash = keccak_1.keccak256(address);\n  let checksumAddress = '0x';\n\n  for (let i = 0; i < address.length; i++) {\n    let byte = hash[i >> 1];\n\n    if (i % 2 === 0) {\n      byte >>= 4;\n    }\n\n    if (byte % 16 >= 8) {\n      checksumAddress += address[i].toUpperCase();\n    } else {\n      checksumAddress += address[i];\n    }\n  }\n\n  return checksumAddress;\n}\n\nexports.toChecksumAddress = toChecksumAddress;","map":{"version":3,"sources":["../../src/cry/address.ts"],"names":[],"mappings":";;;;;;AAAA,MAAA,QAAA,GAAA,OAAA,CAAA,UAAA,CAAA;AACA;;;AAGG;;;AACH,SAAgB,kBAAhB,CAAmC,MAAnC,EAAiD;AAC/C,SAAO,QAAA,CAAA,SAAA,CAAU,MAAM,CAAC,KAAP,CAAa,CAAb,CAAV,EAA2B,KAA3B,CAAiC,EAAjC,CAAP;AACD;;AAFD,OAAA,CAAA,kBAAA,GAAA,kBAAA;AAIA;;;AAGG;;AACH,SAAgB,SAAhB,CAA0B,CAA1B,EAAgC;AAC9B,SAAO,OAAO,CAAP,KAAa,QAAb,IAAyB,oBAAoB,IAApB,CAAyB,CAAzB,CAAhC;AACD;;AAFD,OAAA,CAAA,SAAA,GAAA,SAAA;AAIA;;;AAGG;;AACH,SAAgB,iBAAhB,CAAkC,OAAlC,EAAiD;AAC/C,MAAI,CAAC,SAAS,CAAC,OAAD,CAAd,EAAyB;AACvB,UAAM,IAAI,KAAJ,CAAU,iBAAV,CAAN;AACD;;AACD,EAAA,OAAO,GAAG,OAAO,CAAC,KAAR,CAAc,CAAd,EAAiB,WAAjB,EAAV;AACA,QAAM,IAAI,GAAG,QAAA,CAAA,SAAA,CAAU,OAAV,CAAb;AAEA,MAAI,eAAe,GAAG,IAAtB;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,EAArC,EAAyC;AACvC,QAAI,IAAI,GAAG,IAAI,CAAC,CAAC,IAAI,CAAN,CAAf;;AACA,QAAI,CAAC,GAAG,CAAJ,KAAU,CAAd,EAAiB;AACf,MAAA,IAAI,KAAK,CAAT;AACD;;AAED,QAAI,IAAI,GAAG,EAAP,IAAa,CAAjB,EAAoB;AAClB,MAAA,eAAe,IAAI,OAAO,CAAC,CAAD,CAAP,CAAW,WAAX,EAAnB;AACD,KAFD,MAEO;AACL,MAAA,eAAe,IAAI,OAAO,CAAC,CAAD,CAA1B;AACD;AACF;;AACD,SAAO,eAAP;AACD;;AArBD,OAAA,CAAA,iBAAA,GAAA,iBAAA","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst keccak_1 = require(\"./keccak\");\n/**\n * derive Address from public key\n * @param pubKey the public key\n */\nfunction publicKeyToAddress(pubKey) {\n    return keccak_1.keccak256(pubKey.slice(1)).slice(12);\n}\nexports.publicKeyToAddress = publicKeyToAddress;\n/**\n * to check if a value presents an address\n * @param v the value to be checked\n */\nfunction isAddress(v) {\n    return typeof v === 'string' && /^0x[0-9a-f]{40}$/i.test(v);\n}\nexports.isAddress = isAddress;\n/**\n * encode the address to checksum address that is compatible with eip-55\n * @param address input address\n */\nfunction toChecksumAddress(address) {\n    if (!isAddress(address)) {\n        throw new Error('invalid address');\n    }\n    address = address.slice(2).toLowerCase();\n    const hash = keccak_1.keccak256(address);\n    let checksumAddress = '0x';\n    for (let i = 0; i < address.length; i++) {\n        let byte = hash[i >> 1];\n        if (i % 2 === 0) {\n            byte >>= 4;\n        }\n        if (byte % 16 >= 8) {\n            checksumAddress += address[i].toUpperCase();\n        }\n        else {\n            checksumAddress += address[i];\n        }\n    }\n    return checksumAddress;\n}\nexports.toChecksumAddress = toChecksumAddress;\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWRkcmVzcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jcnkvYWRkcmVzcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHFDQUFxQztBQUNyQzs7O0dBR0c7QUFDSCxTQUFnQixrQkFBa0IsQ0FBQyxNQUFjO0lBQy9DLE9BQU8sa0JBQVMsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQzlDLENBQUM7QUFGRCxnREFFQztBQUVEOzs7R0FHRztBQUNILFNBQWdCLFNBQVMsQ0FBQyxDQUFNO0lBQzlCLE9BQU8sT0FBTyxDQUFDLEtBQUssUUFBUSxJQUFJLG1CQUFtQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUM5RCxDQUFDO0FBRkQsOEJBRUM7QUFFRDs7O0dBR0c7QUFDSCxTQUFnQixpQkFBaUIsQ0FBQyxPQUFlO0lBQy9DLElBQUksQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDdkIsTUFBTSxJQUFJLEtBQUssQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDO0tBQ3BDO0lBQ0QsT0FBTyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLENBQUM7SUFDekMsTUFBTSxJQUFJLEdBQUcsa0JBQVMsQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUVoQyxJQUFJLGVBQWUsR0FBRyxJQUFJLENBQUM7SUFDM0IsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7UUFDdkMsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUN4QixJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ2YsSUFBSSxLQUFLLENBQUMsQ0FBQztTQUNaO1FBRUQsSUFBSSxJQUFJLEdBQUcsRUFBRSxJQUFJLENBQUMsRUFBRTtZQUNsQixlQUFlLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxDQUFDO1NBQzdDO2FBQU07WUFDTCxlQUFlLElBQUksT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQy9CO0tBQ0Y7SUFDRCxPQUFPLGVBQWUsQ0FBQztBQUN6QixDQUFDO0FBckJELDhDQXFCQyJ9"]},"metadata":{},"sourceType":"script"}