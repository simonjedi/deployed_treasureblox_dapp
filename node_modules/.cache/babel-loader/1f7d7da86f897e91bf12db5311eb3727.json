{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst bignumber_js_1 = require(\"bignumber.js\");\n\nconst rlp = require(\"rlp\");\n\nclass RLP {\n  constructor(profile) {\n    this.profile = profile;\n  }\n  /**\n   * encode data according to profile\n   * @param data the structured data to be encoded\n   */\n\n\n  encode(data) {\n    const packed = pack(data, this.profile, '');\n    return rlp.encode(packed);\n  }\n  /**\n   * decode buffer according to profile\n   * @param buf rlp encoded data\n   */\n\n\n  decode(buf) {\n    const packed = rlp.decode(buf);\n    return unpack(packed, this.profile, '');\n  }\n\n}\n\nexports.RLP = RLP;\n\n(function (RLP) {\n  /** base class of scalar kind */\n  class ScalarKind {}\n\n  RLP.ScalarKind = ScalarKind;\n  /** a buffer kind to keep buffer type */\n\n  class BufferKind extends ScalarKind {\n    data(data, ctx) {\n      assert(Buffer.isBuffer(data), ctx, 'expected buffer');\n      return {\n        encode() {\n          return data;\n        }\n\n      };\n    }\n\n    buffer(buf, ctx) {\n      return {\n        decode() {\n          return buf;\n        }\n\n      };\n    }\n\n  }\n\n  RLP.BufferKind = BufferKind;\n  /** a scalar kind to presents number */\n\n  class NumericKind extends ScalarKind {\n    /**\n     * create a numeric kind\n     * @param maxBytes up limit of data in bytes\n     */\n    constructor(maxBytes) {\n      super();\n      this.maxBytes = maxBytes;\n    }\n\n    data(data, ctx) {\n      assert(typeof data === 'string' || typeof data === 'number', ctx, 'expected string or number');\n\n      if (typeof data === 'string') {\n        const isHex = isHexString(data);\n        const isDec = isDecString(data);\n        assert(isHex || isDec, ctx, 'expected non-negative integer in hex or dec string');\n\n        if (isHex) {\n          assert(data.length > 2, ctx, 'expected valid hex string');\n        }\n      } else {\n        assert(Number.isSafeInteger(data) && data >= 0, ctx, 'expected non-negative safe integer');\n      }\n\n      const bn = new bignumber_js_1.default(data);\n\n      if (bn.isZero()) {\n        return {\n          encode() {\n            return Buffer.alloc(0);\n          }\n\n        };\n      }\n\n      let hex = bn.toString(16);\n\n      if (hex.length % 2 !== 0) {\n        hex = `0${hex}`;\n      }\n\n      assert(this.maxBytes ? hex.length <= this.maxBytes * 2 : true, ctx, `expected number in ${this.maxBytes} bytes`);\n      return {\n        encode() {\n          return Buffer.from(hex, 'hex');\n        }\n\n      };\n    }\n\n    buffer(buf, ctx) {\n      assert(this.maxBytes ? buf.length <= this.maxBytes : true, ctx, `expected less than ${this.maxBytes} bytes`);\n      assert(buf.length === 0 || buf[0] !== 0, ctx, `expected canonical integer (no leading zero bytes)`);\n      return {\n        decode() {\n          if (buf.length === 0) {\n            return 0;\n          }\n\n          const bn = new bignumber_js_1.default(buf.toString('hex'), 16);\n          const num = bn.toNumber();\n          return Number.isSafeInteger(num) ? num : `0x${bn.toString(16)}`;\n        }\n\n      };\n    }\n\n  }\n\n  RLP.NumericKind = NumericKind;\n  /** a scalar kind to present blob */\n\n  class BlobKind extends ScalarKind {\n    data(data, ctx) {\n      assert(isHexString(data), ctx, 'expected hex string');\n      assert(data.length % 2 === 0, ctx, 'expected even length hex');\n      return {\n        encode() {\n          return Buffer.from(data.slice(2), 'hex');\n        }\n\n      };\n    }\n\n    buffer(buf, ctx) {\n      return {\n        decode() {\n          return `0x${buf.toString('hex')}`;\n        }\n\n      };\n    }\n\n  }\n\n  RLP.BlobKind = BlobKind;\n  /** fixed length blob */\n\n  class FixedBlobKind extends BlobKind {\n    constructor(bytes) {\n      super();\n      this.bytes = bytes;\n    }\n\n    data(data, ctx) {\n      const encoder = super.data(data, ctx);\n      assert(data.length === this.bytes * 2 + 2, ctx, `expected hex string presents ${this.bytes} bytes`);\n      return encoder;\n    }\n\n    buffer(buf, ctx) {\n      const decoder = super.buffer(buf, ctx);\n      assert(buf.length === this.bytes, ctx, `expected ${this.bytes} bytes`);\n      return decoder;\n    }\n\n  }\n\n  RLP.FixedBlobKind = FixedBlobKind;\n  /** fixed length blob allowing null */\n\n  class NullableFixedBlobKind extends FixedBlobKind {\n    data(data, ctx) {\n      if (!data) {\n        return {\n          encode() {\n            return Buffer.alloc(0);\n          }\n\n        };\n      }\n\n      return super.data(data, ctx);\n    }\n\n    buffer(buf, ctx) {\n      if (buf.length === 0) {\n        return {\n          decode() {\n            return null;\n          }\n\n        };\n      }\n\n      return super.buffer(buf, ctx);\n    }\n\n  }\n\n  RLP.NullableFixedBlobKind = NullableFixedBlobKind;\n  /** fixed length blob kind that will remove leading zero on encoding and pad zero on decoding */\n\n  class CompactFixedBlobKind extends FixedBlobKind {\n    data(data, ctx) {\n      const buf = super.data(data, ctx).encode();\n      return {\n        encode() {\n          const nzIndex = buf.findIndex(v => v !== 0);\n\n          if (nzIndex >= 0) {\n            return buf.slice(nzIndex);\n          }\n\n          return Buffer.alloc(0);\n        }\n\n      };\n    }\n\n    buffer(buf, ctx) {\n      assert(buf.length <= this.bytes, ctx, `expected less than ${this.bytes} bytes`);\n      assert(buf.length === 0 || buf[0] !== 0, ctx, `expected no leading zero bytes`);\n      const {\n        bytes\n      } = this;\n      return {\n        decode() {\n          const zeros = '0'.repeat((bytes - buf.length) * 2);\n          return `0x${zeros}${buf.toString('hex')}`;\n        }\n\n      };\n    }\n\n  }\n\n  RLP.CompactFixedBlobKind = CompactFixedBlobKind;\n})(RLP = exports.RLP || (exports.RLP = {}));\n\nfunction pack(obj, profile, ctx) {\n  ctx = ctx ? `${ctx}.${profile.name}` : profile.name;\n  const {\n    kind\n  } = profile;\n\n  if (kind instanceof RLP.ScalarKind) {\n    return kind.data(obj, ctx).encode();\n  }\n\n  if (Array.isArray(kind)) {\n    return kind.map(k => pack(obj[k.name], k, ctx));\n  }\n\n  assert(Array.isArray(obj), ctx, 'expected array');\n  const {\n    item\n  } = kind;\n  return obj.map((part, i) => pack(part, {\n    name: `#${i}`,\n    kind: item\n  }, ctx));\n}\n\nfunction unpack(packed, profile, ctx) {\n  ctx = ctx ? `${ctx}.${profile.name}` : profile.name;\n  const {\n    kind\n  } = profile;\n\n  if (kind instanceof RLP.ScalarKind) {\n    assert(Buffer.isBuffer(packed), ctx, 'expected Buffer');\n    return kind.buffer(packed, ctx).decode();\n  }\n\n  if (Array.isArray(kind)) {\n    assert(Array.isArray(packed), ctx, 'expected array');\n    const parts = packed;\n    assert(parts.length === kind.length, ctx, `expected ${kind.length} items, but got ${parts.length}`);\n    return kind.reduce((o, p, i) => {\n      o[p.name] = unpack(parts[i], p, ctx);\n      return o;\n    }, {});\n  }\n\n  assert(Array.isArray(packed), ctx, 'expected array');\n  const {\n    item\n  } = kind;\n  return packed.map((part, i) => unpack(part, {\n    name: `#${i}`,\n    kind: item\n  }, ctx));\n}\n\nfunction assert(cond, ctx, msg) {\n  if (!cond) {\n    throw new RLPError(`${ctx}: ${msg}`);\n  }\n}\n\nfunction isHexString(str) {\n  return /^0x[0-9a-f]*$/i.test(str);\n}\n\nfunction isDecString(str) {\n  return /^[0-9]+$/.test(str);\n}\n\nclass RLPError extends Error {\n  constructor(msg) {\n    super(msg);\n    this.name = RLPError.name;\n  }\n\n}","map":{"version":3,"sources":["../src/rlp.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bignumber_js_1 = require(\"bignumber.js\");\nconst rlp = require(\"rlp\");\nclass RLP {\n    constructor(profile) {\n        this.profile = profile;\n    }\n    /**\n     * encode data according to profile\n     * @param data the structured data to be encoded\n     */\n    encode(data) {\n        const packed = pack(data, this.profile, '');\n        return rlp.encode(packed);\n    }\n    /**\n     * decode buffer according to profile\n     * @param buf rlp encoded data\n     */\n    decode(buf) {\n        const packed = rlp.decode(buf);\n        return unpack(packed, this.profile, '');\n    }\n}\nexports.RLP = RLP;\n(function (RLP) {\n    /** base class of scalar kind */\n    class ScalarKind {\n    }\n    RLP.ScalarKind = ScalarKind;\n    /** a buffer kind to keep buffer type */\n    class BufferKind extends ScalarKind {\n        data(data, ctx) {\n            assert(Buffer.isBuffer(data), ctx, 'expected buffer');\n            return {\n                encode() {\n                    return data;\n                },\n            };\n        }\n        buffer(buf, ctx) {\n            return {\n                decode() {\n                    return buf;\n                },\n            };\n        }\n    }\n    RLP.BufferKind = BufferKind;\n    /** a scalar kind to presents number */\n    class NumericKind extends ScalarKind {\n        /**\n         * create a numeric kind\n         * @param maxBytes up limit of data in bytes\n         */\n        constructor(maxBytes) {\n            super();\n            this.maxBytes = maxBytes;\n        }\n        data(data, ctx) {\n            assert(typeof data === 'string' || typeof data === 'number', ctx, 'expected string or number');\n            if (typeof data === 'string') {\n                const isHex = isHexString(data);\n                const isDec = isDecString(data);\n                assert(isHex || isDec, ctx, 'expected non-negative integer in hex or dec string');\n                if (isHex) {\n                    assert(data.length > 2, ctx, 'expected valid hex string');\n                }\n            }\n            else {\n                assert(Number.isSafeInteger(data) && data >= 0, ctx, 'expected non-negative safe integer');\n            }\n            const bn = new bignumber_js_1.default(data);\n            if (bn.isZero()) {\n                return {\n                    encode() {\n                        return Buffer.alloc(0);\n                    },\n                };\n            }\n            let hex = bn.toString(16);\n            if (hex.length % 2 !== 0) {\n                hex = `0${hex}`;\n            }\n            assert(this.maxBytes ? hex.length <= this.maxBytes * 2 : true, ctx, `expected number in ${this.maxBytes} bytes`);\n            return {\n                encode() {\n                    return Buffer.from(hex, 'hex');\n                },\n            };\n        }\n        buffer(buf, ctx) {\n            assert(this.maxBytes ? buf.length <= this.maxBytes : true, ctx, `expected less than ${this.maxBytes} bytes`);\n            assert(buf.length === 0 || buf[0] !== 0, ctx, `expected canonical integer (no leading zero bytes)`);\n            return {\n                decode() {\n                    if (buf.length === 0) {\n                        return 0;\n                    }\n                    const bn = new bignumber_js_1.default(buf.toString('hex'), 16);\n                    const num = bn.toNumber();\n                    return Number.isSafeInteger(num) ? num : `0x${bn.toString(16)}`;\n                },\n            };\n        }\n    }\n    RLP.NumericKind = NumericKind;\n    /** a scalar kind to present blob */\n    class BlobKind extends ScalarKind {\n        data(data, ctx) {\n            assert(isHexString(data), ctx, 'expected hex string');\n            assert(data.length % 2 === 0, ctx, 'expected even length hex');\n            return {\n                encode() {\n                    return Buffer.from(data.slice(2), 'hex');\n                },\n            };\n        }\n        buffer(buf, ctx) {\n            return {\n                decode() {\n                    return `0x${buf.toString('hex')}`;\n                },\n            };\n        }\n    }\n    RLP.BlobKind = BlobKind;\n    /** fixed length blob */\n    class FixedBlobKind extends BlobKind {\n        constructor(bytes) {\n            super();\n            this.bytes = bytes;\n        }\n        data(data, ctx) {\n            const encoder = super.data(data, ctx);\n            assert(data.length === this.bytes * 2 + 2, ctx, `expected hex string presents ${this.bytes} bytes`);\n            return encoder;\n        }\n        buffer(buf, ctx) {\n            const decoder = super.buffer(buf, ctx);\n            assert(buf.length === this.bytes, ctx, `expected ${this.bytes} bytes`);\n            return decoder;\n        }\n    }\n    RLP.FixedBlobKind = FixedBlobKind;\n    /** fixed length blob allowing null */\n    class NullableFixedBlobKind extends FixedBlobKind {\n        data(data, ctx) {\n            if (!data) {\n                return {\n                    encode() {\n                        return Buffer.alloc(0);\n                    },\n                };\n            }\n            return super.data(data, ctx);\n        }\n        buffer(buf, ctx) {\n            if (buf.length === 0) {\n                return {\n                    decode() {\n                        return null;\n                    },\n                };\n            }\n            return super.buffer(buf, ctx);\n        }\n    }\n    RLP.NullableFixedBlobKind = NullableFixedBlobKind;\n    /** fixed length blob kind that will remove leading zero on encoding and pad zero on decoding */\n    class CompactFixedBlobKind extends FixedBlobKind {\n        data(data, ctx) {\n            const buf = super.data(data, ctx).encode();\n            return {\n                encode() {\n                    const nzIndex = buf.findIndex((v) => v !== 0);\n                    if (nzIndex >= 0) {\n                        return buf.slice(nzIndex);\n                    }\n                    return Buffer.alloc(0);\n                },\n            };\n        }\n        buffer(buf, ctx) {\n            assert(buf.length <= this.bytes, ctx, `expected less than ${this.bytes} bytes`);\n            assert(buf.length === 0 || buf[0] !== 0, ctx, `expected no leading zero bytes`);\n            const { bytes } = this;\n            return {\n                decode() {\n                    const zeros = '0'.repeat((bytes - buf.length) * 2);\n                    return `0x${zeros}${buf.toString('hex')}`;\n                },\n            };\n        }\n    }\n    RLP.CompactFixedBlobKind = CompactFixedBlobKind;\n})(RLP = exports.RLP || (exports.RLP = {}));\nfunction pack(obj, profile, ctx) {\n    ctx = ctx ? `${ctx}.${profile.name}` : profile.name;\n    const { kind } = profile;\n    if (kind instanceof RLP.ScalarKind) {\n        return kind.data(obj, ctx).encode();\n    }\n    if (Array.isArray(kind)) {\n        return kind.map((k) => pack(obj[k.name], k, ctx));\n    }\n    assert(Array.isArray(obj), ctx, 'expected array');\n    const { item } = kind;\n    return obj.map((part, i) => pack(part, { name: `#${i}`, kind: item }, ctx));\n}\nfunction unpack(packed, profile, ctx) {\n    ctx = ctx ? `${ctx}.${profile.name}` : profile.name;\n    const { kind } = profile;\n    if (kind instanceof RLP.ScalarKind) {\n        assert(Buffer.isBuffer(packed), ctx, 'expected Buffer');\n        return kind.buffer(packed, ctx).decode();\n    }\n    if (Array.isArray(kind)) {\n        assert(Array.isArray(packed), ctx, 'expected array');\n        const parts = packed;\n        assert(parts.length === kind.length, ctx, `expected ${kind.length} items, but got ${parts.length}`);\n        return kind.reduce((o, p, i) => {\n            o[p.name] = unpack(parts[i], p, ctx);\n            return o;\n        }, {});\n    }\n    assert(Array.isArray(packed), ctx, 'expected array');\n    const { item } = kind;\n    return packed.map((part, i) => unpack(part, { name: `#${i}`, kind: item }, ctx));\n}\nfunction assert(cond, ctx, msg) {\n    if (!cond) {\n        throw new RLPError(`${ctx}: ${msg}`);\n    }\n}\nfunction isHexString(str) {\n    return /^0x[0-9a-f]*$/i.test(str);\n}\nfunction isDecString(str) {\n    return /^[0-9]+$/.test(str);\n}\nclass RLPError extends Error {\n    constructor(msg) {\n        super(msg);\n        this.name = RLPError.name;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmxwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3JscC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtDQUFxQztBQUNyQywyQkFBMkI7QUFFM0IsTUFBYSxHQUFHO0lBQ2QsWUFBcUIsT0FBb0I7UUFBcEIsWUFBTyxHQUFQLE9BQU8sQ0FBYTtJQUFHLENBQUM7SUFFN0M7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLElBQVM7UUFDckIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzVDLE9BQVEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQW1CLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxHQUFXO1FBQ3ZCLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBVSxDQUFDLENBQUM7UUFDdEMsT0FBTyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDMUMsQ0FBQztDQUNGO0FBcEJELGtCQW9CQztBQUVELFdBQWlCLEdBQUc7SUFDbEIsZ0NBQWdDO0lBQ2hDLE1BQXNCLFVBQVU7S0FJL0I7SUFKcUIsY0FBVSxhQUkvQixDQUFBO0lBRUQsd0NBQXdDO0lBQ3hDLE1BQWEsVUFBVyxTQUFRLFVBQVU7UUFDakMsSUFBSSxDQUFDLElBQVksRUFBRSxHQUFXO1lBQ25DLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3RELE9BQU87Z0JBQ0wsTUFBTTtvQkFDSixPQUFPLElBQUksQ0FBQztnQkFDZCxDQUFDO2FBQ0YsQ0FBQztRQUNKLENBQUM7UUFFTSxNQUFNLENBQUMsR0FBVyxFQUFFLEdBQVc7WUFDcEMsT0FBTztnQkFDTCxNQUFNO29CQUNKLE9BQU8s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"]},"metadata":{},"sourceType":"script"}