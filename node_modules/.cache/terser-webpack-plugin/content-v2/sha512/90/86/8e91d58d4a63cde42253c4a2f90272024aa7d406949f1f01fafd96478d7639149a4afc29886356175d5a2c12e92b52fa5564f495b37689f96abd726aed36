{"code":"(this[\"webpackJsonptreasure-blox\"]=this[\"webpackJsonptreasure-blox\"]||[]).push([[13],{1356:function(e,t,r){\"use strict\";r.r(t),r.d(t,\"NoEthereumProviderError\",(function(){return v})),r.d(t,\"ProvidedConnector\",(function(){return m})),r.d(t,\"UserRejectedRequestError\",(function(){return l}));var n=r(631);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var n in r)Object.prototype.hasOwnProperty.call(r,n)&&(e[n]=r[n])}return e}).apply(this,arguments)}function i(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}function u(e){return(u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function a(){if(\"undefined\"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function s(e,t,r){return(s=a()?Reflect.construct:function(e,t,r){var n=[null];n.push.apply(n,t);var o=new(Function.bind.apply(e,n));return r&&c(o,r.prototype),o}).apply(null,arguments)}function h(e){var t=\"function\"===typeof Map?new Map:void 0;return(h=function(e){if(null===e||(r=e,-1===Function.toString.call(r).indexOf(\"[native code]\")))return e;var r;if(\"function\"!==typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(\"undefined\"!==typeof t){if(t.has(e))return t.get(e);t.set(e,n)}function n(){return s(e,arguments,u(this).constructor)}return n.prototype=Object.create(e.prototype,{constructor:{value:n,enumerable:!1,writable:!0,configurable:!0}}),c(n,e)})(e)}function d(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}\"undefined\"!==typeof Symbol&&(Symbol.iterator||(Symbol.iterator=Symbol(\"Symbol.iterator\"))),\"undefined\"!==typeof Symbol&&(Symbol.asyncIterator||(Symbol.asyncIterator=Symbol(\"Symbol.asyncIterator\")));function f(e,t){try{var r=e()}catch(n){return t(n)}return r&&r.then?r.then(void 0,t):r}function p(e){return e.hasOwnProperty(\"result\")?e.result:e}var v=function(e){function t(){var t;return(t=e.call(this)||this).name=t.constructor.name,t.message=\"No Ethereum provider was passed to the constructor or found on window.ethereum.\",t}return i(t,e),t}(h(Error)),l=function(e){function t(){var t;return(t=e.call(this)||this).name=t.constructor.name,t.message=\"The user rejected the request.\",t}return i(t,e),t}(h(Error)),m=function(e){function t(t){var r,n=t.provider,o=void 0===n?window.ethereum:n,i=t.supportedChainIds;return(r=e.call(this,{supportedChainIds:i})||this).provider=o,r.handleNetworkChanged=r.handleNetworkChanged.bind(d(r)),r.handleChainChanged=r.handleChainChanged.bind(d(r)),r.handleAccountsChanged=r.handleAccountsChanged.bind(d(r)),r.handleClose=r.handleClose.bind(d(r)),r}i(t,e);var r=t.prototype;return r.handleChainChanged=function(e){this.emitUpdate({chainId:e,provider:this.provider})},r.handleAccountsChanged=function(e){0===e.length?this.emitDeactivate():this.emitUpdate({account:e[0]})},r.handleClose=function(e,t){this.emitDeactivate()},r.handleNetworkChanged=function(e){this.emitUpdate({chainId:e,provider:this.provider})},r.activate=function(){try{var e,t=function(t){if(r)return t;function i(){return o({provider:n.provider},e?{account:e}:{})}var u=function(){if(!e)return Promise.resolve(n.provider.enable().then((function(e){return e&&p(e)[0]}))).then((function(t){e=t}))}();return u&&u.then?u.then(i):i()},r=!1,n=this;if(!n.provider)throw new v;n.provider.on&&(n.provider.on(\"chainChanged\",n.handleChainChanged),n.provider.on(\"accountsChanged\",n.handleAccountsChanged),n.provider.on(\"close\",n.handleClose),n.provider.on(\"networkChanged\",n.handleNetworkChanged)),n.provider.isMetaMask&&(n.provider.autoRefreshOnNetworkChange=!1);var i=f((function(){return Promise.resolve(n.provider.send(\"eth_requestAccounts\").then((function(e){return p(e)[0]}))).then((function(t){e=t}))}),(function(e){if(4001===e.code)throw new l}));return Promise.resolve(i&&i.then?i.then(t):t(i))}catch(u){return Promise.reject(u)}},r.getProvider=function(){try{return Promise.resolve(this.provider)}catch(e){return Promise.reject(e)}},r.getChainId=function(){try{var e,t=function(){function t(){if(!e)try{e=p(r.provider.send({method:\"net_version\"}))}catch(t){}return e||(e=r.provider.isDapper?p(r.provider.cachedResults.net_version):r.provider.chainId||r.provider.networkVersion||r.provider._chainId),e}var n=function(){if(!e){var t=f((function(){return Promise.resolve(r.provider.send(\"net_version\").then(p)).then((function(t){e=t}))}),(function(){}));if(t&&t.then)return t.then((function(){}))}}();return n&&n.then?n.then(t):t()},r=this;if(!r.provider)throw new v;var n=f((function(){return Promise.resolve(r.provider.send(\"eth_chainId\").then(p)).then((function(t){e=t}))}),(function(){}));return Promise.resolve(n&&n.then?n.then(t):t())}catch(o){return Promise.reject(o)}},r.getAccount=function(){try{var e,t=function(){function t(){return e||(e=p(r.provider.send({method:\"eth_accounts\"}))[0]),e}var n=function(){if(!e){var t=f((function(){return Promise.resolve(r.provider.enable().then((function(e){return p(e)[0]}))).then((function(t){e=t}))}),(function(){}));if(t&&t.then)return t.then((function(){}))}}();return n&&n.then?n.then(t):t()},r=this;if(!r.provider)throw new v;var n=f((function(){return Promise.resolve(r.provider.send(\"eth_accounts\").then((function(e){return p(e)[0]}))).then((function(t){e=t}))}),(function(){}));return Promise.resolve(n&&n.then?n.then(t):t())}catch(o){return Promise.reject(o)}},r.deactivate=function(){this.provider&&this.provider.removeListener&&(this.provider.removeListener(\"chainChanged\",this.handleChainChanged),this.provider.removeListener(\"accountsChanged\",this.handleAccountsChanged),this.provider.removeListener(\"close\",this.handleClose),this.provider.removeListener(\"networkChanged\",this.handleNetworkChanged))},r.isAuthorized=function(){try{var e=this;return e.provider?Promise.resolve(f((function(){return Promise.resolve(e.provider.send(\"eth_accounts\").then((function(e){return p(e).length>0})))}),(function(){return!1}))):Promise.resolve(!1)}catch(t){return Promise.reject(t)}},t}(n.a)},631:function(e,t,r){\"use strict\";r.d(t,\"a\",(function(){return i}));var n=r(59),o=r(70);var i=function(e){var t,r;function n(t){var r,n=(void 0===t?{}:t).supportedChainIds;return(r=e.call(this)||this).supportedChainIds=n,r}r=e,(t=n).prototype=Object.create(r.prototype),t.prototype.constructor=t,t.__proto__=r;var i=n.prototype;return i.emitUpdate=function(e){this.emit(o.a.Update,e)},i.emitError=function(e){this.emit(o.a.Error,e)},i.emitDeactivate=function(){this.emit(o.a.Deactivate)},n}(n.EventEmitter)}}]);","name":"static/js/13.b42d95f2.chunk.js","map":{"version":3,"sources":["static/js/13.b42d95f2.chunk.js"],"names":["this","push","module","__webpack_exports__","__webpack_require__","r","d","NoEthereumProviderError","ProvidedConnector","UserRejectedRequestError","_web3_react_abstract_connector__WEBPACK_IMPORTED_MODULE_0__","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","_setPrototypeOf","p","_isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","e","_construct","Parent","args","Class","a","instance","Function","bind","_wrapNativeSuper","_cache","Map","undefined","fn","indexOf","TypeError","has","get","set","Wrapper","value","enumerable","writable","configurable","_assertThisInitialized","self","ReferenceError","Symbol","iterator","asyncIterator","_catch","body","recover","result","then","parseSendReturn","sendReturn","_Error","_this","name","message","Error","_Error2","_this2","_AbstractConnector","_ref","_this3","_ref$provider","provider","window","ethereum","supportedChainIds","handleNetworkChanged","handleChainChanged","handleAccountsChanged","handleClose","_proto","chainId","emitUpdate","accounts","emitDeactivate","account","code","reason","networkId","activate","_temp5","_result","_exit2","_temp2","_this5","_temp","Promise","resolve","enable","_this4$provider$enabl","on","isMetaMask","autoRefreshOnNetworkChange","_temp6","send","_this4$provider$send$","error","reject","getProvider","getChainId","_temp12","_temp9","_this9","method","_unused","isDapper","cachedResults","net_version","networkVersion","_chainId","_temp8","_temp14","_this8$provider$send$2","_temp13","_this8$provider$send$","getAccount","_temp20","_temp17","_this11","_temp16","_temp22","_this10$provider$enab","_temp21","_this10$provider$send","deactivate","removeListener","isAuthorized","_this13","AbstractConnector","events__WEBPACK_IMPORTED_MODULE_0__","_web3_react_types__WEBPACK_IMPORTED_MODULE_1__","_EventEmitter","update","emit","Update","emitError","Deactivate"],"mappings":"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"},"input":"(this[\"webpackJsonptreasure-blox\"] = this[\"webpackJsonptreasure-blox\"] || []).push([[13],{\n\n/***/ 1356:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoEthereumProviderError\", function() { return NoEthereumProviderError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProvidedConnector\", function() { return ProvidedConnector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UserRejectedRequestError\", function() { return UserRejectedRequestError; });\n/* harmony import */ var _web3_react_abstract_connector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(631);\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (_isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n} // A type of promise-like that resolves synchronously and supports only one observer\n\n\nvar _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = /*#__PURE__*/Symbol(\"Symbol.iterator\")) : \"@@iterator\"; // Asynchronously iterate through an object's values\n\n\nvar _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = /*#__PURE__*/Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n} // Asynchronously await a promise and pass the result to a finally continuation\n\n\nfunction parseSendReturn(sendReturn) {\n  return sendReturn.hasOwnProperty('result') ? sendReturn.result : sendReturn;\n}\n\nvar NoEthereumProviderError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(NoEthereumProviderError, _Error);\n\n  function NoEthereumProviderError() {\n    var _this;\n\n    _this = _Error.call(this) || this;\n    _this.name = _this.constructor.name;\n    _this.message = 'No Ethereum provider was passed to the constructor or found on window.ethereum.';\n    return _this;\n  }\n\n  return NoEthereumProviderError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar UserRejectedRequestError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(UserRejectedRequestError, _Error2);\n\n  function UserRejectedRequestError() {\n    var _this2;\n\n    _this2 = _Error2.call(this) || this;\n    _this2.name = _this2.constructor.name;\n    _this2.message = 'The user rejected the request.';\n    return _this2;\n  }\n\n  return UserRejectedRequestError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar ProvidedConnector = /*#__PURE__*/function (_AbstractConnector) {\n  _inheritsLoose(ProvidedConnector, _AbstractConnector);\n\n  function ProvidedConnector(_ref) {\n    var _this3;\n\n    var _ref$provider = _ref.provider,\n        provider = _ref$provider === void 0 ? window.ethereum : _ref$provider,\n        supportedChainIds = _ref.supportedChainIds;\n    _this3 = _AbstractConnector.call(this, {\n      supportedChainIds: supportedChainIds\n    }) || this;\n    _this3.provider = provider;\n    _this3.handleNetworkChanged = _this3.handleNetworkChanged.bind(_assertThisInitialized(_this3));\n    _this3.handleChainChanged = _this3.handleChainChanged.bind(_assertThisInitialized(_this3));\n    _this3.handleAccountsChanged = _this3.handleAccountsChanged.bind(_assertThisInitialized(_this3));\n    _this3.handleClose = _this3.handleClose.bind(_assertThisInitialized(_this3));\n    return _this3;\n  }\n\n  var _proto = ProvidedConnector.prototype;\n\n  _proto.handleChainChanged = function handleChainChanged(chainId) {\n    if (false) {}\n\n    this.emitUpdate({\n      chainId: chainId,\n      provider: this.provider\n    });\n  };\n\n  _proto.handleAccountsChanged = function handleAccountsChanged(accounts) {\n    if (false) {}\n\n    if (accounts.length === 0) {\n      this.emitDeactivate();\n    } else {\n      this.emitUpdate({\n        account: accounts[0]\n      });\n    }\n  };\n\n  _proto.handleClose = function handleClose(code, reason) {\n    if (false) {}\n\n    this.emitDeactivate();\n  };\n\n  _proto.handleNetworkChanged = function handleNetworkChanged(networkId) {\n    if (false) {}\n\n    this.emitUpdate({\n      chainId: networkId,\n      provider: this.provider\n    });\n  };\n\n  _proto.activate = function activate() {\n    try {\n      var _temp5 = function _temp5(_result) {\n        if (_exit2) return _result;\n\n        function _temp2() {\n          return _extends({\n            provider: _this5.provider\n          }, account ? {\n            account: account\n          } : {});\n        }\n\n        var _temp = function () {\n          if (!account) {\n            // if enable is successful but doesn't return accounts, fall back to getAccount (not happy i have to do this...)\n            return Promise.resolve(_this5.provider.enable().then(function (sendReturn) {\n              return sendReturn && parseSendReturn(sendReturn)[0];\n            })).then(function (_this4$provider$enabl) {\n              account = _this4$provider$enabl;\n            });\n          }\n        }(); // if unsuccessful, try enable\n\n\n        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n      };\n\n      var _exit2 = false;\n\n      var _this5 = this;\n\n      if (!_this5.provider) {\n        throw new NoEthereumProviderError();\n      }\n\n      if (_this5.provider.on) {\n        _this5.provider.on('chainChanged', _this5.handleChainChanged);\n\n        _this5.provider.on('accountsChanged', _this5.handleAccountsChanged);\n\n        _this5.provider.on('close', _this5.handleClose);\n\n        _this5.provider.on('networkChanged', _this5.handleNetworkChanged);\n      }\n\n      if (_this5.provider.isMetaMask) {\n        ;\n        _this5.provider.autoRefreshOnNetworkChange = false;\n      } // try to activate + get account via eth_requestAccounts\n\n\n      var account;\n\n      var _temp6 = _catch(function () {\n        return Promise.resolve(_this5.provider.send('eth_requestAccounts').then(function (sendReturn) {\n          return parseSendReturn(sendReturn)[0];\n        })).then(function (_this4$provider$send$) {\n          account = _this4$provider$send$;\n        });\n      }, function (error) {\n        if (error.code === 4001) {\n          throw new UserRejectedRequestError();\n        }\n\n         false ? undefined : void 0;\n      });\n\n      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getProvider = function getProvider() {\n    try {\n      var _this7 = this;\n\n      return Promise.resolve(_this7.provider);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getChainId = function getChainId() {\n    try {\n      var _temp12 = function _temp12() {\n        function _temp9() {\n          if (!chainId) {\n            try {\n              chainId = parseSendReturn(_this9.provider.send({\n                method: 'net_version'\n              }));\n            } catch (_unused) {\n               false ? undefined : void 0;\n            }\n          }\n\n          if (!chainId) {\n            if (_this9.provider.isDapper) {\n              chainId = parseSendReturn(_this9.provider.cachedResults.net_version);\n            } else {\n              chainId = _this9.provider.chainId || _this9.provider.networkVersion || _this9.provider._chainId;\n            }\n          }\n\n          return chainId;\n        }\n\n        var _temp8 = function () {\n          if (!chainId) {\n            var _temp14 = _catch(function () {\n              return Promise.resolve(_this9.provider.send('net_version').then(parseSendReturn)).then(function (_this8$provider$send$2) {\n                chainId = _this8$provider$send$2;\n              });\n            }, function () {\n               false ? undefined : void 0;\n            });\n\n            if (_temp14 && _temp14.then) return _temp14.then(function () {});\n          }\n        }();\n\n        return _temp8 && _temp8.then ? _temp8.then(_temp9) : _temp9(_temp8);\n      };\n\n      var _this9 = this;\n\n      if (!_this9.provider) {\n        throw new NoEthereumProviderError();\n      }\n\n      var chainId;\n\n      var _temp13 = _catch(function () {\n        return Promise.resolve(_this9.provider.send('eth_chainId').then(parseSendReturn)).then(function (_this8$provider$send$) {\n          chainId = _this8$provider$send$;\n        });\n      }, function () {\n         false ? undefined : void 0;\n      });\n\n      return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(_temp12) : _temp12(_temp13));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getAccount = function getAccount() {\n    try {\n      var _temp20 = function _temp20() {\n        function _temp17() {\n          if (!account) {\n            account = parseSendReturn(_this11.provider.send({\n              method: 'eth_accounts'\n            }))[0];\n          }\n\n          return account;\n        }\n\n        var _temp16 = function () {\n          if (!account) {\n            var _temp22 = _catch(function () {\n              return Promise.resolve(_this11.provider.enable().then(function (sendReturn) {\n                return parseSendReturn(sendReturn)[0];\n              })).then(function (_this10$provider$enab) {\n                account = _this10$provider$enab;\n              });\n            }, function () {\n               false ? undefined : void 0;\n            });\n\n            if (_temp22 && _temp22.then) return _temp22.then(function () {});\n          }\n        }();\n\n        return _temp16 && _temp16.then ? _temp16.then(_temp17) : _temp17(_temp16);\n      };\n\n      var _this11 = this;\n\n      if (!_this11.provider) {\n        throw new NoEthereumProviderError();\n      }\n\n      var account;\n\n      var _temp21 = _catch(function () {\n        return Promise.resolve(_this11.provider.send('eth_accounts').then(function (sendReturn) {\n          return parseSendReturn(sendReturn)[0];\n        })).then(function (_this10$provider$send) {\n          account = _this10$provider$send;\n        });\n      }, function () {\n         false ? undefined : void 0;\n      });\n\n      return Promise.resolve(_temp21 && _temp21.then ? _temp21.then(_temp20) : _temp20(_temp21));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.deactivate = function deactivate() {\n    if (this.provider && this.provider.removeListener) {\n      this.provider.removeListener('chainChanged', this.handleChainChanged);\n      this.provider.removeListener('accountsChanged', this.handleAccountsChanged);\n      this.provider.removeListener('close', this.handleClose);\n      this.provider.removeListener('networkChanged', this.handleNetworkChanged);\n    }\n  };\n\n  _proto.isAuthorized = function isAuthorized() {\n    try {\n      var _this13 = this;\n\n      if (!_this13.provider) {\n        return Promise.resolve(false);\n      }\n\n      return Promise.resolve(_catch(function () {\n        return Promise.resolve(_this13.provider.send('eth_accounts').then(function (sendReturn) {\n          if (parseSendReturn(sendReturn).length > 0) {\n            return true;\n          } else {\n            return false;\n          }\n        }));\n      }, function () {\n        return false;\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return ProvidedConnector;\n}(_web3_react_abstract_connector__WEBPACK_IMPORTED_MODULE_0__[/* AbstractConnector */ \"a\"]);\n\n\n\n/***/ }),\n\n/***/ 631:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AbstractConnector; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _web3_react_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);\n\n\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar AbstractConnector = /*#__PURE__*/function (_EventEmitter) {\n  _inheritsLoose(AbstractConnector, _EventEmitter);\n\n  function AbstractConnector(_temp) {\n    var _this;\n\n    var _ref = _temp === void 0 ? {} : _temp,\n        supportedChainIds = _ref.supportedChainIds;\n\n    _this = _EventEmitter.call(this) || this;\n    _this.supportedChainIds = supportedChainIds;\n    return _this;\n  }\n\n  var _proto = AbstractConnector.prototype;\n\n  _proto.emitUpdate = function emitUpdate(update) {\n    if (false) {}\n\n    this.emit(_web3_react_types__WEBPACK_IMPORTED_MODULE_1__[/* ConnectorEvent */ \"a\"].Update, update);\n  };\n\n  _proto.emitError = function emitError(error) {\n    if (false) {}\n\n    this.emit(_web3_react_types__WEBPACK_IMPORTED_MODULE_1__[/* ConnectorEvent */ \"a\"].Error, error);\n  };\n\n  _proto.emitDeactivate = function emitDeactivate() {\n    if (false) {}\n\n    this.emit(_web3_react_types__WEBPACK_IMPORTED_MODULE_1__[/* ConnectorEvent */ \"a\"].Deactivate);\n  };\n\n  return AbstractConnector;\n}(events__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter\"]);\n\n\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts"],"names":["_iteratorSymbol","Symbol","_asyncIteratorSymbol","result","body","recover","sendReturn","NoEthereumProviderError","UserRejectedRequestError","ProvidedConnector","provider","window","ethereum","supportedChainIds","handleChainChanged","chainId","handleAccountsChanged","accounts","account","handleClose","handleNetworkChanged","parseSendReturn","error","method","deactivate","AbstractConnector","emitUpdate","ConnectorEvent","emitError","emitDeactivate"],"mappings":"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","file":"x","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { EventEmitter } from 'events'\nimport { AbstractConnectorArguments, ConnectorUpdate, ConnectorEvent } from '@web3-react/types'\n\nexport abstract class AbstractConnector extends EventEmitter {\n  public readonly supportedChainIds?: number[]\n\n  constructor({ supportedChainIds }: AbstractConnectorArguments = {}) {\n    super()\n    this.supportedChainIds = supportedChainIds\n  }\n\n  public abstract async activate(): Promise<ConnectorUpdate>\n  public abstract async getProvider(): Promise<any>\n  public abstract async getChainId(): Promise<number | string>\n  public abstract async getAccount(): Promise<null | string>\n  public abstract deactivate(): void\n\n  protected emitUpdate(update: ConnectorUpdate): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Update}' with payload`, update)\n    }\n    this.emit(ConnectorEvent.Update, update)\n  }\n\n  protected emitError(error: Error): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Error}' with payload`, error)\n    }\n    this.emit(ConnectorEvent.Error, error)\n  }\n\n  protected emitDeactivate(): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Deactivate}'`)\n    }\n    this.emit(ConnectorEvent.Deactivate)\n  }\n}\n"]}}