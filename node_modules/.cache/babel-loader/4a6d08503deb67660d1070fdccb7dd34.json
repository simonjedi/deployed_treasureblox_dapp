{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DataEncryptionKeyUtils = exports.deriveDek = exports.decompressPublicKey = exports.compressedPubKey = void 0;\n\nvar elliptic_1 = require(\"elliptic\");\n\nvar account_1 = require(\"./account\");\n\nvar address_1 = require(\"./address\");\n\nvar ec = new elliptic_1.ec('secp256k1');\n/**\n * Turns a private key to a compressed public key (hex string with hex leader).\n *\n * @param {Buffer} privateKey Private key.\n * @returns {string} Corresponding compessed public key in hex encoding with '0x' leader.\n */\n\nfunction compressedPubKey(privateKey) {\n  var key = ec.keyFromPrivate(privateKey);\n  return (0, address_1.ensureLeading0x)(key.getPublic(true, 'hex'));\n}\n\nexports.compressedPubKey = compressedPubKey;\n/**\n * Decompresses a public key and strips out the '0x04' leading constant. This makes\n * any public key suitable to be used with this ECIES implementation.\n *\n * @param publicKey Public key in standard form (with 0x02, 0x03, or 0x04 prefix)\n * @returns Decompresssed public key without prefix.\n */\n\nfunction decompressPublicKey(publicKey) {\n  return Buffer.from(ec.keyFromPublic(publicKey).getPublic(false, 'hex'), 'hex').slice(1);\n}\n\nexports.decompressPublicKey = decompressPublicKey;\n/**\n * Derives a data encryption key from the mnemonic\n *\n * @param {string} privateKey Hex encoded private account key.\n * @returns {Buffer} Comment Encryption Private key.\n */\n\nfunction deriveDek(mnemonic, bip39ToUse) {\n  if (!mnemonic) {\n    throw new Error('Invalid mnemonic');\n  }\n\n  return (0, account_1.generateKeys)(mnemonic, undefined, 1, // The DEK is derived from change index 1, not 0 like the wallet's transaction keys\n  0, bip39ToUse);\n}\n\nexports.deriveDek = deriveDek;\nexports.DataEncryptionKeyUtils = {\n  compressedPubKey: compressedPubKey,\n  decompressPublicKey: decompressPublicKey,\n  deriveDek: deriveDek\n};","map":{"version":3,"sources":["../src/dataEncryptionKey.ts"],"names":[],"mappings":";;;;;;;AAAA,IAAA,UAAA,GAAA,OAAA,CAAA,UAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AACA,IAAA,SAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,IAAM,EAAE,GAAG,IAAI,UAAA,CAAA,EAAJ,CAAO,WAAP,CAAX;AAEA;;;;;AAKG;;AACH,SAAgB,gBAAhB,CAAiC,UAAjC,EAAmD;AACjD,MAAM,GAAG,GAAG,EAAE,CAAC,cAAH,CAAkB,UAAlB,CAAZ;AACA,SAAO,CAAA,GAAA,SAAA,CAAA,eAAA,EAAgB,GAAG,CAAC,SAAJ,CAAc,IAAd,EAAoB,KAApB,CAAhB,CAAP;AACD;;AAHD,OAAA,CAAA,gBAAA,GAAA,gBAAA;AAKA;;;;;;AAMG;;AACH,SAAgB,mBAAhB,CAAoC,SAApC,EAAqD;AACnD,SAAO,MAAM,CAAC,IAAP,CAAY,EAAE,CAAC,aAAH,CAAiB,SAAjB,EAA4B,SAA5B,CAAsC,KAAtC,EAA6C,KAA7C,CAAZ,EAAiE,KAAjE,EAAwE,KAAxE,CAA8E,CAA9E,CAAP;AACD;;AAFD,OAAA,CAAA,mBAAA,GAAA,mBAAA;AAIA;;;;;AAKG;;AACH,SAAgB,SAAhB,CAA0B,QAA1B,EAA4C,UAA5C,EAA8D;AAC5D,MAAI,CAAC,QAAL,EAAe;AACb,UAAM,IAAI,KAAJ,CAAU,kBAAV,CAAN;AACD;;AAED,SAAO,CAAA,GAAA,SAAA,CAAA,YAAA,EACL,QADK,EAEL,SAFK,EAGL,CAHK,EAGF;AACH,GAJK,EAKL,UALK,CAAP;AAOD;;AAZD,OAAA,CAAA,SAAA,GAAA,SAAA;AAca,OAAA,CAAA,sBAAA,GAAyB;AACpC,EAAA,gBAAgB,EAAA,gBADoB;AAEpC,EAAA,mBAAmB,EAAA,mBAFiB;AAGpC,EAAA,SAAS,EAAA;AAH2B,CAAzB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.DataEncryptionKeyUtils = exports.deriveDek = exports.decompressPublicKey = exports.compressedPubKey = void 0;\nvar elliptic_1 = require(\"elliptic\");\nvar account_1 = require(\"./account\");\nvar address_1 = require(\"./address\");\nvar ec = new elliptic_1.ec('secp256k1');\n/**\n * Turns a private key to a compressed public key (hex string with hex leader).\n *\n * @param {Buffer} privateKey Private key.\n * @returns {string} Corresponding compessed public key in hex encoding with '0x' leader.\n */\nfunction compressedPubKey(privateKey) {\n    var key = ec.keyFromPrivate(privateKey);\n    return (0, address_1.ensureLeading0x)(key.getPublic(true, 'hex'));\n}\nexports.compressedPubKey = compressedPubKey;\n/**\n * Decompresses a public key and strips out the '0x04' leading constant. This makes\n * any public key suitable to be used with this ECIES implementation.\n *\n * @param publicKey Public key in standard form (with 0x02, 0x03, or 0x04 prefix)\n * @returns Decompresssed public key without prefix.\n */\nfunction decompressPublicKey(publicKey) {\n    return Buffer.from(ec.keyFromPublic(publicKey).getPublic(false, 'hex'), 'hex').slice(1);\n}\nexports.decompressPublicKey = decompressPublicKey;\n/**\n * Derives a data encryption key from the mnemonic\n *\n * @param {string} privateKey Hex encoded private account key.\n * @returns {Buffer} Comment Encryption Private key.\n */\nfunction deriveDek(mnemonic, bip39ToUse) {\n    if (!mnemonic) {\n        throw new Error('Invalid mnemonic');\n    }\n    return (0, account_1.generateKeys)(mnemonic, undefined, 1, // The DEK is derived from change index 1, not 0 like the wallet's transaction keys\n    0, bip39ToUse);\n}\nexports.deriveDek = deriveDek;\nexports.DataEncryptionKeyUtils = {\n    compressedPubKey: compressedPubKey,\n    decompressPublicKey: decompressPublicKey,\n    deriveDek: deriveDek,\n};\n//# sourceMappingURL=dataEncryptionKey.js.map"]},"metadata":{},"sourceType":"script"}