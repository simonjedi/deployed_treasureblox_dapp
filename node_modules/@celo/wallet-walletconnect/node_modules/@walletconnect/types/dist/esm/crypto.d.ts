import { JsonRpcPayload } from "@walletconnect/jsonrpc-types";
import { Logger } from "pino";
import { IClient } from "./client";
export declare namespace CryptoTypes {
    interface Participant {
        publicKey: string;
    }
    interface KeyPair {
        privateKey: string;
        publicKey: string;
    }
    interface EncryptionKeys {
        sharedKey: string;
        publicKey: string;
        iv?: string;
    }
    interface EncryptParams extends EncryptionKeys {
        message: string;
    }
    interface DecryptParams {
        sharedKey: string;
        encrypted: string;
    }
}
export declare abstract class IKeyChain {
    client: IClient;
    logger: Logger;
    abstract keychain: Map<string, string>;
    abstract name: string;
    abstract readonly context: string;
    constructor(client: IClient, logger: Logger);
    abstract init(): Promise<void>;
    abstract has(tag: string, opts?: any): Promise<boolean>;
    abstract set(tag: string, key: string, opts?: any): Promise<void>;
    abstract get(tag: string, opts?: any): Promise<string>;
    abstract del(tag: string, opts?: any): Promise<void>;
}
export declare abstract class ICrypto {
    client: IClient;
    logger: Logger;
    abstract name: string;
    abstract readonly context: string;
    abstract keychain: IKeyChain;
    constructor(client: IClient, logger: Logger, keychain?: IKeyChain);
    abstract init(): Promise<void>;
    abstract hasKeys(tag: string): Promise<boolean>;
    abstract generateKeyPair(): Promise<string>;
    abstract generateSharedKey(self: CryptoTypes.Participant, peer: CryptoTypes.Participant, overrideTopic?: string): Promise<string>;
    abstract encrypt(topic: string, message: string): Promise<string>;
    abstract decrypt(topic: string, encrypted: string): Promise<string>;
    abstract encodeJsonRpc(topic: string, payload: JsonRpcPayload): Promise<string>;
    abstract decodeJsonRpc(topic: string, encrypted: string): Promise<JsonRpcPayload>;
}
//# sourceMappingURL=crypto.d.ts.map