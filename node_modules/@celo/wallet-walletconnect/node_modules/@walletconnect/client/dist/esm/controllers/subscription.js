import { EventEmitter } from "events";
import { ISubscription, } from "@walletconnect/types";
import { ERROR, formatMessageContext, toMiliseconds, calcExpiry } from "@walletconnect/utils";
import { generateChildLogger, getLoggerContext } from "@walletconnect/logger";
import { CLIENT_EVENTS, SUBSCRIPTION_CONTEXT, SUBSCRIPTION_DEFAULT_TTL, SUBSCRIPTION_EVENTS, } from "../constants";
export class SubscriptionTopicMap {
    constructor() {
        this.map = new Map();
    }
    get topics() {
        return Array.from(this.map.keys());
    }
    set(topic, id) {
        const ids = this.get(topic);
        if (this.exists(topic, id))
            return;
        this.map.set(topic, [...ids, id]);
    }
    get(topic) {
        const ids = this.map.get(topic);
        return ids || [];
    }
    exists(topic, id) {
        const ids = this.get(topic);
        return ids.includes(id);
    }
    delete(topic, id) {
        if (typeof id === "undefined") {
            this.map.delete(topic);
            return;
        }
        if (!this.map.has(topic))
            return;
        const ids = this.get(topic);
        if (!this.exists(topic, id))
            return;
        const remaining = ids.filter(x => x !== id);
        if (!remaining.length) {
            this.map.delete(topic);
            return;
        }
        this.map.set(topic, remaining);
    }
    clear() {
        this.map.clear();
    }
}
export class Subscription extends ISubscription {
    constructor(client, logger) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.subscriptions = new Map();
        this.topicMap = new SubscriptionTopicMap();
        this.events = new EventEmitter();
        this.name = SUBSCRIPTION_CONTEXT;
        this.cached = [];
        this.logger = generateChildLogger(logger, this.name);
        this.registerEventListeners();
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.initialize();
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    get length() {
        return this.subscriptions.size;
    }
    get ids() {
        return Array.from(this.subscriptions.keys());
    }
    get values() {
        return Array.from(this.subscriptions.values());
    }
    get topics() {
        return this.topicMap.topics;
    }
    async set(id, subscription) {
        await this.isEnabled();
        if (this.subscriptions.has(id))
            return;
        this.logger.debug(`Setting subscription`);
        this.logger.trace({ type: "method", method: "set", id, subscription });
        this.setSubscription(id, subscription);
        this.events.emit(SUBSCRIPTION_EVENTS.created, subscription);
    }
    async get(id) {
        await this.isEnabled();
        this.logger.debug(`Getting subscription`);
        this.logger.trace({ type: "method", method: "get", id });
        const subscription = this.getSubscription(id);
        return subscription;
    }
    async exists(id, topic) {
        await this.isEnabled();
        let result = false;
        try {
            const subscription = this.getSubscription(id);
            result = subscription.topic === topic;
        }
        catch (e) {
        }
        return result;
    }
    async delete(id, reason) {
        await this.isEnabled();
        this.logger.debug(`Deleting subscription`);
        this.logger.trace({ type: "method", method: "delete", id, reason });
        const subscription = this.getSubscription(id);
        this.deleteSubscription(id, subscription);
        this.events.emit(SUBSCRIPTION_EVENTS.deleted, Object.assign(Object.assign({}, subscription), { reason }));
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    async enable() {
        if (!this.cached.length)
            return;
        this.reset();
        this.onEnable();
    }
    async disable() {
        if (this.cached.length)
            return;
        this.onDisable();
    }
    reset() {
        this.cached.map(async (subscription) => this.setSubscription(subscription.id, subscription));
    }
    onEnable() {
        this.cached = [];
        this.events.emit(SUBSCRIPTION_EVENTS.enabled);
    }
    onDisable() {
        this.cached = this.values;
        this.subscriptions.clear();
        this.topicMap.clear();
        this.events.emit(SUBSCRIPTION_EVENTS.disabled);
    }
    setSubscription(id, subscription) {
        const expiry = subscription.expiry || calcExpiry(SUBSCRIPTION_DEFAULT_TTL);
        this.subscriptions.set(id, Object.assign(Object.assign({}, subscription), { expiry }));
        this.topicMap.set(subscription.topic, id);
        this.checkExpiry(id, expiry);
    }
    getSubscription(id) {
        const subscription = this.subscriptions.get(id);
        if (!subscription) {
            const error = ERROR.NO_MATCHING_ID.format({
                context: formatMessageContext(this.context),
                id,
            });
            throw new Error(error.message);
        }
        return subscription;
    }
    deleteSubscription(id, subscription) {
        this.subscriptions.delete(id);
        this.topicMap.delete(subscription.topic, id);
    }
    checkExpiry(id, expiry) {
        const msToTimeout = toMiliseconds(expiry) - Date.now();
        if (msToTimeout <= 0)
            this.expire(id);
    }
    expire(id) {
        const reason = ERROR.EXPIRED.format({ context: formatMessageContext(this.context) });
        const subscription = this.getSubscription(id);
        this.deleteSubscription(id, subscription);
        this.events.emit(SUBSCRIPTION_EVENTS.deleted, Object.assign(Object.assign({}, subscription), { reason }));
    }
    checkSubscriptions() {
        this.subscriptions.forEach(subscription => this.checkExpiry(subscription.id, subscription.expiry));
    }
    async persist() {
        await this.client.storage.setRelayerSubscriptions(this.context, this.values);
        this.events.emit(SUBSCRIPTION_EVENTS.sync);
    }
    async restore() {
        try {
            const persisted = await this.client.storage.getRelayerSubscriptions(this.context);
            if (typeof persisted === "undefined")
                return;
            if (!persisted.length)
                return;
            if (this.subscriptions.size) {
                const error = ERROR.RESTORE_WILL_OVERRIDE.format({
                    context: formatMessageContext(this.context),
                });
                this.logger.error(error.message);
                throw new Error(error.message);
            }
            this.cached = persisted;
            this.logger.debug(`Successfully Restored subscriptions for ${formatMessageContext(this.context)}`);
            this.logger.trace({ type: "method", method: "restore", subscriptions: this.values });
        }
        catch (e) {
            this.logger.debug(`Failed to Restore subscriptions for ${formatMessageContext(this.context)}`);
            this.logger.error(e);
        }
    }
    async initialize() {
        await this.restore();
        this.reset();
        this.onInit();
    }
    onInit() {
        this.onEnable();
    }
    async isEnabled() {
        if (!this.cached.length)
            return;
        return new Promise(resolve => {
            this.events.once(SUBSCRIPTION_EVENTS.enabled, () => resolve());
        });
    }
    onExpiry(expiredEvent) {
        const eventName = SUBSCRIPTION_EVENTS.expired;
        this.logger.info(`Emitting ${eventName}`);
        this.logger.debug({ type: "event", event: eventName, data: expiredEvent });
        this.events.emit(SUBSCRIPTION_EVENTS.expired, expiredEvent);
    }
    registerEventListeners() {
        this.client.on(CLIENT_EVENTS.beat, () => this.checkSubscriptions());
        this.events.on(SUBSCRIPTION_EVENTS.created, async (createdEvent) => {
            const eventName = SUBSCRIPTION_EVENTS.created;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: createdEvent });
            await this.persist();
        });
        this.events.on(SUBSCRIPTION_EVENTS.deleted, async (deletedEvent) => {
            const eventName = SUBSCRIPTION_EVENTS.deleted;
            this.logger.info(`Emitting ${eventName}`);
            this.logger.debug({ type: "event", event: eventName, data: deletedEvent });
            await this.persist();
            if (deletedEvent.reason.code === ERROR.EXPIRED.code)
                this.onExpiry(deletedEvent);
        });
    }
}
//# sourceMappingURL=subscription.js.map