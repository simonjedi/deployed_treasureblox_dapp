"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Storage = void 0;
const tslib_1 = require("tslib");
const logger_1 = require("@walletconnect/logger");
const utils_1 = require("@walletconnect/utils");
const constants_1 = require("../constants");
class Storage {
    constructor(client, logger, keyValueStorage) {
        this.client = client;
        this.logger = logger;
        this.keyValueStorage = keyValueStorage;
        this.name = constants_1.STORAGE_CONTEXT;
        this.version = constants_1.STORAGE_VERSION;
        this.keyMap = constants_1.STORAGE_KEYS;
        this.client = client;
        this.logger = logger_1.generateChildLogger(logger, this.name);
        this.keyValueStorage = keyValueStorage;
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    get prefix() {
        return `${this.client.protocol}@${this.client.version}:${this.client.context}:${this.version}`;
    }
    setKeyChain(context, keychain) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.getStorageKey(context);
            yield this.keyValueStorage.setItem(key, utils_1.mapToObj(keychain));
        });
    }
    getKeyChain(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.getStorageKey(context);
            const keychain = yield this.keyValueStorage.getItem(key);
            return typeof keychain !== "undefined" ? utils_1.objToMap(keychain) : undefined;
        });
    }
    setSequenceState(context, sequences) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.getStorageKey(context);
            yield this.keyValueStorage.setItem(key, sequences);
        });
    }
    getSequenceState(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.getStorageKey(context);
            const sequences = yield this.keyValueStorage.getItem(key);
            return sequences;
        });
    }
    setJsonRpcRecords(context, records) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.getStorageKey(context);
            yield this.keyValueStorage.setItem(key, records);
        });
    }
    getJsonRpcRecords(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.getStorageKey(context);
            const records = yield this.keyValueStorage.getItem(key);
            return records;
        });
    }
    setRelayerSubscriptions(context, subscriptions) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.getStorageKey(context);
            yield this.keyValueStorage.setItem(key, subscriptions);
        });
    }
    getRelayerSubscriptions(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.getStorageKey(context);
            const subscriptions = yield this.keyValueStorage.getItem(key);
            return subscriptions;
        });
    }
    getStorageKey(context) {
        const name = this.getStorageKeyName(context);
        if (!this.isValidStorageKeyName(name)) {
            const error = utils_1.ERROR.INVALID_STORAGE_KEY_NAME.format({ name });
            throw new Error(error.message);
        }
        const key = this.prefix + "//" + name;
        return key;
    }
    getStorageKeyName(context) {
        return utils_1.formatStorageKeyName(context);
    }
    isValidStorageKeyName(name) {
        const validKeys = Object.keys(this.keyMap)
            .map(key => Object.values(this.keyMap[key]))
            .flat();
        return validKeys.includes(name.toLowerCase());
    }
}
exports.Storage = Storage;
//# sourceMappingURL=storage.js.map