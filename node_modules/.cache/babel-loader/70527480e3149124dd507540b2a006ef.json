{"ast":null,"code":"'use strict';\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar crypto_1 = require(\"crypto\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar errors = __importStar(require(\"../errors\"));\n\nvar SupportedAlgorithms;\n\n(function (SupportedAlgorithms) {\n  SupportedAlgorithms[\"sha256\"] = \"sha256\";\n  SupportedAlgorithms[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithms = exports.SupportedAlgorithms || (exports.SupportedAlgorithms = {}));\n\n;\n\nfunction computeHmac(algorithm, key, data) {\n  if (!SupportedAlgorithms[algorithm]) {\n    errors.throwError('unsupported algorithm ' + algorithm, errors.UNSUPPORTED_OPERATION, {\n      operation: 'hmac',\n      algorithm: algorithm\n    });\n  }\n\n  return bytes_1.arrayify(crypto_1.createHmac(algorithm, Buffer.from(bytes_1.arrayify(key))).update(Buffer.from(bytes_1.arrayify(data))).digest());\n}\n\nexports.computeHmac = computeHmac;","map":{"version":3,"sources":["/Users/jedi/Desktop/Education/REACT/deployed_treasureblox_dapp/node_modules/@meterio/ethers/utils/hmac.js"],"names":["__importStar","mod","__esModule","result","k","Object","hasOwnProperty","call","defineProperty","exports","value","crypto_1","require","bytes_1","errors","SupportedAlgorithms","computeHmac","algorithm","key","data","throwError","UNSUPPORTED_OPERATION","operation","arrayify","createHmac","Buffer","from","update","digest"],"mappings":"AAAA;;AACA,IAAIA,YAAY,GAAI,QAAQ,KAAKA,YAAd,IAA+B,UAAUC,GAAV,EAAe;AAC7D,MAAIA,GAAG,IAAIA,GAAG,CAACC,UAAf,EAA2B,OAAOD,GAAP;AAC3B,MAAIE,MAAM,GAAG,EAAb;AACA,MAAIF,GAAG,IAAI,IAAX,EAAiB,KAAK,IAAIG,CAAT,IAAcH,GAAd,EAAmB,IAAII,MAAM,CAACC,cAAP,CAAsBC,IAAtB,CAA2BN,GAA3B,EAAgCG,CAAhC,CAAJ,EAAwCD,MAAM,CAACC,CAAD,CAAN,GAAYH,GAAG,CAACG,CAAD,CAAf;AAC5ED,EAAAA,MAAM,CAAC,SAAD,CAAN,GAAoBF,GAApB;AACA,SAAOE,MAAP;AACH,CAND;;AAOAE,MAAM,CAACG,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,SAAD,CAArB;;AACA,IAAIE,MAAM,GAAGd,YAAY,CAACY,OAAO,CAAC,WAAD,CAAR,CAAzB;;AACA,IAAIG,mBAAJ;;AACA,CAAC,UAAUA,mBAAV,EAA+B;AAC5BA,EAAAA,mBAAmB,CAAC,QAAD,CAAnB,GAAgC,QAAhC;AACAA,EAAAA,mBAAmB,CAAC,QAAD,CAAnB,GAAgC,QAAhC;AACH,CAHD,EAGGA,mBAAmB,GAAGN,OAAO,CAACM,mBAAR,KAAgCN,OAAO,CAACM,mBAAR,GAA8B,EAA9D,CAHzB;;AAIA;;AACA,SAASC,WAAT,CAAqBC,SAArB,EAAgCC,GAAhC,EAAqCC,IAArC,EAA2C;AACvC,MAAI,CAACJ,mBAAmB,CAACE,SAAD,CAAxB,EAAqC;AACjCH,IAAAA,MAAM,CAACM,UAAP,CAAkB,2BAA2BH,SAA7C,EAAwDH,MAAM,CAACO,qBAA/D,EAAsF;AAAEC,MAAAA,SAAS,EAAE,MAAb;AAAqBL,MAAAA,SAAS,EAAEA;AAAhC,KAAtF;AACH;;AACD,SAAOJ,OAAO,CAACU,QAAR,CAAiBZ,QAAQ,CAACa,UAAT,CAAoBP,SAApB,EAA+BQ,MAAM,CAACC,IAAP,CAAYb,OAAO,CAACU,QAAR,CAAiBL,GAAjB,CAAZ,CAA/B,EAAmES,MAAnE,CAA0EF,MAAM,CAACC,IAAP,CAAYb,OAAO,CAACU,QAAR,CAAiBJ,IAAjB,CAAZ,CAA1E,EAA+GS,MAA/G,EAAjB,CAAP;AACH;;AACDnB,OAAO,CAACO,WAAR,GAAsBA,WAAtB","sourcesContent":["'use strict';\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar crypto_1 = require(\"crypto\");\nvar bytes_1 = require(\"./bytes\");\nvar errors = __importStar(require(\"../errors\"));\nvar SupportedAlgorithms;\n(function (SupportedAlgorithms) {\n    SupportedAlgorithms[\"sha256\"] = \"sha256\";\n    SupportedAlgorithms[\"sha512\"] = \"sha512\";\n})(SupportedAlgorithms = exports.SupportedAlgorithms || (exports.SupportedAlgorithms = {}));\n;\nfunction computeHmac(algorithm, key, data) {\n    if (!SupportedAlgorithms[algorithm]) {\n        errors.throwError('unsupported algorithm ' + algorithm, errors.UNSUPPORTED_OPERATION, { operation: 'hmac', algorithm: algorithm });\n    }\n    return bytes_1.arrayify(crypto_1.createHmac(algorithm, Buffer.from(bytes_1.arrayify(key))).update(Buffer.from(bytes_1.arrayify(data))).digest());\n}\nexports.computeHmac = computeHmac;\n"]},"metadata":{},"sourceType":"script"}