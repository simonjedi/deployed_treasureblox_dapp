{"ast":null,"code":"\"use strict\";\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.mapAddressListDataOnto = exports.mapAddressListOnto = exports.findAddressIndex = exports.NULL_ADDRESS = exports.bufferToHex = exports.hexToBuffer = exports.isHexString = exports.getAddressChunks = exports.ensureLeading0x = exports.trimLeading0x = exports.normalizeAddressWith0x = exports.isNullAddress = exports.normalizeAddress = exports.eqAddress = void 0;\nvar HEX_REGEX = /^0x[0-9A-F]*$/i;\n\nvar eqAddress = function (a, b) {\n  return (0, exports.normalizeAddress)(a) === (0, exports.normalizeAddress)(b);\n};\n\nexports.eqAddress = eqAddress;\n\nvar normalizeAddress = function (a) {\n  return (0, exports.trimLeading0x)(a).toLowerCase();\n};\n\nexports.normalizeAddress = normalizeAddress;\n\nvar isNullAddress = function (a) {\n  return (0, exports.normalizeAddress)(a) === exports.NULL_ADDRESS;\n};\n\nexports.isNullAddress = isNullAddress;\n\nvar normalizeAddressWith0x = function (a) {\n  return (0, exports.ensureLeading0x)(a).toLowerCase();\n};\n\nexports.normalizeAddressWith0x = normalizeAddressWith0x;\n\nvar trimLeading0x = function (input) {\n  return input.startsWith('0x') ? input.slice(2) : input;\n};\n\nexports.trimLeading0x = trimLeading0x;\n\nvar ensureLeading0x = function (input) {\n  return input.startsWith('0x') ? input : \"0x\" + input;\n};\n\nexports.ensureLeading0x = ensureLeading0x; // Turns '0xce10ce10ce10ce10ce10ce10ce10ce10ce10ce10'\n// into ['ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10']\n\nvar getAddressChunks = function (input) {\n  return (0, exports.trimLeading0x)(input).match(/.{1,4}/g) || [];\n};\n\nexports.getAddressChunks = getAddressChunks;\n\nvar isHexString = function (input) {\n  return HEX_REGEX.test(input);\n};\n\nexports.isHexString = isHexString;\n\nvar hexToBuffer = function (input) {\n  return Buffer.from((0, exports.trimLeading0x)(input), 'hex');\n};\n\nexports.hexToBuffer = hexToBuffer;\n\nvar bufferToHex = function (buf) {\n  return (0, exports.ensureLeading0x)(buf.toString('hex'));\n};\n\nexports.bufferToHex = bufferToHex;\nexports.NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\n\nvar findAddressIndex = function (address, addresses) {\n  return addresses.findIndex(function (x) {\n    return (0, exports.eqAddress)(x, address);\n  });\n};\n\nexports.findAddressIndex = findAddressIndex; // Returns an array of indices mapping the entries of oldAddress[] to newAddress[]\n\nvar mapAddressListOnto = function (oldAddress, newAddress) {\n  var oldAddressIndex = oldAddress.map(function (x, index) {\n    return {\n      address: (0, exports.normalizeAddress)(x),\n      index: index\n    };\n  });\n  var newAddressIndex = newAddress.map(function (x, index) {\n    return {\n      address: (0, exports.normalizeAddress)(x),\n      index: index\n    };\n  });\n  oldAddressIndex.sort(function (a, b) {\n    return a.address.localeCompare(b.address);\n  });\n  newAddressIndex.sort(function (a, b) {\n    return a.address.localeCompare(b.address);\n  });\n\n  var res = __spreadArray([], Array(oldAddress.length).fill(-1), true);\n\n  for (var i = 0, j = 0; i < oldAddress.length && j < newAddress.length;) {\n    var cmp = oldAddressIndex[i].address.localeCompare(newAddressIndex[j].address);\n\n    if (cmp < 0) {\n      i++;\n    } else if (cmp > 0) {\n      j++;\n    } else {\n      // Address is present in both lists\n      res[oldAddressIndex[i].index] = newAddressIndex[j].index;\n      i++;\n      j++;\n    }\n  }\n\n  return res;\n};\n\nexports.mapAddressListOnto = mapAddressListOnto; // Returns data[] reordered by mapAddressListOnto(), and initiaValue for any entry of\n// oldAddress[] not present in newAddress[].\n\nfunction mapAddressListDataOnto(data, oldAddress, newAddress, initialValue) {\n  var res = __spreadArray([], Array(oldAddress.length).fill(initialValue), true);\n\n  if (data.length === 0) {\n    return res;\n  }\n\n  var addressIndexMap = (0, exports.mapAddressListOnto)(oldAddress, newAddress);\n\n  for (var i = 0; i < addressIndexMap.length; i++) {\n    if (addressIndexMap[i] >= 0) {\n      res[addressIndexMap[i]] = data[i];\n    }\n  }\n\n  return res;\n}\n\nexports.mapAddressListDataOnto = mapAddressListDataOnto;","map":{"version":3,"sources":["../src/address.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mapAddressListDataOnto = exports.mapAddressListOnto = exports.findAddressIndex = exports.NULL_ADDRESS = exports.bufferToHex = exports.hexToBuffer = exports.isHexString = exports.getAddressChunks = exports.ensureLeading0x = exports.trimLeading0x = exports.normalizeAddressWith0x = exports.isNullAddress = exports.normalizeAddress = exports.eqAddress = void 0;\nvar HEX_REGEX = /^0x[0-9A-F]*$/i;\nvar eqAddress = function (a, b) { return (0, exports.normalizeAddress)(a) === (0, exports.normalizeAddress)(b); };\nexports.eqAddress = eqAddress;\nvar normalizeAddress = function (a) { return (0, exports.trimLeading0x)(a).toLowerCase(); };\nexports.normalizeAddress = normalizeAddress;\nvar isNullAddress = function (a) { return (0, exports.normalizeAddress)(a) === exports.NULL_ADDRESS; };\nexports.isNullAddress = isNullAddress;\nvar normalizeAddressWith0x = function (a) { return (0, exports.ensureLeading0x)(a).toLowerCase(); };\nexports.normalizeAddressWith0x = normalizeAddressWith0x;\nvar trimLeading0x = function (input) { return (input.startsWith('0x') ? input.slice(2) : input); };\nexports.trimLeading0x = trimLeading0x;\nvar ensureLeading0x = function (input) { return (input.startsWith('0x') ? input : \"0x\" + input); };\nexports.ensureLeading0x = ensureLeading0x;\n// Turns '0xce10ce10ce10ce10ce10ce10ce10ce10ce10ce10'\n// into ['ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10','ce10']\nvar getAddressChunks = function (input) {\n    return (0, exports.trimLeading0x)(input).match(/.{1,4}/g) || [];\n};\nexports.getAddressChunks = getAddressChunks;\nvar isHexString = function (input) { return HEX_REGEX.test(input); };\nexports.isHexString = isHexString;\nvar hexToBuffer = function (input) { return Buffer.from((0, exports.trimLeading0x)(input), 'hex'); };\nexports.hexToBuffer = hexToBuffer;\nvar bufferToHex = function (buf) { return (0, exports.ensureLeading0x)(buf.toString('hex')); };\nexports.bufferToHex = bufferToHex;\nexports.NULL_ADDRESS = '0x0000000000000000000000000000000000000000';\nvar findAddressIndex = function (address, addresses) {\n    return addresses.findIndex(function (x) { return (0, exports.eqAddress)(x, address); });\n};\nexports.findAddressIndex = findAddressIndex;\n// Returns an array of indices mapping the entries of oldAddress[] to newAddress[]\nvar mapAddressListOnto = function (oldAddress, newAddress) {\n    var oldAddressIndex = oldAddress.map(function (x, index) { return ({ address: (0, exports.normalizeAddress)(x), index: index }); });\n    var newAddressIndex = newAddress.map(function (x, index) { return ({ address: (0, exports.normalizeAddress)(x), index: index }); });\n    oldAddressIndex.sort(function (a, b) { return a.address.localeCompare(b.address); });\n    newAddressIndex.sort(function (a, b) { return a.address.localeCompare(b.address); });\n    var res = __spreadArray([], Array(oldAddress.length).fill(-1), true);\n    for (var i = 0, j = 0; i < oldAddress.length && j < newAddress.length;) {\n        var cmp = oldAddressIndex[i].address.localeCompare(newAddressIndex[j].address);\n        if (cmp < 0) {\n            i++;\n        }\n        else if (cmp > 0) {\n            j++;\n        }\n        else {\n            // Address is present in both lists\n            res[oldAddressIndex[i].index] = newAddressIndex[j].index;\n            i++;\n            j++;\n        }\n    }\n    return res;\n};\nexports.mapAddressListOnto = mapAddressListOnto;\n// Returns data[] reordered by mapAddressListOnto(), and initiaValue for any entry of\n// oldAddress[] not present in newAddress[].\nfunction mapAddressListDataOnto(data, oldAddress, newAddress, initialValue) {\n    var res = __spreadArray([], Array(oldAddress.length).fill(initialValue), true);\n    if (data.length === 0) {\n        return res;\n    }\n    var addressIndexMap = (0, exports.mapAddressListOnto)(oldAddress, newAddress);\n    for (var i = 0; i < addressIndexMap.length; i++) {\n        if (addressIndexMap[i] >= 0) {\n            res[addressIndexMap[i]] = data[i];\n        }\n    }\n    return res;\n}\nexports.mapAddressListDataOnto = mapAddressListDataOnto;\n//# sourceMappingURL=address.js.map"]},"metadata":{},"sourceType":"script"}