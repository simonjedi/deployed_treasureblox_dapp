{"ast":null,"code":"var _classCallCheck = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events');\n\nvar parse = require('../parse');\n\nvar dev = process.env.NODE_ENV === 'development';\nvar WebSocket;\n\nvar WebSocketConnection = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(WebSocketConnection, _EventEmitter);\n\n  var _super = _createSuper(WebSocketConnection);\n\n  function WebSocketConnection(_WebSocket, url, options) {\n    var _this;\n\n    _classCallCheck(this, WebSocketConnection);\n\n    _this = _super.call(this);\n    WebSocket = _WebSocket;\n    setTimeout(function () {\n      return _this.create(url, options);\n    }, 0);\n    return _this;\n  }\n\n  _createClass(WebSocketConnection, [{\n    key: \"create\",\n    value: function create(url, options) {\n      var _this2 = this;\n\n      if (!WebSocket) this.emit('error', new Error('No WebSocket transport available'));\n\n      try {\n        this.socket = new WebSocket(url);\n      } catch (e) {\n        return this.emit('error', e);\n      }\n\n      this.socket.addEventListener('error', function (err) {\n        return _this2.emit('error', err);\n      });\n      this.socket.addEventListener('open', function () {\n        _this2.emit('connect');\n\n        _this2.socket.addEventListener('message', function (message) {\n          var data = typeof message.data === 'string' ? message.data : '';\n          parse(data, function (err, payloads) {\n            if (err) return; //\n\n            payloads.forEach(function (load) {\n              if (Array.isArray(load)) {\n                load.forEach(function (payload) {\n                  return _this2.emit('payload', payload);\n                });\n              } else {\n                _this2.emit('payload', load);\n              }\n            });\n          });\n        });\n\n        _this2.socket.addEventListener('close', function () {\n          return _this2.onClose();\n        });\n      });\n    }\n  }, {\n    key: \"onClose\",\n    value: function onClose() {\n      this.socket = null;\n      this.closed = true;\n      if (dev) console.log('Closing WebSocket connection');\n      this.emit('close');\n      this.removeAllListeners();\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this.socket) {\n        this.socket.close();\n      } else {\n        this.onClose();\n      }\n    }\n  }, {\n    key: \"error\",\n    value: function error(payload, message) {\n      var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      this.emit('payload', {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        error: {\n          message: message,\n          code: code\n        }\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload) {\n      var _this3 = this;\n\n      if (this.socket && this.socket.readyState === this.socket.CONNECTING) {\n        setTimeout(function (_) {\n          return _this3.send(payload);\n        }, 10);\n      } else if (!this.socket || this.socket.readyState > 1) {\n        this.connected = false;\n        this.error(payload, 'Not connected');\n      } else {\n        this.socket.send(JSON.stringify(payload));\n      }\n    }\n  }]);\n\n  return WebSocketConnection;\n}(EventEmitter);\n\nmodule.exports = function (WebSocket) {\n  return function (url, cb) {\n    return new WebSocketConnection(WebSocket, url, cb);\n  };\n};","map":{"version":3,"sources":["/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/eth-provider/connections/ws.js"],"names":["EventEmitter","require","parse","dev","process","env","NODE_ENV","WebSocket","WebSocketConnection","_WebSocket","url","options","setTimeout","create","emit","Error","socket","e","addEventListener","err","message","data","payloads","forEach","load","Array","isArray","payload","onClose","closed","console","log","removeAllListeners","close","code","id","jsonrpc","error","readyState","CONNECTING","_","send","connected","JSON","stringify","module","exports","cb"],"mappings":"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","sourcesContent":["const EventEmitter = require('events')\nconst parse = require('../parse')\nconst dev = process.env.NODE_ENV === 'development'\n\nlet WebSocket\n\nclass WebSocketConnection extends EventEmitter {\n  constructor (_WebSocket, url, options) {\n    super()\n    WebSocket = _WebSocket\n    setTimeout(() => this.create(url, options), 0)\n  }\n\n  create (url, options) {\n    if (!WebSocket) this.emit('error', new Error('No WebSocket transport available'))\n    try { this.socket = new WebSocket(url) } catch (e) { return this.emit('error', e) }\n    this.socket.addEventListener('error', err => this.emit('error', err))\n    this.socket.addEventListener('open', () => {\n      this.emit('connect')\n      this.socket.addEventListener('message', message => {\n        const data = typeof message.data === 'string' ? message.data : ''\n        parse(data, (err, payloads) => {\n          if (err) return //\n          payloads.forEach(load => {\n            if (Array.isArray(load)) {\n              load.forEach(payload => this.emit('payload', payload))\n            } else {\n              this.emit('payload', load)\n            }\n          })\n        })\n      })\n      this.socket.addEventListener('close', () => this.onClose())\n    })\n  }\n\n  onClose () {\n    this.socket = null\n    this.closed = true\n    if (dev) console.log('Closing WebSocket connection')\n    this.emit('close')\n    this.removeAllListeners()\n  }\n\n  close () {\n    if (this.socket) {\n      this.socket.close()\n    } else {\n      this.onClose()\n    }\n  }\n\n  error (payload, message, code = -1) {\n    this.emit('payload', { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } })\n  }\n\n  send (payload) {\n    if (this.socket && this.socket.readyState === this.socket.CONNECTING) {\n      setTimeout(_ => this.send(payload), 10)\n    } else if (!this.socket || this.socket.readyState > 1) {\n      this.connected = false\n      this.error(payload, 'Not connected')\n    } else {\n      this.socket.send(JSON.stringify(payload))\n    }\n  }\n}\n\nmodule.exports = WebSocket => (url, cb) => new WebSocketConnection(WebSocket, url, cb)\n"]},"metadata":{},"sourceType":"script"}