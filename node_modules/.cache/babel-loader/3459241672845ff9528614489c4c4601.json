{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { IState } from \"@walletconnect/types\";\nimport { ERROR, formatMessageContext } from \"@walletconnect/utils\";\nimport { STATE_EVENTS } from \"../constants\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nexport class State extends IState {\n  constructor(client, logger, name) {\n    super(client, logger, name);\n    this.client = client;\n    this.logger = logger;\n    this.name = name;\n    this.sequences = new Map();\n    this.events = new EventEmitter();\n    this.cached = [];\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.initialize();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get length() {\n    return this.sequences.size;\n  }\n\n  get topics() {\n    return Array.from(this.sequences.keys());\n  }\n\n  get values() {\n    return Array.from(this.sequences.values());\n  }\n\n  async set(topic, sequence) {\n    await this.isInitialized();\n\n    if (this.sequences.has(topic)) {\n      this.update(topic, sequence);\n    } else {\n      this.logger.debug(`Setting sequence`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic,\n        sequence\n      });\n      this.sequences.set(topic, sequence);\n      this.events.emit(STATE_EVENTS.created, {\n        topic,\n        sequence\n      });\n    }\n  }\n\n  async get(topic) {\n    await this.isInitialized();\n    this.logger.debug(`Getting sequence`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      topic\n    });\n    const sequence = await this.getState(topic);\n    return sequence;\n  }\n\n  async update(topic, update) {\n    await this.isInitialized();\n    this.logger.debug(`Updating sequence`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"update\",\n      topic,\n      update\n    });\n    const sequence = Object.assign(Object.assign({}, await this.getState(topic)), update);\n    this.sequences.set(topic, sequence);\n    this.events.emit(STATE_EVENTS.updated, {\n      topic,\n      sequence,\n      update\n    });\n  }\n\n  async delete(topic, reason) {\n    await this.isInitialized();\n    if (!this.sequences.has(topic)) return;\n    this.logger.debug(`Deleting sequence`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"delete\",\n      topic,\n      reason\n    });\n    const sequence = await this.getState(topic);\n    this.sequences.delete(topic);\n    this.events.emit(STATE_EVENTS.deleted, {\n      topic,\n      sequence,\n      reason\n    });\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async getState(topic) {\n    await this.isInitialized();\n    const sequence = this.sequences.get(topic);\n\n    if (!sequence) {\n      const error = ERROR.NO_MATCHING_TOPIC.format({\n        context: formatMessageContext(this.context),\n        topic\n      });\n      this.logger.error(error.message);\n      throw new Error(error.message);\n    }\n\n    return sequence;\n  }\n\n  async persist() {\n    await this.client.storage.setSequenceState(this.context, this.values);\n    this.events.emit(STATE_EVENTS.sync);\n  }\n\n  async restore() {\n    try {\n      const persisted = await this.client.storage.getSequenceState(this.context);\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n\n      if (this.sequences.size) {\n        const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n          context: formatMessageContext(this.context)\n        });\n        this.logger.error(error.message);\n        throw new Error(error.message);\n      }\n\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored sequences for ${formatMessageContext(this.context)}`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        sequences: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore sequences for ${formatMessageContext(this.context)}`);\n      this.logger.error(e);\n    }\n  }\n\n  async initialize() {\n    await this.restore();\n    this.reset();\n    this.onInit();\n  }\n\n  reset() {\n    this.cached.forEach(sequence => this.sequences.set(sequence.topic, sequence));\n  }\n\n  onInit() {\n    this.cached = [];\n    this.events.emit(STATE_EVENTS.init);\n  }\n\n  async isInitialized() {\n    if (!this.cached.length) return;\n    return new Promise(resolve => {\n      this.events.once(STATE_EVENTS.init, () => resolve());\n    });\n  }\n\n  registerEventListeners() {\n    this.events.on(STATE_EVENTS.created, createdEvent => {\n      const eventName = STATE_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: createdEvent\n      });\n      this.persist();\n    });\n    this.events.on(STATE_EVENTS.updated, updatedEvent => {\n      const eventName = STATE_EVENTS.updated;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: updatedEvent\n      });\n      this.persist();\n    });\n    this.events.on(STATE_EVENTS.deleted, deletedEvent => {\n      const eventName = STATE_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: deletedEvent\n      });\n      this.persist();\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/state.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { IState } from \"@walletconnect/types\";\nimport { ERROR, formatMessageContext } from \"@walletconnect/utils\";\nimport { STATE_EVENTS } from \"../constants\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nexport class State extends IState {\n    constructor(client, logger, name) {\n        super(client, logger, name);\n        this.client = client;\n        this.logger = logger;\n        this.name = name;\n        this.sequences = new Map();\n        this.events = new EventEmitter();\n        this.cached = [];\n        this.logger = generateChildLogger(logger, this.name);\n        this.registerEventListeners();\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.initialize();\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    get length() {\n        return this.sequences.size;\n    }\n    get topics() {\n        return Array.from(this.sequences.keys());\n    }\n    get values() {\n        return Array.from(this.sequences.values());\n    }\n    async set(topic, sequence) {\n        await this.isInitialized();\n        if (this.sequences.has(topic)) {\n            this.update(topic, sequence);\n        }\n        else {\n            this.logger.debug(`Setting sequence`);\n            this.logger.trace({ type: \"method\", method: \"set\", topic, sequence });\n            this.sequences.set(topic, sequence);\n            this.events.emit(STATE_EVENTS.created, {\n                topic,\n                sequence,\n            });\n        }\n    }\n    async get(topic) {\n        await this.isInitialized();\n        this.logger.debug(`Getting sequence`);\n        this.logger.trace({ type: \"method\", method: \"get\", topic });\n        const sequence = await this.getState(topic);\n        return sequence;\n    }\n    async update(topic, update) {\n        await this.isInitialized();\n        this.logger.debug(`Updating sequence`);\n        this.logger.trace({ type: \"method\", method: \"update\", topic, update });\n        const sequence = Object.assign(Object.assign({}, (await this.getState(topic))), update);\n        this.sequences.set(topic, sequence);\n        this.events.emit(STATE_EVENTS.updated, {\n            topic,\n            sequence,\n            update,\n        });\n    }\n    async delete(topic, reason) {\n        await this.isInitialized();\n        if (!this.sequences.has(topic))\n            return;\n        this.logger.debug(`Deleting sequence`);\n        this.logger.trace({ type: \"method\", method: \"delete\", topic, reason });\n        const sequence = await this.getState(topic);\n        this.sequences.delete(topic);\n        this.events.emit(STATE_EVENTS.deleted, {\n            topic,\n            sequence,\n            reason,\n        });\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async getState(topic) {\n        await this.isInitialized();\n        const sequence = this.sequences.get(topic);\n        if (!sequence) {\n            const error = ERROR.NO_MATCHING_TOPIC.format({\n                context: formatMessageContext(this.context),\n                topic,\n            });\n            this.logger.error(error.message);\n            throw new Error(error.message);\n        }\n        return sequence;\n    }\n    async persist() {\n        await this.client.storage.setSequenceState(this.context, this.values);\n        this.events.emit(STATE_EVENTS.sync);\n    }\n    async restore() {\n        try {\n            const persisted = await this.client.storage.getSequenceState(this.context);\n            if (typeof persisted === \"undefined\")\n                return;\n            if (!persisted.length)\n                return;\n            if (this.sequences.size) {\n                const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n                    context: formatMessageContext(this.context),\n                });\n                this.logger.error(error.message);\n                throw new Error(error.message);\n            }\n            this.cached = persisted;\n            this.logger.debug(`Successfully Restored sequences for ${formatMessageContext(this.context)}`);\n            this.logger.trace({ type: \"method\", method: \"restore\", sequences: this.values });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Restore sequences for ${formatMessageContext(this.context)}`);\n            this.logger.error(e);\n        }\n    }\n    async initialize() {\n        await this.restore();\n        this.reset();\n        this.onInit();\n    }\n    reset() {\n        this.cached.forEach(sequence => this.sequences.set(sequence.topic, sequence));\n    }\n    onInit() {\n        this.cached = [];\n        this.events.emit(STATE_EVENTS.init);\n    }\n    async isInitialized() {\n        if (!this.cached.length)\n            return;\n        return new Promise(resolve => {\n            this.events.once(STATE_EVENTS.init, () => resolve());\n        });\n    }\n    registerEventListeners() {\n        this.events.on(STATE_EVENTS.created, (createdEvent) => {\n            const eventName = STATE_EVENTS.created;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n            this.persist();\n        });\n        this.events.on(STATE_EVENTS.updated, (updatedEvent) => {\n            const eventName = STATE_EVENTS.updated;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: updatedEvent });\n            this.persist();\n        });\n        this.events.on(STATE_EVENTS.deleted, (deletedEvent) => {\n            const eventName = STATE_EVENTS.deleted;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n            this.persist();\n        });\n    }\n}\n//# sourceMappingURL=state.js.map"]},"metadata":{},"sourceType":"module"}