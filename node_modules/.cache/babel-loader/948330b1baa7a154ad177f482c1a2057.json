{"ast":null,"code":"import * as x25519 from \"@stablelib/x25519\";\nimport { concatArrays } from \"@walletconnect/encoding\";\nimport { LENGTH_0, KEY_LENGTH, IV_LENGTH, MAC_LENGTH } from \"@walletconnect/crypto\";\nexport function derive(privateKey, publicKey) {\n  return x25519.sharedKey(privateKey, publicKey);\n}\nexport function generatePnrgFromEntropy(entropy) {\n  return {\n    isAvailable: true,\n    randomBytes: () => entropy\n  };\n}\nexport function generateKeyPair(entropy) {\n  const prng = typeof entropy !== \"undefined\" ? generatePnrgFromEntropy(entropy) : undefined;\n  const keyPair = x25519.generateKeyPair(prng);\n  return {\n    publicKey: keyPair.publicKey,\n    privateKey: keyPair.secretKey\n  };\n}\nexport function getSenderKeyPair(opts) {\n  const keyPair = (opts === null || opts === void 0 ? void 0 : opts.sender) || generateKeyPair();\n  return {\n    privateKey: keyPair.privateKey,\n    publicKey: keyPair.publicKey\n  };\n}\nexport function getSharedKey(privateKey, publicKey) {\n  return derive(privateKey, publicKey);\n}\nexport function getEncryptionKey(hash) {\n  return new Uint8Array(hash.slice(LENGTH_0, KEY_LENGTH));\n}\nexport function getMacKey(hash) {\n  return new Uint8Array(hash.slice(KEY_LENGTH));\n}\nexport function serialize(opts) {\n  return concatArrays(opts.iv, opts.publicKey, opts.mac, opts.ciphertext);\n}\nexport function deserialize(arr) {\n  const slice0 = LENGTH_0;\n  const slice1 = slice0 + IV_LENGTH;\n  const slice2 = slice1 + KEY_LENGTH;\n  const slice3 = slice2 + MAC_LENGTH;\n  const slice4 = arr.length;\n  return {\n    iv: arr.slice(slice0, slice1),\n    publicKey: arr.slice(slice1, slice2),\n    mac: arr.slice(slice2, slice3),\n    ciphertext: arr.slice(slice3, slice4)\n  };\n}","map":{"version":3,"sources":["../../../../src/ecies/shared/index.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,MAAZ,MAAwB,mBAAxB;AACA,SAAS,YAAT,QAA6B,yBAA7B;AACA,SAIE,QAJF,EAKE,UALF,EAME,SANF,EAOE,UAPF,QASO,uBATP;AAWA,OAAM,SAAU,MAAV,CACJ,UADI,EAEJ,SAFI,EAEiB;AAErB,SAAO,MAAM,CAAC,SAAP,CAAiB,UAAjB,EAA6B,SAA7B,CAAP;AACD;AAED,OAAM,SAAU,uBAAV,CAAkC,OAAlC,EAAqD;AACzD,SAAO;AACL,IAAA,WAAW,EAAE,IADR;AAEL,IAAA,WAAW,EAAE,MAAM;AAFd,GAAP;AAID;AAED,OAAM,SAAU,eAAV,CAA0B,OAA1B,EAA8C;AAClD,QAAM,IAAI,GACR,OAAO,OAAP,KAAmB,WAAnB,GACI,uBAAuB,CAAC,OAAD,CAD3B,GAEI,SAHN;AAIA,QAAM,OAAO,GAAG,MAAM,CAAC,eAAP,CAAuB,IAAvB,CAAhB;AACA,SAAO;AACL,IAAA,SAAS,EAAE,OAAO,CAAC,SADd;AAEL,IAAA,UAAU,EAAE,OAAO,CAAC;AAFf,GAAP;AAID;AAED,OAAM,SAAU,gBAAV,CAA2B,IAA3B,EAAsD;AAC1D,QAAM,OAAO,GAAG,CAAA,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,MAAN,KAAgB,eAAe,EAA/C;AACA,SAAO;AACL,IAAA,UAAU,EAAE,OAAO,CAAC,UADf;AAEL,IAAA,SAAS,EAAE,OAAO,CAAC;AAFd,GAAP;AAID;AAED,OAAM,SAAU,YAAV,CAAuB,UAAvB,EAA+C,SAA/C,EAAoE;AACxE,SAAO,MAAM,CAAC,UAAD,EAAa,SAAb,CAAb;AACD;AAED,OAAM,SAAU,gBAAV,CAA2B,IAA3B,EAA2C;AAC/C,SAAO,IAAI,UAAJ,CAAe,IAAI,CAAC,KAAL,CAAW,QAAX,EAAqB,UAArB,CAAf,CAAP;AACD;AAED,OAAM,SAAU,SAAV,CAAoB,IAApB,EAAoC;AACxC,SAAO,IAAI,UAAJ,CAAe,IAAI,CAAC,KAAL,CAAW,UAAX,CAAf,CAAP;AACD;AAED,OAAM,SAAU,SAAV,CAAoB,IAApB,EAAmC;AACvC,SAAO,YAAY,CAAC,IAAI,CAAC,EAAN,EAAU,IAAI,CAAC,SAAf,EAA0B,IAAI,CAAC,GAA/B,EAAoC,IAAI,CAAC,UAAzC,CAAnB;AACD;AAED,OAAM,SAAU,WAAV,CAAsB,GAAtB,EAAqC;AACzC,QAAM,MAAM,GAAG,QAAf;AACA,QAAM,MAAM,GAAG,MAAM,GAAG,SAAxB;AACA,QAAM,MAAM,GAAG,MAAM,GAAG,UAAxB;AACA,QAAM,MAAM,GAAG,MAAM,GAAG,UAAxB;AACA,QAAM,MAAM,GAAG,GAAG,CAAC,MAAnB;AACA,SAAO;AACL,IAAA,EAAE,EAAE,GAAG,CAAC,KAAJ,CAAU,MAAV,EAAkB,MAAlB,CADC;AAEL,IAAA,SAAS,EAAE,GAAG,CAAC,KAAJ,CAAU,MAAV,EAAkB,MAAlB,CAFN;AAGL,IAAA,GAAG,EAAE,GAAG,CAAC,KAAJ,CAAU,MAAV,EAAkB,MAAlB,CAHA;AAIL,IAAA,UAAU,EAAE,GAAG,CAAC,KAAJ,CAAU,MAAV,EAAkB,MAAlB;AAJP,GAAP;AAMD","sourceRoot":"","sourcesContent":["import * as x25519 from \"@stablelib/x25519\";\nimport { concatArrays } from \"@walletconnect/encoding\";\nimport { LENGTH_0, KEY_LENGTH, IV_LENGTH, MAC_LENGTH, } from \"@walletconnect/crypto\";\nexport function derive(privateKey, publicKey) {\n    return x25519.sharedKey(privateKey, publicKey);\n}\nexport function generatePnrgFromEntropy(entropy) {\n    return {\n        isAvailable: true,\n        randomBytes: () => entropy,\n    };\n}\nexport function generateKeyPair(entropy) {\n    const prng = typeof entropy !== \"undefined\"\n        ? generatePnrgFromEntropy(entropy)\n        : undefined;\n    const keyPair = x25519.generateKeyPair(prng);\n    return {\n        publicKey: keyPair.publicKey,\n        privateKey: keyPair.secretKey,\n    };\n}\nexport function getSenderKeyPair(opts) {\n    const keyPair = (opts === null || opts === void 0 ? void 0 : opts.sender) || generateKeyPair();\n    return {\n        privateKey: keyPair.privateKey,\n        publicKey: keyPair.publicKey,\n    };\n}\nexport function getSharedKey(privateKey, publicKey) {\n    return derive(privateKey, publicKey);\n}\nexport function getEncryptionKey(hash) {\n    return new Uint8Array(hash.slice(LENGTH_0, KEY_LENGTH));\n}\nexport function getMacKey(hash) {\n    return new Uint8Array(hash.slice(KEY_LENGTH));\n}\nexport function serialize(opts) {\n    return concatArrays(opts.iv, opts.publicKey, opts.mac, opts.ciphertext);\n}\nexport function deserialize(arr) {\n    const slice0 = LENGTH_0;\n    const slice1 = slice0 + IV_LENGTH;\n    const slice2 = slice1 + KEY_LENGTH;\n    const slice3 = slice2 + MAC_LENGTH;\n    const slice4 = arr.length;\n    return {\n        iv: arr.slice(slice0, slice1),\n        publicKey: arr.slice(slice1, slice2),\n        mac: arr.slice(slice2, slice3),\n        ciphertext: arr.slice(slice3, slice4),\n    };\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}