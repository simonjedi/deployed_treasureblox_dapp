{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __values = this && this.__values || function (o) {\n  var s = typeof Symbol === \"function\" && Symbol.iterator,\n      m = s && o[s],\n      i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === \"number\") return {\n    next: function () {\n      if (o && i >= o.length) o = void 0;\n      return {\n        value: o && o[i++],\n        done: !o\n      };\n    }\n  };\n  throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\n\nvar __read = this && this.__read || function (o, n) {\n  var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o),\n      r,\n      ar = [],\n      e;\n\n  try {\n    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  } catch (error) {\n    e = {\n      error: error\n    };\n  } finally {\n    try {\n      if (r && !r.done && (m = i[\"return\"])) m.call(i);\n    } finally {\n      if (e) throw e.error;\n    }\n  }\n\n  return ar;\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zeroValue = exports.structHash = exports.encodeData = exports.typeHash = exports.encodeType = exports.generateTypedDataHash = exports.noString = exports.noNumber = exports.noBool = exports.defined = exports.eip712OptionalType = exports.EIP712_BUILTIN_TYPES = exports.EIP712_DYNAMIC_TYPES = exports.EIP712_ATOMIC_TYPES = void 0;\n\nvar address_1 = require(\"@celo/base/lib/address\");\n\nvar bignumber_js_1 = require(\"bignumber.js\");\n\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\n\nvar web3_eth_abi_1 = __importDefault(require(\"web3-eth-abi\"));\n/** Array of all EIP-712 atomic type names. */\n\n\nexports.EIP712_ATOMIC_TYPES = ['bytes1', 'bytes32', 'uint8', 'uint256', 'int8', 'int256', 'bool', 'address'];\nexports.EIP712_DYNAMIC_TYPES = ['bytes', 'string'];\nexports.EIP712_BUILTIN_TYPES = exports.EIP712_ATOMIC_TYPES.concat(exports.EIP712_DYNAMIC_TYPES); // Regular expression used to identify and parse EIP-712 array type strings.\n\nvar EIP712_ARRAY_REGEXP = /^(?<memberType>[\\w<>\\[\\]_\\-]+)(\\[(?<fixedLength>\\d+)?\\])$/; // Regular experssion used to identity EIP-712 integer types (e.g. int256, uint256, uint8).\n\nvar EIP712_INT_REGEXP = /^u?int\\d*$/;\n/**\n * Utility to build EIP712Optional<T> types to insert in EIP-712 type arrays.\n * @param typeName EIP-712 string type name. Should be builtin or defined in the EIP712Types\n * structure into which this type will be merged.\n */\n\nvar eip712OptionalType = function (typeName) {\n  var _a;\n\n  return _a = {}, _a[\"Optional<\" + typeName + \">\"] = [{\n    name: 'defined',\n    type: 'bool'\n  }, {\n    name: 'value',\n    type: typeName\n  }], _a;\n};\n\nexports.eip712OptionalType = eip712OptionalType;\n/** Utility to construct an defined EIP712Optional value with inferred type. */\n\nvar defined = function (value) {\n  return {\n    defined: true,\n    value: value\n  };\n};\n\nexports.defined = defined;\n/** Undefined EIP712Optional type with value type boolean. */\n\nexports.noBool = {\n  defined: false,\n  value: false\n};\n/** Undefined EIP712Optional type with value type number. */\n\nexports.noNumber = {\n  defined: false,\n  value: 0\n};\n/** Undefined EIP712Optional type with value type string. */\n\nexports.noString = {\n  defined: false,\n  value: ''\n};\n/**\n * Generates the EIP712 Typed Data hash for signing\n * @param   typedData An object that conforms to the EIP712TypedData interface\n * @return  A Buffer containing the hash of the typed data.\n */\n\nfunction generateTypedDataHash(typedData) {\n  return (0, ethereumjs_util_1.keccak)(Buffer.concat([Buffer.from('1901', 'hex'), structHash('EIP712Domain', typedData.domain, typedData.types), structHash(typedData.primaryType, typedData.message, typedData.types)]));\n}\n\nexports.generateTypedDataHash = generateTypedDataHash;\n/**\n * Given the primary type, and dictionary of types, this function assembles a sorted list\n * representing the transitive dependency closure of the primary type. (Inclusive of the primary\n * type itself.)\n */\n\nfunction findDependencies(primaryType, types, found) {\n  var e_1, _a;\n\n  var _b;\n\n  if (found === void 0) {\n    found = [];\n  } // If we have aready found the dependencies of this type, or it is a builtin, return early.\n\n\n  if (found.includes(primaryType) || exports.EIP712_BUILTIN_TYPES.includes(primaryType)) {\n    return [];\n  } // If this is an array type, return the results for its member type.\n\n\n  if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n    var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n    var memberType = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.memberType;\n    return findDependencies(memberType, types, found);\n  } // If this is not a builtin and is not defined, we cannot correctly construct a type encoding.\n\n\n  if (types[primaryType] === undefined) {\n    throw new Error(\"Unrecognized type \" + primaryType + \" is not included in the EIP-712 type list\");\n  } // Execute a depth-first search to populate the (inclusive) dependencies list.\n  // By the first invarient of this function, the resulting list should not contain duplicates.\n\n\n  var dependencies = [primaryType];\n\n  try {\n    for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n      var field = _d.value;\n      dependencies.push.apply(dependencies, __spreadArray([], __read(findDependencies(field.type, types, found.concat(dependencies))), false));\n    }\n  } catch (e_1_1) {\n    e_1 = {\n      error: e_1_1\n    };\n  } finally {\n    try {\n      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n    } finally {\n      if (e_1) throw e_1.error;\n    }\n  }\n\n  return dependencies;\n}\n/**\n * Creates a string encoding of the primary type, including all dependencies.\n * E.g. \"Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)\"\n */\n\n\nfunction encodeType(primaryType, types) {\n  var e_2, _a;\n\n  var deps = findDependencies(primaryType, types);\n  deps = deps.filter(function (d) {\n    return d !== primaryType;\n  });\n  deps = [primaryType].concat(deps.sort());\n  var result = '';\n\n  try {\n    for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n      var dep = deps_1_1.value;\n      result += dep + \"(\" + types[dep].map(function (_a) {\n        var name = _a.name,\n            type = _a.type;\n        return type + \" \" + name;\n      }).join(',') + \")\";\n    }\n  } catch (e_2_1) {\n    e_2 = {\n      error: e_2_1\n    };\n  } finally {\n    try {\n      if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n    } finally {\n      if (e_2) throw e_2.error;\n    }\n  }\n\n  return result;\n}\n\nexports.encodeType = encodeType;\n\nfunction typeHash(primaryType, types) {\n  return (0, ethereumjs_util_1.keccak)(encodeType(primaryType, types));\n}\n\nexports.typeHash = typeHash;\n/** Encodes a single EIP-712 value to a 32-byte buffer */\n\nfunction encodeValue(valueType, value, types) {\n  var _a; // Encode the atomic types as their corresponding soldity ABI type.\n\n\n  if (exports.EIP712_ATOMIC_TYPES.includes(valueType)) {\n    // @ts-ignore TypeScript does not believe encodeParameter exists.\n    var hexEncoded = web3_eth_abi_1.default.encodeParameter(valueType, normalizeValue(valueType, value));\n    return Buffer.from((0, address_1.trimLeading0x)(hexEncoded), 'hex');\n  } // Encode `string` and `bytes` types as their keccak hash.\n\n\n  if (valueType === 'string') {\n    // Converting to Buffer before passing to `keccak` prevents an issue where the string is\n    // interpretted as a hex-encoded string when is starts with 0x.\n    // https://github.com/ethereumjs/ethereumjs-util/blob/7e3be1d97b4e11fbc4924836b8c444e644f643ac/index.js#L155-L183\n    return (0, ethereumjs_util_1.keccak)(Buffer.from(value, 'utf8'));\n  }\n\n  if (valueType === 'bytes') {\n    // Allow the user to use either utf8 (plain string) or hex encoding for their bytes.\n    // Note: keccak throws if the value cannot be converted into a Buffer,\n    return (0, ethereumjs_util_1.keccak)(value);\n  } // Encode structs as its hashStruct (e.g. keccak(typeHash || encodeData(struct)) ).\n\n\n  if (types[valueType] !== undefined) {\n    // tslint:disable-next-line:no-unnecessary-type-assertion.\n    return structHash(valueType, value, types);\n  } // Encode arrays as the hash of the concatenated encoding of the underlying types.\n\n\n  if (EIP712_ARRAY_REGEXP.test(valueType)) {\n    // Note: If a fixed length is provided in the type, it is not checked.\n    var match = EIP712_ARRAY_REGEXP.exec(valueType);\n    var memberType_1 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n    return (0, ethereumjs_util_1.keccak)(Buffer.concat(value.map(function (member) {\n      return encodeValue(memberType_1, member, types);\n    })));\n  }\n\n  throw new Error(\"Unrecognized or unsupported type in EIP-712 encoding: \" + valueType);\n}\n\nfunction normalizeValue(type, value) {\n  var normalizedValue = EIP712_INT_REGEXP.test(type) && bignumber_js_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n  return normalizedValue;\n}\n/**\n * Constructs the struct encoding of the data as the primary type.\n */\n\n\nfunction encodeData(primaryType, data, types) {\n  var fields = types[primaryType];\n\n  if (fields === undefined) {\n    throw new Error(\"Unrecognized primary type in EIP-712 encoding: \" + primaryType);\n  }\n\n  return Buffer.concat(fields.map(function (field) {\n    return encodeValue(field.type, data[field.name], types);\n  }));\n}\n\nexports.encodeData = encodeData;\n\nfunction structHash(primaryType, data, types) {\n  return (0, ethereumjs_util_1.keccak)(Buffer.concat([typeHash(primaryType, types), encodeData(primaryType, data, types)]));\n}\n\nexports.structHash = structHash;\n/**\n * Produce the zero value for a given type.\n *\n * @remarks\n * All atomic types will encode as the 32-byte zero value. Dynamic types as an empty hash.\n * Dynamic arrays will return an empty array. Fixed length arrays will have members set to zero.\n * Structs will have the values of all fields set to zero recursively.\n *\n * Note that EIP-712 does not specify zero values, and so this is non-standard.\n */\n\nfunction zeroValue(primaryType, types) {\n  var _a, _b;\n\n  if (types === void 0) {\n    types = {};\n  } // If the type is a built-in, return a pre-defined zero value.\n\n\n  if (['bytes', 'bytes1', 'bytes32'].includes(primaryType)) {\n    return Buffer.alloc(0);\n  }\n\n  if (['uint8', 'uint256', 'int8', 'int256'].includes(primaryType)) {\n    return 0;\n  }\n\n  if (primaryType === 'bool') {\n    return false;\n  }\n\n  if (primaryType === 'address') {\n    return address_1.NULL_ADDRESS;\n  }\n\n  if (primaryType === 'string') {\n    return '';\n  } // If the type is an array, return an empty array or an array of the given fixed length.\n\n\n  if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n    var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n    var memberType_2 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n    var fixedLengthStr = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.fixedLength;\n    var fixedLength = fixedLengthStr === undefined ? 0 : parseInt(fixedLengthStr, 10);\n    return __spreadArray([], __read(Array(fixedLength).keys()), false).map(function () {\n      return zeroValue(memberType_2, types);\n    });\n  } // Must be user-defined type. Return an object with all fields set to their zero value.\n\n\n  var fields = types[primaryType];\n\n  if (fields === undefined) {\n    throw new Error(\"Unrecognized primary type for EIP-712 zero value: \" + primaryType);\n  }\n\n  return fields.reduce(function (obj, field) {\n    var _a;\n\n    return __assign(__assign({}, obj), (_a = {}, _a[field.name] = zeroValue(field.type, types), _a));\n  }, {});\n}\n\nexports.zeroValue = zeroValue;","map":{"version":3,"sources":["../src/sign-typed-data-utils.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nvar __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __values = (this && this.__values) || function(o) {\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\n    if (m) return m.call(o);\n    if (o && typeof o.length === \"number\") return {\n        next: function () {\n            if (o && i >= o.length) o = void 0;\n            return { value: o && o[i++], done: !o };\n        }\n    };\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\n};\nvar __read = (this && this.__read) || function (o, n) {\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\n    if (!m) return o;\n    var i = m.call(o), r, ar = [], e;\n    try {\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n    }\n    catch (error) { e = { error: error }; }\n    finally {\n        try {\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\n        }\n        finally { if (e) throw e.error; }\n    }\n    return ar;\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.zeroValue = exports.structHash = exports.encodeData = exports.typeHash = exports.encodeType = exports.generateTypedDataHash = exports.noString = exports.noNumber = exports.noBool = exports.defined = exports.eip712OptionalType = exports.EIP712_BUILTIN_TYPES = exports.EIP712_DYNAMIC_TYPES = exports.EIP712_ATOMIC_TYPES = void 0;\nvar address_1 = require(\"@celo/base/lib/address\");\nvar bignumber_js_1 = require(\"bignumber.js\");\nvar ethereumjs_util_1 = require(\"ethereumjs-util\");\nvar web3_eth_abi_1 = __importDefault(require(\"web3-eth-abi\"));\n/** Array of all EIP-712 atomic type names. */\nexports.EIP712_ATOMIC_TYPES = [\n    'bytes1',\n    'bytes32',\n    'uint8',\n    'uint256',\n    'int8',\n    'int256',\n    'bool',\n    'address',\n];\nexports.EIP712_DYNAMIC_TYPES = ['bytes', 'string'];\nexports.EIP712_BUILTIN_TYPES = exports.EIP712_ATOMIC_TYPES.concat(exports.EIP712_DYNAMIC_TYPES);\n// Regular expression used to identify and parse EIP-712 array type strings.\nvar EIP712_ARRAY_REGEXP = /^(?<memberType>[\\w<>\\[\\]_\\-]+)(\\[(?<fixedLength>\\d+)?\\])$/;\n// Regular experssion used to identity EIP-712 integer types (e.g. int256, uint256, uint8).\nvar EIP712_INT_REGEXP = /^u?int\\d*$/;\n/**\n * Utility to build EIP712Optional<T> types to insert in EIP-712 type arrays.\n * @param typeName EIP-712 string type name. Should be builtin or defined in the EIP712Types\n * structure into which this type will be merged.\n */\nvar eip712OptionalType = function (typeName) {\n    var _a;\n    return (_a = {},\n        _a[\"Optional<\" + typeName + \">\"] = [\n            { name: 'defined', type: 'bool' },\n            { name: 'value', type: typeName },\n        ],\n        _a);\n};\nexports.eip712OptionalType = eip712OptionalType;\n/** Utility to construct an defined EIP712Optional value with inferred type. */\nvar defined = function (value) { return ({\n    defined: true,\n    value: value,\n}); };\nexports.defined = defined;\n/** Undefined EIP712Optional type with value type boolean. */\nexports.noBool = {\n    defined: false,\n    value: false,\n};\n/** Undefined EIP712Optional type with value type number. */\nexports.noNumber = {\n    defined: false,\n    value: 0,\n};\n/** Undefined EIP712Optional type with value type string. */\nexports.noString = {\n    defined: false,\n    value: '',\n};\n/**\n * Generates the EIP712 Typed Data hash for signing\n * @param   typedData An object that conforms to the EIP712TypedData interface\n * @return  A Buffer containing the hash of the typed data.\n */\nfunction generateTypedDataHash(typedData) {\n    return (0, ethereumjs_util_1.keccak)(Buffer.concat([\n        Buffer.from('1901', 'hex'),\n        structHash('EIP712Domain', typedData.domain, typedData.types),\n        structHash(typedData.primaryType, typedData.message, typedData.types),\n    ]));\n}\nexports.generateTypedDataHash = generateTypedDataHash;\n/**\n * Given the primary type, and dictionary of types, this function assembles a sorted list\n * representing the transitive dependency closure of the primary type. (Inclusive of the primary\n * type itself.)\n */\nfunction findDependencies(primaryType, types, found) {\n    var e_1, _a;\n    var _b;\n    if (found === void 0) { found = []; }\n    // If we have aready found the dependencies of this type, or it is a builtin, return early.\n    if (found.includes(primaryType) || exports.EIP712_BUILTIN_TYPES.includes(primaryType)) {\n        return [];\n    }\n    // If this is an array type, return the results for its member type.\n    if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n        var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n        var memberType = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.memberType;\n        return findDependencies(memberType, types, found);\n    }\n    // If this is not a builtin and is not defined, we cannot correctly construct a type encoding.\n    if (types[primaryType] === undefined) {\n        throw new Error(\"Unrecognized type \" + primaryType + \" is not included in the EIP-712 type list\");\n    }\n    // Execute a depth-first search to populate the (inclusive) dependencies list.\n    // By the first invarient of this function, the resulting list should not contain duplicates.\n    var dependencies = [primaryType];\n    try {\n        for (var _c = __values(types[primaryType]), _d = _c.next(); !_d.done; _d = _c.next()) {\n            var field = _d.value;\n            dependencies.push.apply(dependencies, __spreadArray([], __read(findDependencies(field.type, types, found.concat(dependencies))), false));\n        }\n    }\n    catch (e_1_1) { e_1 = { error: e_1_1 }; }\n    finally {\n        try {\n            if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        }\n        finally { if (e_1) throw e_1.error; }\n    }\n    return dependencies;\n}\n/**\n * Creates a string encoding of the primary type, including all dependencies.\n * E.g. \"Transaction(Person from,Person to,Asset tx)Asset(address token,uint256 amount)Person(address wallet,string name)\"\n */\nfunction encodeType(primaryType, types) {\n    var e_2, _a;\n    var deps = findDependencies(primaryType, types);\n    deps = deps.filter(function (d) { return d !== primaryType; });\n    deps = [primaryType].concat(deps.sort());\n    var result = '';\n    try {\n        for (var deps_1 = __values(deps), deps_1_1 = deps_1.next(); !deps_1_1.done; deps_1_1 = deps_1.next()) {\n            var dep = deps_1_1.value;\n            result += dep + \"(\" + types[dep].map(function (_a) {\n                var name = _a.name, type = _a.type;\n                return type + \" \" + name;\n            }).join(',') + \")\";\n        }\n    }\n    catch (e_2_1) { e_2 = { error: e_2_1 }; }\n    finally {\n        try {\n            if (deps_1_1 && !deps_1_1.done && (_a = deps_1.return)) _a.call(deps_1);\n        }\n        finally { if (e_2) throw e_2.error; }\n    }\n    return result;\n}\nexports.encodeType = encodeType;\nfunction typeHash(primaryType, types) {\n    return (0, ethereumjs_util_1.keccak)(encodeType(primaryType, types));\n}\nexports.typeHash = typeHash;\n/** Encodes a single EIP-712 value to a 32-byte buffer */\nfunction encodeValue(valueType, value, types) {\n    var _a;\n    // Encode the atomic types as their corresponding soldity ABI type.\n    if (exports.EIP712_ATOMIC_TYPES.includes(valueType)) {\n        // @ts-ignore TypeScript does not believe encodeParameter exists.\n        var hexEncoded = web3_eth_abi_1.default.encodeParameter(valueType, normalizeValue(valueType, value));\n        return Buffer.from((0, address_1.trimLeading0x)(hexEncoded), 'hex');\n    }\n    // Encode `string` and `bytes` types as their keccak hash.\n    if (valueType === 'string') {\n        // Converting to Buffer before passing to `keccak` prevents an issue where the string is\n        // interpretted as a hex-encoded string when is starts with 0x.\n        // https://github.com/ethereumjs/ethereumjs-util/blob/7e3be1d97b4e11fbc4924836b8c444e644f643ac/index.js#L155-L183\n        return (0, ethereumjs_util_1.keccak)(Buffer.from(value, 'utf8'));\n    }\n    if (valueType === 'bytes') {\n        // Allow the user to use either utf8 (plain string) or hex encoding for their bytes.\n        // Note: keccak throws if the value cannot be converted into a Buffer,\n        return (0, ethereumjs_util_1.keccak)(value);\n    }\n    // Encode structs as its hashStruct (e.g. keccak(typeHash || encodeData(struct)) ).\n    if (types[valueType] !== undefined) {\n        // tslint:disable-next-line:no-unnecessary-type-assertion.\n        return structHash(valueType, value, types);\n    }\n    // Encode arrays as the hash of the concatenated encoding of the underlying types.\n    if (EIP712_ARRAY_REGEXP.test(valueType)) {\n        // Note: If a fixed length is provided in the type, it is not checked.\n        var match = EIP712_ARRAY_REGEXP.exec(valueType);\n        var memberType_1 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n        return (0, ethereumjs_util_1.keccak)(Buffer.concat(value.map(function (member) { return encodeValue(memberType_1, member, types); })));\n    }\n    throw new Error(\"Unrecognized or unsupported type in EIP-712 encoding: \" + valueType);\n}\nfunction normalizeValue(type, value) {\n    var normalizedValue = EIP712_INT_REGEXP.test(type) && bignumber_js_1.BigNumber.isBigNumber(value) ? value.toString() : value;\n    return normalizedValue;\n}\n/**\n * Constructs the struct encoding of the data as the primary type.\n */\nfunction encodeData(primaryType, data, types) {\n    var fields = types[primaryType];\n    if (fields === undefined) {\n        throw new Error(\"Unrecognized primary type in EIP-712 encoding: \" + primaryType);\n    }\n    return Buffer.concat(fields.map(function (field) { return encodeValue(field.type, data[field.name], types); }));\n}\nexports.encodeData = encodeData;\nfunction structHash(primaryType, data, types) {\n    return (0, ethereumjs_util_1.keccak)(Buffer.concat([typeHash(primaryType, types), encodeData(primaryType, data, types)]));\n}\nexports.structHash = structHash;\n/**\n * Produce the zero value for a given type.\n *\n * @remarks\n * All atomic types will encode as the 32-byte zero value. Dynamic types as an empty hash.\n * Dynamic arrays will return an empty array. Fixed length arrays will have members set to zero.\n * Structs will have the values of all fields set to zero recursively.\n *\n * Note that EIP-712 does not specify zero values, and so this is non-standard.\n */\nfunction zeroValue(primaryType, types) {\n    var _a, _b;\n    if (types === void 0) { types = {}; }\n    // If the type is a built-in, return a pre-defined zero value.\n    if (['bytes', 'bytes1', 'bytes32'].includes(primaryType)) {\n        return Buffer.alloc(0);\n    }\n    if (['uint8', 'uint256', 'int8', 'int256'].includes(primaryType)) {\n        return 0;\n    }\n    if (primaryType === 'bool') {\n        return false;\n    }\n    if (primaryType === 'address') {\n        return address_1.NULL_ADDRESS;\n    }\n    if (primaryType === 'string') {\n        return '';\n    }\n    // If the type is an array, return an empty array or an array of the given fixed length.\n    if (EIP712_ARRAY_REGEXP.test(primaryType)) {\n        var match = EIP712_ARRAY_REGEXP.exec(primaryType);\n        var memberType_2 = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.memberType;\n        var fixedLengthStr = (_b = match === null || match === void 0 ? void 0 : match.groups) === null || _b === void 0 ? void 0 : _b.fixedLength;\n        var fixedLength = fixedLengthStr === undefined ? 0 : parseInt(fixedLengthStr, 10);\n        return __spreadArray([], __read(Array(fixedLength).keys()), false).map(function () { return zeroValue(memberType_2, types); });\n    }\n    // Must be user-defined type. Return an object with all fields set to their zero value.\n    var fields = types[primaryType];\n    if (fields === undefined) {\n        throw new Error(\"Unrecognized primary type for EIP-712 zero value: \" + primaryType);\n    }\n    return fields.reduce(function (obj, field) {\n        var _a;\n        return (__assign(__assign({}, obj), (_a = {}, _a[field.name] = zeroValue(field.type, types), _a)));\n    }, {});\n}\nexports.zeroValue = zeroValue;\n//# sourceMappingURL=sign-typed-data-utils.js.map"]},"metadata":{},"sourceType":"script"}