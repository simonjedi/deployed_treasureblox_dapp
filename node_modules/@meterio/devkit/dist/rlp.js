"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bignumber_js_1 = require("bignumber.js");
const rlp = require("rlp");
class RLP {
    constructor(profile) {
        this.profile = profile;
    }
    /**
     * encode data according to profile
     * @param data the structured data to be encoded
     */
    encode(data) {
        const packed = pack(data, this.profile, '');
        return rlp.encode(packed);
    }
    /**
     * decode buffer according to profile
     * @param buf rlp encoded data
     */
    decode(buf) {
        const packed = rlp.decode(buf);
        return unpack(packed, this.profile, '');
    }
}
exports.RLP = RLP;
(function (RLP) {
    /** base class of scalar kind */
    class ScalarKind {
    }
    RLP.ScalarKind = ScalarKind;
    /** a buffer kind to keep buffer type */
    class BufferKind extends ScalarKind {
        data(data, ctx) {
            assert(Buffer.isBuffer(data), ctx, 'expected buffer');
            return {
                encode() {
                    return data;
                },
            };
        }
        buffer(buf, ctx) {
            return {
                decode() {
                    return buf;
                },
            };
        }
    }
    RLP.BufferKind = BufferKind;
    /** a scalar kind to presents number */
    class NumericKind extends ScalarKind {
        /**
         * create a numeric kind
         * @param maxBytes up limit of data in bytes
         */
        constructor(maxBytes) {
            super();
            this.maxBytes = maxBytes;
        }
        data(data, ctx) {
            assert(typeof data === 'string' || typeof data === 'number', ctx, 'expected string or number');
            if (typeof data === 'string') {
                const isHex = isHexString(data);
                const isDec = isDecString(data);
                assert(isHex || isDec, ctx, 'expected non-negative integer in hex or dec string');
                if (isHex) {
                    assert(data.length > 2, ctx, 'expected valid hex string');
                }
            }
            else {
                assert(Number.isSafeInteger(data) && data >= 0, ctx, 'expected non-negative safe integer');
            }
            const bn = new bignumber_js_1.default(data);
            if (bn.isZero()) {
                return {
                    encode() {
                        return Buffer.alloc(0);
                    },
                };
            }
            let hex = bn.toString(16);
            if (hex.length % 2 !== 0) {
                hex = `0${hex}`;
            }
            assert(this.maxBytes ? hex.length <= this.maxBytes * 2 : true, ctx, `expected number in ${this.maxBytes} bytes`);
            return {
                encode() {
                    return Buffer.from(hex, 'hex');
                },
            };
        }
        buffer(buf, ctx) {
            assert(this.maxBytes ? buf.length <= this.maxBytes : true, ctx, `expected less than ${this.maxBytes} bytes`);
            assert(buf.length === 0 || buf[0] !== 0, ctx, `expected canonical integer (no leading zero bytes)`);
            return {
                decode() {
                    if (buf.length === 0) {
                        return 0;
                    }
                    const bn = new bignumber_js_1.default(buf.toString('hex'), 16);
                    const num = bn.toNumber();
                    return Number.isSafeInteger(num) ? num : `0x${bn.toString(16)}`;
                },
            };
        }
    }
    RLP.NumericKind = NumericKind;
    /** a scalar kind to present blob */
    class BlobKind extends ScalarKind {
        data(data, ctx) {
            assert(isHexString(data), ctx, 'expected hex string');
            assert(data.length % 2 === 0, ctx, 'expected even length hex');
            return {
                encode() {
                    return Buffer.from(data.slice(2), 'hex');
                },
            };
        }
        buffer(buf, ctx) {
            return {
                decode() {
                    return `0x${buf.toString('hex')}`;
                },
            };
        }
    }
    RLP.BlobKind = BlobKind;
    /** fixed length blob */
    class FixedBlobKind extends BlobKind {
        constructor(bytes) {
            super();
            this.bytes = bytes;
        }
        data(data, ctx) {
            const encoder = super.data(data, ctx);
            assert(data.length === this.bytes * 2 + 2, ctx, `expected hex string presents ${this.bytes} bytes`);
            return encoder;
        }
        buffer(buf, ctx) {
            const decoder = super.buffer(buf, ctx);
            assert(buf.length === this.bytes, ctx, `expected ${this.bytes} bytes`);
            return decoder;
        }
    }
    RLP.FixedBlobKind = FixedBlobKind;
    /** fixed length blob allowing null */
    class NullableFixedBlobKind extends FixedBlobKind {
        data(data, ctx) {
            if (!data) {
                return {
                    encode() {
                        return Buffer.alloc(0);
                    },
                };
            }
            return super.data(data, ctx);
        }
        buffer(buf, ctx) {
            if (buf.length === 0) {
                return {
                    decode() {
                        return null;
                    },
                };
            }
            return super.buffer(buf, ctx);
        }
    }
    RLP.NullableFixedBlobKind = NullableFixedBlobKind;
    /** fixed length blob kind that will remove leading zero on encoding and pad zero on decoding */
    class CompactFixedBlobKind extends FixedBlobKind {
        data(data, ctx) {
            const buf = super.data(data, ctx).encode();
            return {
                encode() {
                    const nzIndex = buf.findIndex((v) => v !== 0);
                    if (nzIndex >= 0) {
                        return buf.slice(nzIndex);
                    }
                    return Buffer.alloc(0);
                },
            };
        }
        buffer(buf, ctx) {
            assert(buf.length <= this.bytes, ctx, `expected less than ${this.bytes} bytes`);
            assert(buf.length === 0 || buf[0] !== 0, ctx, `expected no leading zero bytes`);
            const { bytes } = this;
            return {
                decode() {
                    const zeros = '0'.repeat((bytes - buf.length) * 2);
                    return `0x${zeros}${buf.toString('hex')}`;
                },
            };
        }
    }
    RLP.CompactFixedBlobKind = CompactFixedBlobKind;
})(RLP = exports.RLP || (exports.RLP = {}));
function pack(obj, profile, ctx) {
    ctx = ctx ? `${ctx}.${profile.name}` : profile.name;
    const { kind } = profile;
    if (kind instanceof RLP.ScalarKind) {
        return kind.data(obj, ctx).encode();
    }
    if (Array.isArray(kind)) {
        return kind.map((k) => pack(obj[k.name], k, ctx));
    }
    assert(Array.isArray(obj), ctx, 'expected array');
    const { item } = kind;
    return obj.map((part, i) => pack(part, { name: `#${i}`, kind: item }, ctx));
}
function unpack(packed, profile, ctx) {
    ctx = ctx ? `${ctx}.${profile.name}` : profile.name;
    const { kind } = profile;
    if (kind instanceof RLP.ScalarKind) {
        assert(Buffer.isBuffer(packed), ctx, 'expected Buffer');
        return kind.buffer(packed, ctx).decode();
    }
    if (Array.isArray(kind)) {
        assert(Array.isArray(packed), ctx, 'expected array');
        const parts = packed;
        assert(parts.length === kind.length, ctx, `expected ${kind.length} items, but got ${parts.length}`);
        return kind.reduce((o, p, i) => {
            o[p.name] = unpack(parts[i], p, ctx);
            return o;
        }, {});
    }
    assert(Array.isArray(packed), ctx, 'expected array');
    const { item } = kind;
    return packed.map((part, i) => unpack(part, { name: `#${i}`, kind: item }, ctx));
}
function assert(cond, ctx, msg) {
    if (!cond) {
        throw new RLPError(`${ctx}: ${msg}`);
    }
}
function isHexString(str) {
    return /^0x[0-9a-f]*$/i.test(str);
}
function isDecString(str) {
    return /^[0-9]+$/.test(str);
}
class RLPError extends Error {
    constructor(msg) {
        super(msg);
        this.name = RLPError.name;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmxwLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3JscC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtDQUFxQztBQUNyQywyQkFBMkI7QUFFM0IsTUFBYSxHQUFHO0lBQ2QsWUFBcUIsT0FBb0I7UUFBcEIsWUFBTyxHQUFQLE9BQU8sQ0FBYTtJQUFHLENBQUM7SUFFN0M7OztPQUdHO0lBQ0ksTUFBTSxDQUFDLElBQVM7UUFDckIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzVDLE9BQVEsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQW1CLENBQUM7SUFDL0MsQ0FBQztJQUVEOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxHQUFXO1FBQ3ZCLE1BQU0sTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLENBQUMsR0FBVSxDQUFDLENBQUM7UUFDdEMsT0FBTyxNQUFNLENBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsRUFBRSxDQUFDLENBQUM7SUFDMUMsQ0FBQztDQUNGO0FBcEJELGtCQW9CQztBQUVELFdBQWlCLEdBQUc7SUFDbEIsZ0NBQWdDO0lBQ2hDLE1BQXNCLFVBQVU7S0FJL0I7SUFKcUIsY0FBVSxhQUkvQixDQUFBO0lBRUQsd0NBQXdDO0lBQ3hDLE1BQWEsVUFBVyxTQUFRLFVBQVU7UUFDakMsSUFBSSxDQUFDLElBQVksRUFBRSxHQUFXO1lBQ25DLE1BQU0sQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxFQUFFLEdBQUcsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO1lBQ3RELE9BQU87Z0JBQ0wsTUFBTTtvQkFDSixPQUFPLElBQUksQ0FBQztnQkFDZCxDQUFDO2FBQ0YsQ0FBQztRQUNKLENBQUM7UUFFTSxNQUFNLENBQUMsR0FBVyxFQUFFLEdBQVc7WUFDcEMsT0FBTztnQkFDTCxNQUFNO29CQUNKLE9BQU8s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