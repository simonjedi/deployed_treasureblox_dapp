import { EventEmitter } from "events";
import { generateChildLogger, getLoggerContext } from "@walletconnect/logger";
import { IRelayer, } from "@walletconnect/types";
import { RELAY_JSONRPC } from "@walletconnect/relay-api";
import { ERROR, formatRelayRpcUrl, formatMessageContext } from "@walletconnect/utils";
import { isJsonRpcRequest, formatJsonRpcResult, } from "@walletconnect/jsonrpc-utils";
import { JsonRpcProvider } from "@walletconnect/jsonrpc-provider";
import { WsConnection } from "@walletconnect/jsonrpc-ws-connection";
import { Subscription } from "./subscription";
import { RELAYER_CONTEXT, RELAYER_DEFAULT_PROTOCOL, RELAYER_DEFAULT_RPC_URL, RELAYER_DEFAULT_PUBLISH_TTL, RELAYER_EVENTS, RELAYER_PROVIDER_EVENTS, RELAYER_SUBSCRIPTION_SUFFIX, RELAYER_RECONNECT_TIMEOUT, SUBSCRIPTION_EVENTS, } from "../constants";
import { JsonRpcHistory } from "./history";
export class Relayer extends IRelayer {
    constructor(client, logger, provider) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new EventEmitter();
        this.name = RELAYER_CONTEXT;
        this.logger = generateChildLogger(logger, this.name);
        this.subscriptions = new Subscription(client, this.logger);
        this.history = new JsonRpcHistory(client, this.logger);
        this.provider = this.setProvider(provider);
        this.registerEventListeners();
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    get connected() {
        return this.provider.connection.connected;
    }
    get connecting() {
        return this.provider.connection.connecting;
    }
    async init() {
        this.logger.trace(`Initialized`);
        await this.history.init();
        await this.provider.connect();
        await this.subscriptions.init();
        await this.resubscribe();
    }
    async publish(topic, payload, opts) {
        this.logger.debug(`Publishing Payload`);
        this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
        try {
            const message = await this.client.crypto.encodeJsonRpc(topic, payload);
            const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || RELAYER_DEFAULT_PUBLISH_TTL;
            const relay = this.getRelayProtocol(opts);
            await this.rpcPublish(topic, message, ttl, relay);
            this.logger.debug(`Successfully Published Payload`);
            this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
            await this.recordPayloadEvent({ topic, payload });
        }
        catch (e) {
            this.logger.debug(`Failed to Publish Payload`);
            this.logger.error(e);
            throw e;
        }
    }
    async subscribe(topic, expiry, opts) {
        this.logger.debug(`Subscribing Topic`);
        this.logger.trace({ type: "method", method: "subscribe", params: { topic, expiry, opts } });
        try {
            const relay = this.getRelayProtocol(opts);
            const id = await this.rpcSubscribe(topic, relay);
            const subscription = { id, topic, expiry, relay };
            await this.subscriptions.set(id, subscription);
            this.logger.debug(`Successfully Subscribed Topic`);
            this.logger.trace({ type: "method", method: "subscribe", params: { topic, expiry, opts } });
            return id;
        }
        catch (e) {
            this.logger.debug(`Failed to Subscribe Topic`);
            this.logger.error(e);
            throw e;
        }
    }
    async unsubscribe(topic, id, opts) {
        this.logger.debug(`Unsubscribing Topic`);
        this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
        try {
            const relay = this.getRelayProtocol(opts);
            await this.rpcUnsubscribe(topic, id, relay);
            const reason = ERROR.DELETED.format({ context: formatMessageContext(this.context) });
            await this.onUnsubscribe(topic, id, reason);
            this.logger.debug(`Successfully Unsubscribed Topic`);
            this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
        }
        catch (e) {
            this.logger.debug(`Failed to Unsubscribe Topic`);
            this.logger.error(e);
            throw e;
        }
    }
    async unsubscribeByTopic(topic, opts) {
        const ids = this.subscriptions.topicMap.get(topic);
        await Promise.all(ids.map(async (id) => await this.unsubscribe(topic, id, opts)));
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    getRelayProtocol(opts) {
        return (opts === null || opts === void 0 ? void 0 : opts.relay) || { protocol: RELAYER_DEFAULT_PROTOCOL };
    }
    async rpcPublish(topic, message, ttl, relay) {
        const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);
        const request = {
            method: jsonRpc.publish,
            params: {
                topic,
                message,
                ttl,
            },
        };
        this.logger.debug(`Outgoing Relay Payload`);
        this.logger.trace({ type: "payload", direction: "outgoing", request });
        return this.provider.request(request);
    }
    async rpcSubscribe(topic, relay) {
        const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);
        const request = {
            method: jsonRpc.subscribe,
            params: {
                topic,
            },
        };
        this.logger.debug(`Outgoing Relay Payload`);
        this.logger.trace({ type: "payload", direction: "outgoing", request });
        return this.provider.request(request);
    }
    async rpcUnsubscribe(topic, id, relay) {
        const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);
        const request = {
            method: jsonRpc.unsubscribe,
            params: {
                topic,
                id,
            },
        };
        this.logger.debug(`Outgoing Relay Payload`);
        this.logger.trace({ type: "payload", direction: "outgoing", request });
        return this.provider.request(request);
    }
    async onUnsubscribe(topic, id, reason) {
        this.events.removeAllListeners(id);
        if (await this.subscriptions.exists(id, topic)) {
            await this.subscriptions.delete(id, reason);
        }
        await this.history.delete(topic);
    }
    async recordPayloadEvent(payloadEvent) {
        const { topic, payload } = payloadEvent;
        if (isJsonRpcRequest(payload)) {
            await this.history.set(topic, payload);
        }
        else {
            await this.history.resolve(payload);
        }
    }
    async shouldIgnorePayloadEvent(payloadEvent) {
        const { topic, payload } = payloadEvent;
        if (!this.subscriptions.topics.includes(topic))
            return true;
        let exists = false;
        try {
            if (isJsonRpcRequest(payload)) {
                exists = await this.history.exists(topic, payload.id);
            }
            else {
                let record;
                try {
                    record = await this.history.get(topic, payload.id);
                }
                catch (e) {
                }
                exists = typeof record !== "undefined" && typeof record.response !== "undefined";
            }
        }
        catch (e) {
        }
        return exists;
    }
    async onPayload(payload) {
        this.logger.debug(`Incoming Relay Payload`);
        this.logger.trace({ type: "payload", direction: "incoming", payload });
        if (isJsonRpcRequest(payload)) {
            if (!payload.method.endsWith(RELAYER_SUBSCRIPTION_SUFFIX))
                return;
            const event = payload.params;
            const { topic, message } = event.data;
            const payloadEvent = {
                topic,
                payload: await this.client.crypto.decodeJsonRpc(topic, message),
            };
            if (await this.shouldIgnorePayloadEvent(payloadEvent))
                return;
            this.logger.debug(`Emitting Relayer Payload`);
            this.logger.trace(Object.assign({ type: "event", event: event.id }, payloadEvent));
            this.events.emit(event.id, payloadEvent);
            this.events.emit(RELAYER_EVENTS.payload, payloadEvent);
            await this.acknowledgePayload(payload);
            await this.recordPayloadEvent(payloadEvent);
        }
    }
    async acknowledgePayload(payload) {
        const response = formatJsonRpcResult(payload.id, true);
        await this.provider.connection.send(response);
    }
    async resubscribe() {
        await Promise.all(this.subscriptions.values.map(async (subscription) => {
            const id = await this.rpcSubscribe(subscription.topic, subscription.relay);
            await this.subscriptions.set(id, Object.assign(Object.assign({}, subscription), { id }));
            const reason = ERROR.RESUBSCRIBED.format({ topic: subscription.topic });
            await this.subscriptions.delete(subscription.id, reason);
        }));
    }
    async onConnect() {
        await this.subscriptions.enable();
        await this.resubscribe();
    }
    async onDisconnect() {
        await this.subscriptions.disable();
        setTimeout(() => {
            this.provider.connect();
        }, RELAYER_RECONNECT_TIMEOUT);
    }
    setProvider(provider) {
        this.logger.debug(`Setting Relay Provider`);
        this.logger.trace({ type: "method", method: "setProvider", provider: provider === null || provider === void 0 ? void 0 : provider.toString() });
        const rpcUrl = formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === "string" ? provider : RELAYER_DEFAULT_RPC_URL, this.client.apiKey);
        return typeof provider !== "string" && typeof provider !== "undefined"
            ? provider
            : new JsonRpcProvider(new WsConnection(rpcUrl));
    }
    registerEventListeners() {
        this.provider.on(RELAYER_PROVIDER_EVENTS.payload, (payload) => this.onPayload(payload));
        this.provider.on(RELAYER_PROVIDER_EVENTS.connect, async () => {
            await this.onConnect();
            this.events.emit(RELAYER_EVENTS.connect);
        });
        this.provider.on(RELAYER_PROVIDER_EVENTS.disconnect, async () => {
            await this.onDisconnect();
            this.events.emit(RELAYER_EVENTS.disconnect);
        });
        this.provider.on(RELAYER_PROVIDER_EVENTS.error, e => this.events.emit(RELAYER_EVENTS.error, e));
        this.subscriptions.on(SUBSCRIPTION_EVENTS.expired, async (expiredEvent) => {
            const { topic, id, relay } = expiredEvent;
            await this.rpcUnsubscribe(topic, id, relay);
            await this.onUnsubscribe(topic, id, expiredEvent.reason);
        });
    }
}
function getRelayProtocolJsonRpc(protocol) {
    const jsonrpc = RELAY_JSONRPC[protocol];
    if (typeof jsonrpc === "undefined") {
        throw new Error(`Relay Protocol not supported: ${protocol}`);
    }
    return jsonrpc;
}
//# sourceMappingURL=relayer.js.map