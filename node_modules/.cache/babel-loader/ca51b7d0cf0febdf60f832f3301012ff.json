{"ast":null,"code":"/**\n * ECIES encrypt/decrypt with Ethereum keys\n * A Typescript implementation of geth/crypto/ecies/ecies.go\n * Modified from https://github.com/LimelabsTech/eth-ecies/blob/master/index.js\n * At commit c858cbd021e9a99d8afa629de33c8c30d923b3e5.\n */\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ECIES = exports.Decrypt = exports.Encrypt = exports.AES128DecryptAndHMAC = exports.AES128Decrypt = exports.AES128EncryptAndHMAC = exports.AES128Encrypt = exports.IV_LENGTH = void 0;\n\nvar crypto_1 = require(\"crypto\");\n\nvar elliptic_1 = require(\"elliptic\");\n\nvar ec = new elliptic_1.ec('secp256k1');\nexports.IV_LENGTH = 16;\n/**\n * Increments big endian uint32\n *\n * @param {Buffer} ctr 32 bit unsigned big endian integer to increment.\n * @returns Incremented counter.\n */\n\nvar IncCounter = function (ctr) {\n  for (var i = ctr.length - 1; i >= 0; i--) {\n    ctr[i]++;\n\n    if (ctr[i] !== 0) {\n      return ctr;\n    }\n  }\n\n  return ctr;\n};\n/**\n * NIST 8000-56C Rev 1 One Step KDF with the following parameters:\n * - H(x) is SHA-256(x)\n * - Fixed info is null\n *\n * TODO:\n * - Implement proper ceiling on reps.\n *\n * @param {Buffer} px Input keying material to derive key from.\n * @param {number} kdLen Length of output in bytes\n * @returns {Buffer} Output keying material of length kdLen bytes.\n */\n\n\nvar ConcatKDF = function (px, kdLen) {\n  var blockSize = 32;\n  var reps = (kdLen + 7) * 8 / (blockSize * 8);\n  var counter = Buffer.from('00000001', 'hex');\n  var k = Buffer.from('00', 'hex');\n\n  for (var i = 0; i <= reps; i++) {\n    var hash = (0, crypto_1.createHash)('sha256');\n    hash.update(counter);\n    hash.update(px);\n    k = Buffer.concat([k, hash.digest()]);\n    counter = IncCounter(counter);\n  }\n\n  return k.slice(1, kdLen + 1);\n};\n/**\n * AES-128 CTR encrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\n\n\nfunction AES128Encrypt(encryptionKey, iv, plaintext) {\n  var cipher = (0, crypto_1.createCipheriv)('aes-128-ctr', encryptionKey, iv);\n  var firstChunk = cipher.update(plaintext);\n  var secondChunk = cipher.final();\n  return Buffer.concat([iv, firstChunk, secondChunk]);\n}\n\nexports.AES128Encrypt = AES128Encrypt;\n/**\n * AES-128 CTR encrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\n\nfunction AES128EncryptAndHMAC(encryptionKey, macKey, plaintext) {\n  var iv = (0, crypto_1.randomBytes)(exports.IV_LENGTH);\n  var dataToMac = AES128Encrypt(encryptionKey, iv, plaintext);\n  var mac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n  return Buffer.concat([dataToMac, mac]);\n}\n\nexports.AES128EncryptAndHMAC = AES128EncryptAndHMAC;\n/**\n * AES-128 CTR decrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\n\nfunction AES128Decrypt(encryptionKey, iv, ciphertext) {\n  var cipher = (0, crypto_1.createDecipheriv)('aes-128-ctr', encryptionKey, iv);\n  var firstChunk = cipher.update(ciphertext);\n  var secondChunk = cipher.final();\n  return Buffer.concat([firstChunk, secondChunk]);\n}\n\nexports.AES128Decrypt = AES128Decrypt;\n/**\n * AES-128 CTR decrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\n\nfunction AES128DecryptAndHMAC(encryptionKey, macKey, ciphertext) {\n  var iv = ciphertext.slice(0, exports.IV_LENGTH);\n  var message = ciphertext.slice(exports.IV_LENGTH, ciphertext.length - 32);\n  var mac = ciphertext.slice(ciphertext.length - 32, ciphertext.length);\n  var dataToMac = Buffer.concat([iv, message]);\n  var computedMac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n\n  if (!mac.equals(computedMac)) {\n    throw new Error('MAC mismatch');\n  }\n\n  return AES128Decrypt(encryptionKey, iv, message);\n}\n\nexports.AES128DecryptAndHMAC = AES128DecryptAndHMAC;\n/**\n * ECIES encrypt\n * @param {Buffer} pubKeyTo Ethereum pub key, 64 bytes.\n * @param {Buffer} plaintext Plaintext to be encrypted.\n * @returns {Buffer} Encrypted message, serialized, 113+ bytes\n */\n\nfunction Encrypt(pubKeyTo, plaintext) {\n  var ephemPrivKey = ec.keyFromPrivate((0, crypto_1.randomBytes)(32));\n  var ephemPubKey = ephemPrivKey.getPublic(false, 'hex');\n  var ephemPubKeyEncoded = Buffer.from(ephemPubKey, 'hex');\n  var px = ephemPrivKey.derive(ec.keyFromPublic(Buffer.concat([Buffer.from([0x04]), pubKeyTo])).getPublic());\n  var hash = ConcatKDF(px.toArrayLike(Buffer), 32);\n  var encryptionKey = hash.slice(0, 16);\n  var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n  var message = AES128EncryptAndHMAC(encryptionKey, macKey, plaintext);\n  var serializedCiphertext = Buffer.concat([ephemPubKeyEncoded, message // iv + ciphertext + mac (min 48 bytes)\n  ]);\n  return serializedCiphertext;\n}\n\nexports.Encrypt = Encrypt;\n/**\n * ECIES decrypt\n * @param {Buffer} privKey Ethereum private key, 32 bytes.\n * @param {Buffer} encrypted Encrypted message, serialized, 113+ bytes\n * @returns {Buffer} plaintext\n */\n\nfunction Decrypt(privKey, encrypted) {\n  // Read iv, ephemPubKey, mac, ciphertext from encrypted message\n  var ephemPubKeyEncoded = encrypted.slice(0, 65);\n  var symmetricEncrypted = encrypted.slice(65);\n  var ephemPubKey = ec.keyFromPublic(ephemPubKeyEncoded).getPublic();\n  var px = ec.keyFromPrivate(privKey).derive(ephemPubKey);\n  var hash = ConcatKDF(px.toBuffer(), 32); // km, ke\n\n  var encryptionKey = hash.slice(0, 16);\n  var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n  return AES128DecryptAndHMAC(encryptionKey, macKey, symmetricEncrypted);\n}\n\nexports.Decrypt = Decrypt;\nexports.ECIES = {\n  Encrypt: Encrypt,\n  Decrypt: Decrypt,\n  AES128EncryptAndHMAC: AES128EncryptAndHMAC,\n  AES128DecryptAndHMAC: AES128DecryptAndHMAC\n};","map":{"version":3,"sources":["../src/ecies.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * ECIES encrypt/decrypt with Ethereum keys\n * A Typescript implementation of geth/crypto/ecies/ecies.go\n * Modified from https://github.com/LimelabsTech/eth-ecies/blob/master/index.js\n * At commit c858cbd021e9a99d8afa629de33c8c30d923b3e5.\n */\n'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ECIES = exports.Decrypt = exports.Encrypt = exports.AES128DecryptAndHMAC = exports.AES128Decrypt = exports.AES128EncryptAndHMAC = exports.AES128Encrypt = exports.IV_LENGTH = void 0;\nvar crypto_1 = require(\"crypto\");\nvar elliptic_1 = require(\"elliptic\");\nvar ec = new elliptic_1.ec('secp256k1');\nexports.IV_LENGTH = 16;\n/**\n * Increments big endian uint32\n *\n * @param {Buffer} ctr 32 bit unsigned big endian integer to increment.\n * @returns Incremented counter.\n */\nvar IncCounter = function (ctr) {\n    for (var i = ctr.length - 1; i >= 0; i--) {\n        ctr[i]++;\n        if (ctr[i] !== 0) {\n            return ctr;\n        }\n    }\n    return ctr;\n};\n/**\n * NIST 8000-56C Rev 1 One Step KDF with the following parameters:\n * - H(x) is SHA-256(x)\n * - Fixed info is null\n *\n * TODO:\n * - Implement proper ceiling on reps.\n *\n * @param {Buffer} px Input keying material to derive key from.\n * @param {number} kdLen Length of output in bytes\n * @returns {Buffer} Output keying material of length kdLen bytes.\n */\nvar ConcatKDF = function (px, kdLen) {\n    var blockSize = 32;\n    var reps = ((kdLen + 7) * 8) / (blockSize * 8);\n    var counter = Buffer.from('00000001', 'hex');\n    var k = Buffer.from('00', 'hex');\n    for (var i = 0; i <= reps; i++) {\n        var hash = (0, crypto_1.createHash)('sha256');\n        hash.update(counter);\n        hash.update(px);\n        k = Buffer.concat([k, hash.digest()]);\n        counter = IncCounter(counter);\n    }\n    return k.slice(1, kdLen + 1);\n};\n/**\n * AES-128 CTR encrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\nfunction AES128Encrypt(encryptionKey, iv, plaintext) {\n    var cipher = (0, crypto_1.createCipheriv)('aes-128-ctr', encryptionKey, iv);\n    var firstChunk = cipher.update(plaintext);\n    var secondChunk = cipher.final();\n    return Buffer.concat([iv, firstChunk, secondChunk]);\n}\nexports.AES128Encrypt = AES128Encrypt;\n/**\n * AES-128 CTR encrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} plaintext\n * @returns {Buffer} ciphertext\n */\nfunction AES128EncryptAndHMAC(encryptionKey, macKey, plaintext) {\n    var iv = (0, crypto_1.randomBytes)(exports.IV_LENGTH);\n    var dataToMac = AES128Encrypt(encryptionKey, iv, plaintext);\n    var mac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n    return Buffer.concat([dataToMac, mac]);\n}\nexports.AES128EncryptAndHMAC = AES128EncryptAndHMAC;\n/**\n * AES-128 CTR decrypt\n * @param {Buffer} encryptionKey\n * @param {Buffer} iv\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\nfunction AES128Decrypt(encryptionKey, iv, ciphertext) {\n    var cipher = (0, crypto_1.createDecipheriv)('aes-128-ctr', encryptionKey, iv);\n    var firstChunk = cipher.update(ciphertext);\n    var secondChunk = cipher.final();\n    return Buffer.concat([firstChunk, secondChunk]);\n}\nexports.AES128Decrypt = AES128Decrypt;\n/**\n * AES-128 CTR decrypt with message authentication\n * @param {Buffer} encryptionKey\n * @param {Buffer} macKey\n * @param {Buffer} ciphertext\n * @returns {Buffer} plaintext\n */\nfunction AES128DecryptAndHMAC(encryptionKey, macKey, ciphertext) {\n    var iv = ciphertext.slice(0, exports.IV_LENGTH);\n    var message = ciphertext.slice(exports.IV_LENGTH, ciphertext.length - 32);\n    var mac = ciphertext.slice(ciphertext.length - 32, ciphertext.length);\n    var dataToMac = Buffer.concat([iv, message]);\n    var computedMac = (0, crypto_1.createHmac)('sha256', macKey).update(dataToMac).digest();\n    if (!mac.equals(computedMac)) {\n        throw new Error('MAC mismatch');\n    }\n    return AES128Decrypt(encryptionKey, iv, message);\n}\nexports.AES128DecryptAndHMAC = AES128DecryptAndHMAC;\n/**\n * ECIES encrypt\n * @param {Buffer} pubKeyTo Ethereum pub key, 64 bytes.\n * @param {Buffer} plaintext Plaintext to be encrypted.\n * @returns {Buffer} Encrypted message, serialized, 113+ bytes\n */\nfunction Encrypt(pubKeyTo, plaintext) {\n    var ephemPrivKey = ec.keyFromPrivate((0, crypto_1.randomBytes)(32));\n    var ephemPubKey = ephemPrivKey.getPublic(false, 'hex');\n    var ephemPubKeyEncoded = Buffer.from(ephemPubKey, 'hex');\n    var px = ephemPrivKey.derive(ec.keyFromPublic(Buffer.concat([Buffer.from([0x04]), pubKeyTo])).getPublic());\n    var hash = ConcatKDF(px.toArrayLike(Buffer), 32);\n    var encryptionKey = hash.slice(0, 16);\n    var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n    var message = AES128EncryptAndHMAC(encryptionKey, macKey, plaintext);\n    var serializedCiphertext = Buffer.concat([\n        ephemPubKeyEncoded,\n        message, // iv + ciphertext + mac (min 48 bytes)\n    ]);\n    return serializedCiphertext;\n}\nexports.Encrypt = Encrypt;\n/**\n * ECIES decrypt\n * @param {Buffer} privKey Ethereum private key, 32 bytes.\n * @param {Buffer} encrypted Encrypted message, serialized, 113+ bytes\n * @returns {Buffer} plaintext\n */\nfunction Decrypt(privKey, encrypted) {\n    // Read iv, ephemPubKey, mac, ciphertext from encrypted message\n    var ephemPubKeyEncoded = encrypted.slice(0, 65);\n    var symmetricEncrypted = encrypted.slice(65);\n    var ephemPubKey = ec.keyFromPublic(ephemPubKeyEncoded).getPublic();\n    var px = ec.keyFromPrivate(privKey).derive(ephemPubKey);\n    var hash = ConcatKDF(px.toBuffer(), 32);\n    // km, ke\n    var encryptionKey = hash.slice(0, 16);\n    var macKey = (0, crypto_1.createHash)('sha256').update(hash.slice(16)).digest();\n    return AES128DecryptAndHMAC(encryptionKey, macKey, symmetricEncrypted);\n}\nexports.Decrypt = Decrypt;\nexports.ECIES = {\n    Encrypt: Encrypt,\n    Decrypt: Decrypt,\n    AES128EncryptAndHMAC: AES128EncryptAndHMAC,\n    AES128DecryptAndHMAC: AES128DecryptAndHMAC,\n};\n//# sourceMappingURL=ecies.js.map"]},"metadata":{},"sourceType":"script"}