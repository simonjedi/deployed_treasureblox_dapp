import * as encoding from "@walletconnect/encoding";
import { generateChildLogger, getLoggerContext } from "@walletconnect/logger";
import { safeJsonParse, safeJsonStringify } from "@walletconnect/safe-json";
import { ERROR, generateKeyPair, deriveSharedKey, encrypt, decrypt, sha256, } from "@walletconnect/utils";
import { CRYPTO_CONTEXT, KEYCHAIN_CONTEXT } from "../constants";
export class KeyChain {
    constructor(client, logger) {
        this.client = client;
        this.logger = logger;
        this.keychain = new Map();
        this.name = KEYCHAIN_CONTEXT;
        this.client = client;
        this.logger = generateChildLogger(logger, this.name);
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    async init() {
        await this.restore();
    }
    async has(tag, opts) {
        return this.keychain.has(tag);
    }
    async set(tag, key, opts) {
        this.keychain.set(tag, key);
        await this.persist();
    }
    async get(tag, opts) {
        const key = this.keychain.get(tag);
        if (typeof key === "undefined") {
            throw new Error(ERROR.NO_MATCHING_KEY.format({ tag }).message);
        }
        return key;
    }
    async del(tag, opts) {
        this.keychain.delete(tag);
        await this.persist();
    }
    async restore() {
        const keychain = await this.client.storage.getKeyChain(this.context);
        if (typeof keychain !== "undefined") {
            this.keychain = keychain;
        }
    }
    async persist() {
        await this.client.storage.setKeyChain(this.context, this.keychain);
    }
}
export class Crypto {
    constructor(client, logger, keychain) {
        this.client = client;
        this.logger = logger;
        this.name = CRYPTO_CONTEXT;
        this.client = client;
        this.logger = generateChildLogger(logger, this.name);
        this.keychain = keychain || new KeyChain(this.client, this.logger);
    }
    get context() {
        return getLoggerContext(this.logger);
    }
    async init() {
        await this.keychain.init();
    }
    async hasKeys(tag) {
        return this.keychain.has(tag);
    }
    async generateKeyPair() {
        const keyPair = generateKeyPair();
        return this.setKeyPair(keyPair);
    }
    async generateSharedKey(self, peer, overrideTopic) {
        const keyPair = await this.getKeyPair(self.publicKey);
        const sharedKey = deriveSharedKey(keyPair.privateKey, peer.publicKey);
        return this.setEncryptionKeys({ sharedKey, publicKey: keyPair.publicKey }, overrideTopic);
    }
    async encrypt(topic, message) {
        const { sharedKey, publicKey } = await this.getEncryptionKeys(topic);
        const result = await encrypt({ message, sharedKey, publicKey });
        return result;
    }
    async decrypt(topic, encrypted) {
        const { sharedKey } = await this.getEncryptionKeys(topic);
        const result = await decrypt({ encrypted, sharedKey });
        return result;
    }
    async encodeJsonRpc(topic, payload) {
        const message = safeJsonStringify(payload);
        const hasKeys = await this.hasKeys(topic);
        const result = hasKeys ? await this.encrypt(topic, message) : encoding.utf8ToHex(message);
        return result;
    }
    async decodeJsonRpc(topic, encrypted) {
        const hasKeys = await this.hasKeys(topic);
        const message = hasKeys ? await this.decrypt(topic, encrypted) : encoding.hexToUtf8(encrypted);
        const payload = safeJsonParse(message);
        return payload;
    }
    concatKeys(keyA, keyB) {
        return encoding.arrayToHex(encoding.concatArrays(encoding.hexToArray(keyA), encoding.hexToArray(keyB)));
    }
    splitKeys(keys) {
        const arr = encoding.hexToArray(keys);
        return [encoding.arrayToHex(arr.slice(0, 32)), encoding.arrayToHex(arr.slice(32, 64))];
    }
    async setKeyPair(keyPair) {
        const keys = this.concatKeys(keyPair.publicKey, keyPair.privateKey);
        await this.keychain.set(keyPair.publicKey, keys);
        return keyPair.publicKey;
    }
    async getKeyPair(publicKey) {
        const [_, privateKey] = this.splitKeys(await this.keychain.get(publicKey));
        return { publicKey, privateKey };
    }
    async setEncryptionKeys(encryptionKeys, overrideTopic) {
        const topic = overrideTopic || (await sha256(encryptionKeys.sharedKey));
        const keys = this.concatKeys(encryptionKeys.sharedKey, encryptionKeys.publicKey);
        await this.keychain.set(topic, keys);
        return topic;
    }
    async getEncryptionKeys(topic) {
        const [sharedKey, publicKey] = this.splitKeys(await this.keychain.get(topic));
        return { sharedKey, publicKey };
    }
}
//# sourceMappingURL=crypto.js.map