{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst address_1 = require(\"./cry/address\");\n\nconst blake2b_1 = require(\"./cry/blake2b\");\n\nconst secp256k1_1 = require(\"./cry/secp256k1\");\n\nconst rlp_1 = require(\"./rlp\");\n/** Transaction class defines Meter's multi-clause transaction */\n\n\nclass Transaction {\n  /**\n   * construct a transaction object with given body\n   * @param body body of tx\n   */\n  constructor(body) {\n    this.body = Object.assign({}, body);\n  }\n  /** decode from Buffer to transaction\n   * @param raw encoded buffer\n   * @param unsigned to indicator if the encoded buffer contains signature\n   */\n\n\n  static decode(raw, unsigned) {\n    let body;\n    let signature;\n\n    if (unsigned) {\n      body = unsignedTxRLP.decode(raw);\n    } else {\n      const decoded = txRLP.decode(raw);\n      signature = decoded.signature;\n      delete decoded.signature;\n      body = decoded;\n    }\n\n    const reserved = body.reserved;\n\n    if (reserved.length > 0) {\n      if (reserved[reserved.length - 1].length === 0) {\n        throw new Error('invalid reserved fields: not trimmed');\n      }\n\n      const features = featuresKind.buffer(reserved[0], 'reserved.features').decode();\n      body.reserved = {\n        features\n      };\n\n      if (reserved.length > 1) {\n        body.reserved.unused = reserved.slice(1);\n      }\n    } else {\n      delete body.reserved;\n    }\n\n    const tx = new Transaction(body);\n\n    if (signature) {\n      tx.signature = signature;\n    }\n\n    return tx;\n  }\n  /**\n   * returns transaction ID\n   * null returned if something wrong (e.g. invalid signature)\n   */\n\n\n  get id() {\n    if (!this._signatureValid) {\n      return null;\n    }\n\n    try {\n      const signingHash = this.signingHash();\n      const pubKey = secp256k1_1.secp256k1.recover(signingHash, this.signature.slice(0, 65));\n      const origin = address_1.publicKeyToAddress(pubKey);\n      return '0x' + blake2b_1.blake2b256(signingHash, origin).toString('hex');\n    } catch (_a) {\n      return null;\n    }\n  }\n  /**\n   * compute signing hashes.\n   * It returns tx hash for origin or delegator depends on param `delegateFor`.\n   * @param delegateFor address of intended tx origin. If set, the returned hash is for delegator to sign.\n   */\n\n\n  signingHash(delegateFor) {\n    const reserved = this._encodeReserved();\n\n    const buf = unsignedTxRLP.encode(Object.assign(Object.assign({}, this.body), {\n      reserved\n    }));\n    const hash = blake2b_1.blake2b256(buf);\n\n    if (delegateFor) {\n      if (!/^0x[0-9a-f]{40}$/i.test(delegateFor)) {\n        throw new Error('delegateFor expected address');\n      }\n\n      return blake2b_1.blake2b256(hash, Buffer.from(delegateFor.slice(2), 'hex'));\n    }\n\n    return hash;\n  }\n  /** returns tx origin. null returned if no signature or not incorrectly signed */\n\n\n  get origin() {\n    if (!this._signatureValid) {\n      return null;\n    }\n\n    try {\n      const signingHash = this.signingHash();\n      const pubKey = secp256k1_1.secp256k1.recover(signingHash, this.signature.slice(0, 65));\n      return '0x' + address_1.publicKeyToAddress(pubKey).toString('hex');\n    } catch (_a) {\n      return null;\n    }\n  }\n  /** returns tx delegator. null returned if no signature or not incorrectly signed */\n\n\n  get delegator() {\n    if (!this.delegated) {\n      return null;\n    }\n\n    if (!this._signatureValid) {\n      return null;\n    }\n\n    const origin = this.origin;\n\n    if (!origin) {\n      return null;\n    }\n\n    try {\n      const signingHash = this.signingHash(origin);\n      const pubKey = secp256k1_1.secp256k1.recover(signingHash, this.signature.slice(65));\n      return '0x' + address_1.publicKeyToAddress(pubKey).toString('hex');\n    } catch (_a) {\n      return null;\n    }\n  }\n  /** returns whether delegated. see https://github.com/dfinlab/VIPs/blob/master/vips/VIP-191.md */\n\n\n  get delegated() {\n    return (((this.body.reserved || {}).features || 0) & Transaction.DELEGATED_MASK) === Transaction.DELEGATED_MASK;\n  }\n  /** returns intrinsic gas it takes */\n\n\n  get intrinsicGas() {\n    return Transaction.intrinsicGas(this.body.clauses);\n  }\n  /** encode into Buffer */\n\n\n  encode() {\n    const reserved = this._encodeReserved();\n\n    if (this.signature) {\n      return txRLP.encode(Object.assign(Object.assign({}, this.body), {\n        reserved,\n        signature: this.signature\n      }));\n    }\n\n    return unsignedTxRLP.encode(Object.assign(Object.assign({}, this.body), {\n      reserved\n    }));\n  }\n\n  _encodeReserved() {\n    const reserved = this.body.reserved || {};\n    const list = [featuresKind.data(reserved.features || 0, 'reserved.features').encode(), ...(reserved.unused || [])]; // trim\n\n    while (list.length > 0) {\n      if (list[list.length - 1].length === 0) {\n        list.pop();\n      } else {\n        break;\n      }\n    }\n\n    return list;\n  }\n\n  get _signatureValid() {\n    const expectedSigLen = this.delegated ? 65 * 2 : 65;\n    return this.signature ? this.signature.length === expectedSigLen : false;\n  }\n\n}\n\nexports.Transaction = Transaction;\nTransaction.DELEGATED_MASK = 1;\n\n(function (Transaction) {\n  /**\n   * calculates intrinsic gas that a tx costs with the given clauses.\n   * @param clauses\n   */\n  function intrinsicGas(clauses) {\n    const txGas = 5000;\n    const clauseGas = 16000;\n    const clauseGasContractCreation = 48000;\n\n    if (clauses.length === 0) {\n      return txGas + clauseGas;\n    }\n\n    return clauses.reduce((sum, c) => {\n      if (c.to) {\n        sum += clauseGas;\n      } else {\n        sum += clauseGasContractCreation;\n      }\n\n      sum += dataGas(c.data);\n      return sum;\n    }, txGas);\n  }\n\n  Transaction.intrinsicGas = intrinsicGas;\n\n  function dataGas(data) {\n    const zgas = 4;\n    const nzgas = 68;\n    let sum = 0;\n\n    for (let i = 2; i < data.length; i += 2) {\n      if (data.substr(i, 2) === '00') {\n        sum += zgas;\n      } else {\n        sum += nzgas;\n      }\n    }\n\n    return sum;\n  }\n})(Transaction = exports.Transaction || (exports.Transaction = {}));\n\nconst unsignedTxRLP = new rlp_1.RLP({\n  name: 'tx',\n  kind: [{\n    name: 'chainTag',\n    kind: new rlp_1.RLP.NumericKind(1)\n  }, {\n    name: 'blockRef',\n    kind: new rlp_1.RLP.CompactFixedBlobKind(8)\n  }, {\n    name: 'expiration',\n    kind: new rlp_1.RLP.NumericKind(4)\n  }, {\n    name: 'clauses',\n    kind: {\n      item: [{\n        name: 'to',\n        kind: new rlp_1.RLP.NullableFixedBlobKind(20)\n      }, {\n        name: 'value',\n        kind: new rlp_1.RLP.NumericKind(32)\n      }, {\n        name: 'token',\n        kind: new rlp_1.RLP.NumericKind(1)\n      }, {\n        name: 'data',\n        kind: new rlp_1.RLP.BlobKind()\n      }]\n    }\n  }, {\n    name: 'gasPriceCoef',\n    kind: new rlp_1.RLP.NumericKind(1)\n  }, {\n    name: 'gas',\n    kind: new rlp_1.RLP.NumericKind(8)\n  }, {\n    name: 'dependsOn',\n    kind: new rlp_1.RLP.NullableFixedBlobKind(32)\n  }, {\n    name: 'nonce',\n    kind: new rlp_1.RLP.NumericKind(8)\n  }, {\n    name: 'reserved',\n    kind: {\n      item: new rlp_1.RLP.BufferKind()\n    }\n  }]\n});\nconst txRLP = new rlp_1.RLP({\n  name: 'tx',\n  kind: [...unsignedTxRLP.profile.kind, {\n    name: 'signature',\n    kind: new rlp_1.RLP.BufferKind()\n  }]\n});\nconst featuresKind = new rlp_1.RLP.NumericKind(4);","map":{"version":3,"sources":["../src/transaction.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst address_1 = require(\"./cry/address\");\nconst blake2b_1 = require(\"./cry/blake2b\");\nconst secp256k1_1 = require(\"./cry/secp256k1\");\nconst rlp_1 = require(\"./rlp\");\n/** Transaction class defines Meter's multi-clause transaction */\nclass Transaction {\n    /**\n     * construct a transaction object with given body\n     * @param body body of tx\n     */\n    constructor(body) {\n        this.body = Object.assign({}, body);\n    }\n    /** decode from Buffer to transaction\n     * @param raw encoded buffer\n     * @param unsigned to indicator if the encoded buffer contains signature\n     */\n    static decode(raw, unsigned) {\n        let body;\n        let signature;\n        if (unsigned) {\n            body = unsignedTxRLP.decode(raw);\n        }\n        else {\n            const decoded = txRLP.decode(raw);\n            signature = decoded.signature;\n            delete decoded.signature;\n            body = decoded;\n        }\n        const reserved = body.reserved;\n        if (reserved.length > 0) {\n            if (reserved[reserved.length - 1].length === 0) {\n                throw new Error('invalid reserved fields: not trimmed');\n            }\n            const features = featuresKind.buffer(reserved[0], 'reserved.features').decode();\n            body.reserved = {\n                features,\n            };\n            if (reserved.length > 1) {\n                body.reserved.unused = reserved.slice(1);\n            }\n        }\n        else {\n            delete body.reserved;\n        }\n        const tx = new Transaction(body);\n        if (signature) {\n            tx.signature = signature;\n        }\n        return tx;\n    }\n    /**\n     * returns transaction ID\n     * null returned if something wrong (e.g. invalid signature)\n     */\n    get id() {\n        if (!this._signatureValid) {\n            return null;\n        }\n        try {\n            const signingHash = this.signingHash();\n            const pubKey = secp256k1_1.secp256k1.recover(signingHash, this.signature.slice(0, 65));\n            const origin = address_1.publicKeyToAddress(pubKey);\n            return '0x' + blake2b_1.blake2b256(signingHash, origin).toString('hex');\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    /**\n     * compute signing hashes.\n     * It returns tx hash for origin or delegator depends on param `delegateFor`.\n     * @param delegateFor address of intended tx origin. If set, the returned hash is for delegator to sign.\n     */\n    signingHash(delegateFor) {\n        const reserved = this._encodeReserved();\n        const buf = unsignedTxRLP.encode(Object.assign(Object.assign({}, this.body), { reserved }));\n        const hash = blake2b_1.blake2b256(buf);\n        if (delegateFor) {\n            if (!/^0x[0-9a-f]{40}$/i.test(delegateFor)) {\n                throw new Error('delegateFor expected address');\n            }\n            return blake2b_1.blake2b256(hash, Buffer.from(delegateFor.slice(2), 'hex'));\n        }\n        return hash;\n    }\n    /** returns tx origin. null returned if no signature or not incorrectly signed */\n    get origin() {\n        if (!this._signatureValid) {\n            return null;\n        }\n        try {\n            const signingHash = this.signingHash();\n            const pubKey = secp256k1_1.secp256k1.recover(signingHash, this.signature.slice(0, 65));\n            return '0x' + address_1.publicKeyToAddress(pubKey).toString('hex');\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    /** returns tx delegator. null returned if no signature or not incorrectly signed */\n    get delegator() {\n        if (!this.delegated) {\n            return null;\n        }\n        if (!this._signatureValid) {\n            return null;\n        }\n        const origin = this.origin;\n        if (!origin) {\n            return null;\n        }\n        try {\n            const signingHash = this.signingHash(origin);\n            const pubKey = secp256k1_1.secp256k1.recover(signingHash, this.signature.slice(65));\n            return '0x' + address_1.publicKeyToAddress(pubKey).toString('hex');\n        }\n        catch (_a) {\n            return null;\n        }\n    }\n    /** returns whether delegated. see https://github.com/dfinlab/VIPs/blob/master/vips/VIP-191.md */\n    get delegated() {\n        return ((((this.body.reserved || {}).features || 0) & Transaction.DELEGATED_MASK) ===\n            Transaction.DELEGATED_MASK);\n    }\n    /** returns intrinsic gas it takes */\n    get intrinsicGas() {\n        return Transaction.intrinsicGas(this.body.clauses);\n    }\n    /** encode into Buffer */\n    encode() {\n        const reserved = this._encodeReserved();\n        if (this.signature) {\n            return txRLP.encode(Object.assign(Object.assign({}, this.body), { reserved, signature: this.signature }));\n        }\n        return unsignedTxRLP.encode(Object.assign(Object.assign({}, this.body), { reserved }));\n    }\n    _encodeReserved() {\n        const reserved = this.body.reserved || {};\n        const list = [\n            featuresKind.data(reserved.features || 0, 'reserved.features').encode(),\n            ...(reserved.unused || []),\n        ];\n        // trim\n        while (list.length > 0) {\n            if (list[list.length - 1].length === 0) {\n                list.pop();\n            }\n            else {\n                break;\n            }\n        }\n        return list;\n    }\n    get _signatureValid() {\n        const expectedSigLen = this.delegated ? 65 * 2 : 65;\n        return this.signature ? this.signature.length === expectedSigLen : false;\n    }\n}\nexports.Transaction = Transaction;\nTransaction.DELEGATED_MASK = 1;\n(function (Transaction) {\n    /**\n     * calculates intrinsic gas that a tx costs with the given clauses.\n     * @param clauses\n     */\n    function intrinsicGas(clauses) {\n        const txGas = 5000;\n        const clauseGas = 16000;\n        const clauseGasContractCreation = 48000;\n        if (clauses.length === 0) {\n            return txGas + clauseGas;\n        }\n        return clauses.reduce((sum, c) => {\n            if (c.to) {\n                sum += clauseGas;\n            }\n            else {\n                sum += clauseGasContractCreation;\n            }\n            sum += dataGas(c.data);\n            return sum;\n        }, txGas);\n    }\n    Transaction.intrinsicGas = intrinsicGas;\n    function dataGas(data) {\n        const zgas = 4;\n        const nzgas = 68;\n        let sum = 0;\n        for (let i = 2; i < data.length; i += 2) {\n            if (data.substr(i, 2) === '00') {\n                sum += zgas;\n            }\n            else {\n                sum += nzgas;\n            }\n        }\n        return sum;\n    }\n})(Transaction = exports.Transaction || (exports.Transaction = {}));\nconst unsignedTxRLP = new rlp_1.RLP({\n    name: 'tx',\n    kind: [\n        { name: 'chainTag', kind: new rlp_1.RLP.NumericKind(1) },\n        { name: 'blockRef', kind: new rlp_1.RLP.CompactFixedBlobKind(8) },\n        { name: 'expiration', kind: new rlp_1.RLP.NumericKind(4) },\n        {\n            name: 'clauses',\n            kind: {\n                item: [\n                    { name: 'to', kind: new rlp_1.RLP.NullableFixedBlobKind(20) },\n                    { name: 'value', kind: new rlp_1.RLP.NumericKind(32) },\n                    { name: 'token', kind: new rlp_1.RLP.NumericKind(1) },\n                    { name: 'data', kind: new rlp_1.RLP.BlobKind() },\n                ],\n            },\n        },\n        { name: 'gasPriceCoef', kind: new rlp_1.RLP.NumericKind(1) },\n        { name: 'gas', kind: new rlp_1.RLP.NumericKind(8) },\n        { name: 'dependsOn', kind: new rlp_1.RLP.NullableFixedBlobKind(32) },\n        { name: 'nonce', kind: new rlp_1.RLP.NumericKind(8) },\n        { name: 'reserved', kind: { item: new rlp_1.RLP.BufferKind() } },\n    ],\n});\nconst txRLP = new rlp_1.RLP({\n    name: 'tx',\n    kind: [\n        ...unsignedTxRLP.profile.kind,\n        { name: 'signature', kind: new rlp_1.RLP.BufferKind() },\n    ],\n});\nconst featuresKind = new rlp_1.RLP.NumericKind(4);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhbnNhY3Rpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvdHJhbnNhY3Rpb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSwyQ0FBbUQ7QUFDbkQsMkNBQTJDO0FBQzNDLCtDQUE0QztBQUM1QywrQkFBNEI7QUFFNUIsaUVBQWlFO0FBQ2pFLE1BQWEsV0FBVztJQWdEdEI7OztPQUdHO0lBQ0gsWUFBWSxJQUFzQjtRQUNoQyxJQUFJLENBQUMsSUFBSSxxQkFBUSxJQUFJLENBQUUsQ0FBQztJQUMxQixDQUFDO0lBbkREOzs7T0FHRztJQUNJLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBVyxFQUFFLFFBQWtCO1FBQ2xELElBQUksSUFBc0IsQ0FBQztRQUMzQixJQUFJLFNBQTZCLENBQUM7UUFDbEMsSUFBSSxRQUFRLEVBQUU7WUFDWixJQUFJLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztTQUNsQzthQUFNO1lBQ0wsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNsQyxTQUFTLEdBQUcsT0FBTyxDQUFDLFNBQW1CLENBQUM7WUFDeEMsT0FBTyxPQUFPLENBQUMsU0FBUyxDQUFDO1lBQ3pCLElBQUksR0FBRyxPQUFPLENBQUM7U0FDaEI7UUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsUUFBb0IsQ0FBQztRQUMzQyxJQUFJLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQ3ZCLElBQUksUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtnQkFDOUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxzQ0FBc0MsQ0FBQyxDQUFDO2FBQ3pEO1lBRUQsTUFBTSxRQUFRLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsbUJBQW1CLENBQUMsQ0FB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"]},"metadata":{},"sourceType":"script"}