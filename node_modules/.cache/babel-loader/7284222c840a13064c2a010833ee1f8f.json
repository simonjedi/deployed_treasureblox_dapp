{"ast":null,"code":"var _classCallCheck = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar EventEmitter = require('events');\n\nvar dev = process.env.NODE_ENV === 'development';\n\nvar ConnectionManager = /*#__PURE__*/function (_EventEmitter) {\n  \"use strict\";\n\n  _inherits(ConnectionManager, _EventEmitter);\n\n  var _super = _createSuper(ConnectionManager);\n\n  function ConnectionManager(connections, targets, options) {\n    var _this;\n\n    _classCallCheck(this, ConnectionManager);\n\n    _this = _super.call(this);\n    _this.targets = targets;\n    _this.connections = connections;\n    _this.connected = false;\n    _this.status = 'loading';\n    _this.interval = options.interval || 5000;\n    _this.name = options.name || 'default';\n    _this.inSetup = true;\n\n    _this.connect();\n\n    return _this;\n  }\n\n  _createClass(ConnectionManager, [{\n    key: \"connect\",\n    value: function connect() {\n      var _this2 = this;\n\n      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (dev && index === 0) console.log(\"\\n\\n\\n\\nA connection cycle started for provider with name: \".concat(this.name));\n\n      if (this.connection && this.connection.status === 'connected' && index >= this.connection.index) {\n        if (dev) console.log('Stopping connection cycle becasuse we\\'re already connected to a higher priority provider');\n      } else if (this.targets.length === 0) {\n        if (dev) console.log('No valid targets supplied');\n      } else {\n        var _this$targets$index = this.targets[index],\n            protocol = _this$targets$index.protocol,\n            location = _this$targets$index.location;\n        this.connection = this.connections[protocol](location);\n        this.connection.on('error', function (err) {\n          if (!_this2.connected) return _this2.connectionError(index, err);\n          if (_this2.listenerCount('error')) return _this2.emit('error', err);\n          console.warn('eth-provider - Uncaught connection error: ' + err.message);\n        });\n        this.connection.on('close', function (summary) {\n          _this2.connected = false;\n\n          _this2.emit('close');\n\n          if (!_this2.closing) _this2.refresh();\n        });\n        this.connection.on('connect', function () {\n          _this2.connection.target = _this2.targets[index];\n          _this2.connection.index = index;\n          _this2.targets[index].status = _this2.connection.status;\n          _this2.connected = true;\n          _this2.inSetup = false;\n          if (dev) console.log('Successfully connected to: ' + _this2.targets[index].location);\n\n          _this2.emit('connect');\n        });\n        this.connection.on('data', function (data) {\n          return _this2.emit('data', data);\n        });\n        this.connection.on('payload', function (payload) {\n          return _this2.emit('payload', payload);\n        });\n      }\n    }\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      var _this3 = this;\n\n      var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.interval;\n      if (dev) console.log(\"Reconnect queued for \".concat((interval / 1000).toFixed(2), \"s in the future\"));\n      clearTimeout(this.connectTimer);\n      this.connectTimer = setTimeout(function () {\n        return _this3.connect();\n      }, interval);\n    }\n  }, {\n    key: \"connectionError\",\n    value: function connectionError(index, err) {\n      this.targets[index].status = err;\n\n      if (this.targets.length - 1 === index) {\n        this.inSetup = false;\n        if (dev) console.warn('eth-provider unable to connect to any targets, view connection cycle summary: ', this.targets);\n        this.refresh();\n      } else {\n        // Not last target, move on the next connection option\n        this.connect(++index);\n      }\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      this.closing = true;\n\n      if (this.connection) {\n        this.connection.close(); // Let event bubble from here\n      } else {\n        this.emit('close');\n      }\n\n      clearTimeout(this.connectTimer);\n    }\n  }, {\n    key: \"error\",\n    value: function error(payload, message) {\n      var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;\n      this.emit('payload', {\n        id: payload.id,\n        jsonrpc: payload.jsonrpc,\n        error: {\n          message: message,\n          code: code\n        }\n      });\n    }\n  }, {\n    key: \"send\",\n    value: function send(payload) {\n      var _this4 = this;\n\n      if (this.inSetup) {\n        setTimeout(function () {\n          return _this4.send(payload);\n        }, 100);\n      } else if (this.connection.closed) {\n        this.error(payload, 'Not connected');\n      } else {\n        this.connection.send(payload);\n      }\n    }\n  }]);\n\n  return ConnectionManager;\n}(EventEmitter);\n\nmodule.exports = ConnectionManager;","map":{"version":3,"sources":["/Users/jedi/Desktop/Education/REACT/TreasureHuntDAPP_React/node_modules/eth-provider/ConnectionManager/index.js"],"names":["EventEmitter","require","dev","process","env","NODE_ENV","ConnectionManager","connections","targets","options","connected","status","interval","name","inSetup","connect","index","console","log","connection","length","protocol","location","on","err","connectionError","listenerCount","emit","warn","message","summary","closing","refresh","target","data","payload","toFixed","clearTimeout","connectTimer","setTimeout","close","code","id","jsonrpc","error","send","closed","module","exports"],"mappings":"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","sourcesContent":["const EventEmitter = require('events')\n\nconst dev = process.env.NODE_ENV === 'development'\n\nclass ConnectionManager extends EventEmitter {\n  constructor (connections, targets, options) {\n    super()\n    this.targets = targets\n    this.connections = connections\n    this.connected = false\n    this.status = 'loading'\n    this.interval = options.interval || 5000\n    this.name = options.name || 'default'\n    this.inSetup = true\n    this.connect()\n  }\n\n  connect (index = 0) {\n    if (dev && index === 0) console.log(`\\n\\n\\n\\nA connection cycle started for provider with name: ${this.name}`)\n\n    if (this.connection && this.connection.status === 'connected' && index >= this.connection.index) {\n      if (dev) console.log('Stopping connection cycle becasuse we\\'re already connected to a higher priority provider')\n    } else if (this.targets.length === 0) {\n      if (dev) console.log('No valid targets supplied')\n    } else {\n      const { protocol, location } = this.targets[index]\n      this.connection = this.connections[protocol](location)\n\n      this.connection.on('error', err => {\n        if (!this.connected) return this.connectionError(index, err)\n        if (this.listenerCount('error')) return this.emit('error', err)\n        console.warn('eth-provider - Uncaught connection error: ' + err.message)\n      })\n\n      this.connection.on('close', (summary) => {\n        this.connected = false\n        this.emit('close')\n        if (!this.closing) this.refresh()\n      })\n\n      this.connection.on('connect', () => {\n        this.connection.target = this.targets[index]\n        this.connection.index = index\n        this.targets[index].status = this.connection.status\n        this.connected = true\n        this.inSetup = false\n        if (dev) console.log('Successfully connected to: ' + this.targets[index].location)\n        this.emit('connect')\n      })\n\n      this.connection.on('data', data => this.emit('data', data))\n      this.connection.on('payload', payload => this.emit('payload', payload))\n    }\n  }\n\n  refresh (interval = this.interval) {\n    if (dev) console.log(`Reconnect queued for ${(interval / 1000).toFixed(2)}s in the future`)\n    clearTimeout(this.connectTimer)\n    this.connectTimer = setTimeout(() => this.connect(), interval)\n  }\n\n  connectionError (index, err) {\n    this.targets[index].status = err\n    if (this.targets.length - 1 === index) {\n      this.inSetup = false\n      if (dev) console.warn('eth-provider unable to connect to any targets, view connection cycle summary: ', this.targets)\n      this.refresh()\n    } else { // Not last target, move on the next connection option\n      this.connect(++index)\n    }\n  }\n\n  close () {\n    this.closing = true\n    if (this.connection) {\n      this.connection.close() // Let event bubble from here\n    } else {\n      this.emit('close')\n    }\n    clearTimeout(this.connectTimer)\n  }\n\n  error (payload, message, code = -1) {\n    this.emit('payload', { id: payload.id, jsonrpc: payload.jsonrpc, error: { message, code } })\n  }\n\n  send (payload) {\n    if (this.inSetup) {\n      setTimeout(() => this.send(payload), 100)\n    } else if (this.connection.closed) {\n      this.error(payload, 'Not connected')\n    } else {\n      this.connection.send(payload)\n    }\n  }\n}\n\nmodule.exports = ConnectionManager\n"]},"metadata":{},"sourceType":"script"}