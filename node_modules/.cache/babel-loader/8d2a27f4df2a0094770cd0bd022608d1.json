{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { ISubscription } from \"@walletconnect/types\";\nimport { ERROR, formatMessageContext, toMiliseconds, calcExpiry } from \"@walletconnect/utils\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { CLIENT_EVENTS, SUBSCRIPTION_CONTEXT, SUBSCRIPTION_DEFAULT_TTL, SUBSCRIPTION_EVENTS } from \"../constants\";\nexport class SubscriptionTopicMap {\n  constructor() {\n    this.map = new Map();\n  }\n\n  get topics() {\n    return Array.from(this.map.keys());\n  }\n\n  set(topic, id) {\n    const ids = this.get(topic);\n    if (this.exists(topic, id)) return;\n    this.map.set(topic, [...ids, id]);\n  }\n\n  get(topic) {\n    const ids = this.map.get(topic);\n    return ids || [];\n  }\n\n  exists(topic, id) {\n    const ids = this.get(topic);\n    return ids.includes(id);\n  }\n\n  delete(topic, id) {\n    if (typeof id === \"undefined\") {\n      this.map.delete(topic);\n      return;\n    }\n\n    if (!this.map.has(topic)) return;\n    const ids = this.get(topic);\n    if (!this.exists(topic, id)) return;\n    const remaining = ids.filter(x => x !== id);\n\n    if (!remaining.length) {\n      this.map.delete(topic);\n      return;\n    }\n\n    this.map.set(topic, remaining);\n  }\n\n  clear() {\n    this.map.clear();\n  }\n\n}\nexport class Subscription extends ISubscription {\n  constructor(client, logger) {\n    super(client, logger);\n    this.client = client;\n    this.logger = logger;\n    this.subscriptions = new Map();\n    this.topicMap = new SubscriptionTopicMap();\n    this.events = new EventEmitter();\n    this.name = SUBSCRIPTION_CONTEXT;\n    this.cached = [];\n    this.logger = generateChildLogger(logger, this.name);\n    this.registerEventListeners();\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.initialize();\n  }\n\n  get context() {\n    return getLoggerContext(this.logger);\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get ids() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  get topics() {\n    return this.topicMap.topics;\n  }\n\n  async set(id, subscription) {\n    await this.isEnabled();\n    if (this.subscriptions.has(id)) return;\n    this.logger.debug(`Setting subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"set\",\n      id,\n      subscription\n    });\n    this.setSubscription(id, subscription);\n    this.events.emit(SUBSCRIPTION_EVENTS.created, subscription);\n  }\n\n  async get(id) {\n    await this.isEnabled();\n    this.logger.debug(`Getting subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      id\n    });\n    const subscription = this.getSubscription(id);\n    return subscription;\n  }\n\n  async exists(id, topic) {\n    await this.isEnabled();\n    let result = false;\n\n    try {\n      const subscription = this.getSubscription(id);\n      result = subscription.topic === topic;\n    } catch (e) {}\n\n    return result;\n  }\n\n  async delete(id, reason) {\n    await this.isEnabled();\n    this.logger.debug(`Deleting subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"delete\",\n      id,\n      reason\n    });\n    const subscription = this.getSubscription(id);\n    this.deleteSubscription(id, subscription);\n    this.events.emit(SUBSCRIPTION_EVENTS.deleted, Object.assign(Object.assign({}, subscription), {\n      reason\n    }));\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async enable() {\n    if (!this.cached.length) return;\n    this.reset();\n    this.onEnable();\n  }\n\n  async disable() {\n    if (this.cached.length) return;\n    this.onDisable();\n  }\n\n  reset() {\n    this.cached.map(async subscription => this.setSubscription(subscription.id, subscription));\n  }\n\n  onEnable() {\n    this.cached = [];\n    this.events.emit(SUBSCRIPTION_EVENTS.enabled);\n  }\n\n  onDisable() {\n    this.cached = this.values;\n    this.subscriptions.clear();\n    this.topicMap.clear();\n    this.events.emit(SUBSCRIPTION_EVENTS.disabled);\n  }\n\n  setSubscription(id, subscription) {\n    const expiry = subscription.expiry || calcExpiry(SUBSCRIPTION_DEFAULT_TTL);\n    this.subscriptions.set(id, Object.assign(Object.assign({}, subscription), {\n      expiry\n    }));\n    this.topicMap.set(subscription.topic, id);\n    this.checkExpiry(id, expiry);\n  }\n\n  getSubscription(id) {\n    const subscription = this.subscriptions.get(id);\n\n    if (!subscription) {\n      const error = ERROR.NO_MATCHING_ID.format({\n        context: formatMessageContext(this.context),\n        id\n      });\n      throw new Error(error.message);\n    }\n\n    return subscription;\n  }\n\n  deleteSubscription(id, subscription) {\n    this.subscriptions.delete(id);\n    this.topicMap.delete(subscription.topic, id);\n  }\n\n  checkExpiry(id, expiry) {\n    const msToTimeout = toMiliseconds(expiry) - Date.now();\n    if (msToTimeout <= 0) this.expire(id);\n  }\n\n  expire(id) {\n    const reason = ERROR.EXPIRED.format({\n      context: formatMessageContext(this.context)\n    });\n    const subscription = this.getSubscription(id);\n    this.deleteSubscription(id, subscription);\n    this.events.emit(SUBSCRIPTION_EVENTS.deleted, Object.assign(Object.assign({}, subscription), {\n      reason\n    }));\n  }\n\n  checkSubscriptions() {\n    this.subscriptions.forEach(subscription => this.checkExpiry(subscription.id, subscription.expiry));\n  }\n\n  async persist() {\n    await this.client.storage.setRelayerSubscriptions(this.context, this.values);\n    this.events.emit(SUBSCRIPTION_EVENTS.sync);\n  }\n\n  async restore() {\n    try {\n      const persisted = await this.client.storage.getRelayerSubscriptions(this.context);\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n\n      if (this.subscriptions.size) {\n        const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n          context: formatMessageContext(this.context)\n        });\n        this.logger.error(error.message);\n        throw new Error(error.message);\n      }\n\n      this.cached = persisted;\n      this.logger.debug(`Successfully Restored subscriptions for ${formatMessageContext(this.context)}`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${formatMessageContext(this.context)}`);\n      this.logger.error(e);\n    }\n  }\n\n  async initialize() {\n    await this.restore();\n    this.reset();\n    this.onInit();\n  }\n\n  onInit() {\n    this.onEnable();\n  }\n\n  async isEnabled() {\n    if (!this.cached.length) return;\n    return new Promise(resolve => {\n      this.events.once(SUBSCRIPTION_EVENTS.enabled, () => resolve());\n    });\n  }\n\n  onExpiry(expiredEvent) {\n    const eventName = SUBSCRIPTION_EVENTS.expired;\n    this.logger.info(`Emitting ${eventName}`);\n    this.logger.debug({\n      type: \"event\",\n      event: eventName,\n      data: expiredEvent\n    });\n    this.events.emit(SUBSCRIPTION_EVENTS.expired, expiredEvent);\n  }\n\n  registerEventListeners() {\n    this.client.on(CLIENT_EVENTS.beat, () => this.checkSubscriptions());\n    this.events.on(SUBSCRIPTION_EVENTS.created, async createdEvent => {\n      const eventName = SUBSCRIPTION_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: createdEvent\n      });\n      await this.persist();\n    });\n    this.events.on(SUBSCRIPTION_EVENTS.deleted, async deletedEvent => {\n      const eventName = SUBSCRIPTION_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: deletedEvent\n      });\n      await this.persist();\n      if (deletedEvent.reason.code === ERROR.EXPIRED.code) this.onExpiry(deletedEvent);\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/subscription.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { ISubscription, } from \"@walletconnect/types\";\nimport { ERROR, formatMessageContext, toMiliseconds, calcExpiry } from \"@walletconnect/utils\";\nimport { generateChildLogger, getLoggerContext } from \"@walletconnect/logger\";\nimport { CLIENT_EVENTS, SUBSCRIPTION_CONTEXT, SUBSCRIPTION_DEFAULT_TTL, SUBSCRIPTION_EVENTS, } from \"../constants\";\nexport class SubscriptionTopicMap {\n    constructor() {\n        this.map = new Map();\n    }\n    get topics() {\n        return Array.from(this.map.keys());\n    }\n    set(topic, id) {\n        const ids = this.get(topic);\n        if (this.exists(topic, id))\n            return;\n        this.map.set(topic, [...ids, id]);\n    }\n    get(topic) {\n        const ids = this.map.get(topic);\n        return ids || [];\n    }\n    exists(topic, id) {\n        const ids = this.get(topic);\n        return ids.includes(id);\n    }\n    delete(topic, id) {\n        if (typeof id === \"undefined\") {\n            this.map.delete(topic);\n            return;\n        }\n        if (!this.map.has(topic))\n            return;\n        const ids = this.get(topic);\n        if (!this.exists(topic, id))\n            return;\n        const remaining = ids.filter(x => x !== id);\n        if (!remaining.length) {\n            this.map.delete(topic);\n            return;\n        }\n        this.map.set(topic, remaining);\n    }\n    clear() {\n        this.map.clear();\n    }\n}\nexport class Subscription extends ISubscription {\n    constructor(client, logger) {\n        super(client, logger);\n        this.client = client;\n        this.logger = logger;\n        this.subscriptions = new Map();\n        this.topicMap = new SubscriptionTopicMap();\n        this.events = new EventEmitter();\n        this.name = SUBSCRIPTION_CONTEXT;\n        this.cached = [];\n        this.logger = generateChildLogger(logger, this.name);\n        this.registerEventListeners();\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.initialize();\n    }\n    get context() {\n        return getLoggerContext(this.logger);\n    }\n    get length() {\n        return this.subscriptions.size;\n    }\n    get ids() {\n        return Array.from(this.subscriptions.keys());\n    }\n    get values() {\n        return Array.from(this.subscriptions.values());\n    }\n    get topics() {\n        return this.topicMap.topics;\n    }\n    async set(id, subscription) {\n        await this.isEnabled();\n        if (this.subscriptions.has(id))\n            return;\n        this.logger.debug(`Setting subscription`);\n        this.logger.trace({ type: \"method\", method: \"set\", id, subscription });\n        this.setSubscription(id, subscription);\n        this.events.emit(SUBSCRIPTION_EVENTS.created, subscription);\n    }\n    async get(id) {\n        await this.isEnabled();\n        this.logger.debug(`Getting subscription`);\n        this.logger.trace({ type: \"method\", method: \"get\", id });\n        const subscription = this.getSubscription(id);\n        return subscription;\n    }\n    async exists(id, topic) {\n        await this.isEnabled();\n        let result = false;\n        try {\n            const subscription = this.getSubscription(id);\n            result = subscription.topic === topic;\n        }\n        catch (e) {\n        }\n        return result;\n    }\n    async delete(id, reason) {\n        await this.isEnabled();\n        this.logger.debug(`Deleting subscription`);\n        this.logger.trace({ type: \"method\", method: \"delete\", id, reason });\n        const subscription = this.getSubscription(id);\n        this.deleteSubscription(id, subscription);\n        this.events.emit(SUBSCRIPTION_EVENTS.deleted, Object.assign(Object.assign({}, subscription), { reason }));\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async enable() {\n        if (!this.cached.length)\n            return;\n        this.reset();\n        this.onEnable();\n    }\n    async disable() {\n        if (this.cached.length)\n            return;\n        this.onDisable();\n    }\n    reset() {\n        this.cached.map(async (subscription) => this.setSubscription(subscription.id, subscription));\n    }\n    onEnable() {\n        this.cached = [];\n        this.events.emit(SUBSCRIPTION_EVENTS.enabled);\n    }\n    onDisable() {\n        this.cached = this.values;\n        this.subscriptions.clear();\n        this.topicMap.clear();\n        this.events.emit(SUBSCRIPTION_EVENTS.disabled);\n    }\n    setSubscription(id, subscription) {\n        const expiry = subscription.expiry || calcExpiry(SUBSCRIPTION_DEFAULT_TTL);\n        this.subscriptions.set(id, Object.assign(Object.assign({}, subscription), { expiry }));\n        this.topicMap.set(subscription.topic, id);\n        this.checkExpiry(id, expiry);\n    }\n    getSubscription(id) {\n        const subscription = this.subscriptions.get(id);\n        if (!subscription) {\n            const error = ERROR.NO_MATCHING_ID.format({\n                context: formatMessageContext(this.context),\n                id,\n            });\n            throw new Error(error.message);\n        }\n        return subscription;\n    }\n    deleteSubscription(id, subscription) {\n        this.subscriptions.delete(id);\n        this.topicMap.delete(subscription.topic, id);\n    }\n    checkExpiry(id, expiry) {\n        const msToTimeout = toMiliseconds(expiry) - Date.now();\n        if (msToTimeout <= 0)\n            this.expire(id);\n    }\n    expire(id) {\n        const reason = ERROR.EXPIRED.format({ context: formatMessageContext(this.context) });\n        const subscription = this.getSubscription(id);\n        this.deleteSubscription(id, subscription);\n        this.events.emit(SUBSCRIPTION_EVENTS.deleted, Object.assign(Object.assign({}, subscription), { reason }));\n    }\n    checkSubscriptions() {\n        this.subscriptions.forEach(subscription => this.checkExpiry(subscription.id, subscription.expiry));\n    }\n    async persist() {\n        await this.client.storage.setRelayerSubscriptions(this.context, this.values);\n        this.events.emit(SUBSCRIPTION_EVENTS.sync);\n    }\n    async restore() {\n        try {\n            const persisted = await this.client.storage.getRelayerSubscriptions(this.context);\n            if (typeof persisted === \"undefined\")\n                return;\n            if (!persisted.length)\n                return;\n            if (this.subscriptions.size) {\n                const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n                    context: formatMessageContext(this.context),\n                });\n                this.logger.error(error.message);\n                throw new Error(error.message);\n            }\n            this.cached = persisted;\n            this.logger.debug(`Successfully Restored subscriptions for ${formatMessageContext(this.context)}`);\n            this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Restore subscriptions for ${formatMessageContext(this.context)}`);\n            this.logger.error(e);\n        }\n    }\n    async initialize() {\n        await this.restore();\n        this.reset();\n        this.onInit();\n    }\n    onInit() {\n        this.onEnable();\n    }\n    async isEnabled() {\n        if (!this.cached.length)\n            return;\n        return new Promise(resolve => {\n            this.events.once(SUBSCRIPTION_EVENTS.enabled, () => resolve());\n        });\n    }\n    onExpiry(expiredEvent) {\n        const eventName = SUBSCRIPTION_EVENTS.expired;\n        this.logger.info(`Emitting ${eventName}`);\n        this.logger.debug({ type: \"event\", event: eventName, data: expiredEvent });\n        this.events.emit(SUBSCRIPTION_EVENTS.expired, expiredEvent);\n    }\n    registerEventListeners() {\n        this.client.on(CLIENT_EVENTS.beat, () => this.checkSubscriptions());\n        this.events.on(SUBSCRIPTION_EVENTS.created, async (createdEvent) => {\n            const eventName = SUBSCRIPTION_EVENTS.created;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n            await this.persist();\n        });\n        this.events.on(SUBSCRIPTION_EVENTS.deleted, async (deletedEvent) => {\n            const eventName = SUBSCRIPTION_EVENTS.deleted;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n            await this.persist();\n            if (deletedEvent.reason.code === ERROR.EXPIRED.code)\n                this.onExpiry(deletedEvent);\n        });\n    }\n}\n//# sourceMappingURL=subscription.js.map"]},"metadata":{},"sourceType":"module"}