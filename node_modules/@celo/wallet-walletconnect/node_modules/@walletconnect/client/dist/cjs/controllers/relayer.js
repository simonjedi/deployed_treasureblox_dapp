"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Relayer = void 0;
const tslib_1 = require("tslib");
const events_1 = require("events");
const logger_1 = require("@walletconnect/logger");
const types_1 = require("@walletconnect/types");
const relay_api_1 = require("@walletconnect/relay-api");
const utils_1 = require("@walletconnect/utils");
const jsonrpc_utils_1 = require("@walletconnect/jsonrpc-utils");
const jsonrpc_provider_1 = require("@walletconnect/jsonrpc-provider");
const jsonrpc_ws_connection_1 = require("@walletconnect/jsonrpc-ws-connection");
const subscription_1 = require("./subscription");
const constants_1 = require("../constants");
const history_1 = require("./history");
class Relayer extends types_1.IRelayer {
    constructor(client, logger, provider) {
        super(client, logger);
        this.client = client;
        this.logger = logger;
        this.events = new events_1.EventEmitter();
        this.name = constants_1.RELAYER_CONTEXT;
        this.logger = logger_1.generateChildLogger(logger, this.name);
        this.subscriptions = new subscription_1.Subscription(client, this.logger);
        this.history = new history_1.JsonRpcHistory(client, this.logger);
        this.provider = this.setProvider(provider);
        this.registerEventListeners();
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    get connected() {
        return this.provider.connection.connected;
    }
    get connecting() {
        return this.provider.connection.connecting;
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.trace(`Initialized`);
            yield this.history.init();
            yield this.provider.connect();
            yield this.subscriptions.init();
            yield this.resubscribe();
        });
    }
    publish(topic, payload, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Publishing Payload`);
            this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
            try {
                const message = yield this.client.crypto.encodeJsonRpc(topic, payload);
                const ttl = (opts === null || opts === void 0 ? void 0 : opts.ttl) || constants_1.RELAYER_DEFAULT_PUBLISH_TTL;
                const relay = this.getRelayProtocol(opts);
                yield this.rpcPublish(topic, message, ttl, relay);
                this.logger.debug(`Successfully Published Payload`);
                this.logger.trace({ type: "method", method: "publish", params: { topic, payload, opts } });
                yield this.recordPayloadEvent({ topic, payload });
            }
            catch (e) {
                this.logger.debug(`Failed to Publish Payload`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    subscribe(topic, expiry, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Subscribing Topic`);
            this.logger.trace({ type: "method", method: "subscribe", params: { topic, expiry, opts } });
            try {
                const relay = this.getRelayProtocol(opts);
                const id = yield this.rpcSubscribe(topic, relay);
                const subscription = { id, topic, expiry, relay };
                yield this.subscriptions.set(id, subscription);
                this.logger.debug(`Successfully Subscribed Topic`);
                this.logger.trace({ type: "method", method: "subscribe", params: { topic, expiry, opts } });
                return id;
            }
            catch (e) {
                this.logger.debug(`Failed to Subscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    unsubscribe(topic, id, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Unsubscribing Topic`);
            this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
            try {
                const relay = this.getRelayProtocol(opts);
                yield this.rpcUnsubscribe(topic, id, relay);
                const reason = utils_1.ERROR.DELETED.format({ context: utils_1.formatMessageContext(this.context) });
                yield this.onUnsubscribe(topic, id, reason);
                this.logger.debug(`Successfully Unsubscribed Topic`);
                this.logger.trace({ type: "method", method: "unsubscribe", params: { topic, id, opts } });
            }
            catch (e) {
                this.logger.debug(`Failed to Unsubscribe Topic`);
                this.logger.error(e);
                throw e;
            }
        });
    }
    unsubscribeByTopic(topic, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const ids = this.subscriptions.topicMap.get(topic);
            yield Promise.all(ids.map((id) => tslib_1.__awaiter(this, void 0, void 0, function* () { return yield this.unsubscribe(topic, id, opts); })));
        });
    }
    on(event, listener) {
        this.events.on(event, listener);
    }
    once(event, listener) {
        this.events.once(event, listener);
    }
    off(event, listener) {
        this.events.off(event, listener);
    }
    removeListener(event, listener) {
        this.events.removeListener(event, listener);
    }
    getRelayProtocol(opts) {
        return (opts === null || opts === void 0 ? void 0 : opts.relay) || { protocol: constants_1.RELAYER_DEFAULT_PROTOCOL };
    }
    rpcPublish(topic, message, ttl, relay) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);
            const request = {
                method: jsonRpc.publish,
                params: {
                    topic,
                    message,
                    ttl,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            return this.provider.request(request);
        });
    }
    rpcSubscribe(topic, relay) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);
            const request = {
                method: jsonRpc.subscribe,
                params: {
                    topic,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            return this.provider.request(request);
        });
    }
    rpcUnsubscribe(topic, id, relay) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const jsonRpc = getRelayProtocolJsonRpc(relay.protocol);
            const request = {
                method: jsonRpc.unsubscribe,
                params: {
                    topic,
                    id,
                },
            };
            this.logger.debug(`Outgoing Relay Payload`);
            this.logger.trace({ type: "payload", direction: "outgoing", request });
            return this.provider.request(request);
        });
    }
    onUnsubscribe(topic, id, reason) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.events.removeAllListeners(id);
            if (yield this.subscriptions.exists(id, topic)) {
                yield this.subscriptions.delete(id, reason);
            }
            yield this.history.delete(topic);
        });
    }
    recordPayloadEvent(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                yield this.history.set(topic, payload);
            }
            else {
                yield this.history.resolve(payload);
            }
        });
    }
    shouldIgnorePayloadEvent(payloadEvent) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, payload } = payloadEvent;
            if (!this.subscriptions.topics.includes(topic))
                return true;
            let exists = false;
            try {
                if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                    exists = yield this.history.exists(topic, payload.id);
                }
                else {
                    let record;
                    try {
                        record = yield this.history.get(topic, payload.id);
                    }
                    catch (e) {
                    }
                    exists = typeof record !== "undefined" && typeof record.response !== "undefined";
                }
            }
            catch (e) {
            }
            return exists;
        });
    }
    onPayload(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.logger.debug(`Incoming Relay Payload`);
            this.logger.trace({ type: "payload", direction: "incoming", payload });
            if (jsonrpc_utils_1.isJsonRpcRequest(payload)) {
                if (!payload.method.endsWith(constants_1.RELAYER_SUBSCRIPTION_SUFFIX))
                    return;
                const event = payload.params;
                const { topic, message } = event.data;
                const payloadEvent = {
                    topic,
                    payload: yield this.client.crypto.decodeJsonRpc(topic, message),
                };
                if (yield this.shouldIgnorePayloadEvent(payloadEvent))
                    return;
                this.logger.debug(`Emitting Relayer Payload`);
                this.logger.trace(Object.assign({ type: "event", event: event.id }, payloadEvent));
                this.events.emit(event.id, payloadEvent);
                this.events.emit(constants_1.RELAYER_EVENTS.payload, payloadEvent);
                yield this.acknowledgePayload(payload);
                yield this.recordPayloadEvent(payloadEvent);
            }
        });
    }
    acknowledgePayload(payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const response = jsonrpc_utils_1.formatJsonRpcResult(payload.id, true);
            yield this.provider.connection.send(response);
        });
    }
    resubscribe() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield Promise.all(this.subscriptions.values.map((subscription) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                const id = yield this.rpcSubscribe(subscription.topic, subscription.relay);
                yield this.subscriptions.set(id, Object.assign(Object.assign({}, subscription), { id }));
                const reason = utils_1.ERROR.RESUBSCRIBED.format({ topic: subscription.topic });
                yield this.subscriptions.delete(subscription.id, reason);
            })));
        });
    }
    onConnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.subscriptions.enable();
            yield this.resubscribe();
        });
    }
    onDisconnect() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.subscriptions.disable();
            setTimeout(() => {
                this.provider.connect();
            }, constants_1.RELAYER_RECONNECT_TIMEOUT);
        });
    }
    setProvider(provider) {
        this.logger.debug(`Setting Relay Provider`);
        this.logger.trace({ type: "method", method: "setProvider", provider: provider === null || provider === void 0 ? void 0 : provider.toString() });
        const rpcUrl = utils_1.formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === "string" ? provider : constants_1.RELAYER_DEFAULT_RPC_URL, this.client.apiKey);
        return typeof provider !== "string" && typeof provider !== "undefined"
            ? provider
            : new jsonrpc_provider_1.JsonRpcProvider(new jsonrpc_ws_connection_1.WsConnection(rpcUrl));
    }
    registerEventListeners() {
        this.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.payload, (payload) => this.onPayload(payload));
        this.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.connect, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.onConnect();
            this.events.emit(constants_1.RELAYER_EVENTS.connect);
        }));
        this.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.disconnect, () => tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.onDisconnect();
            this.events.emit(constants_1.RELAYER_EVENTS.disconnect);
        }));
        this.provider.on(constants_1.RELAYER_PROVIDER_EVENTS.error, e => this.events.emit(constants_1.RELAYER_EVENTS.error, e));
        this.subscriptions.on(constants_1.SUBSCRIPTION_EVENTS.expired, (expiredEvent) => tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { topic, id, relay } = expiredEvent;
            yield this.rpcUnsubscribe(topic, id, relay);
            yield this.onUnsubscribe(topic, id, expiredEvent.reason);
        }));
    }
}
exports.Relayer = Relayer;
function getRelayProtocolJsonRpc(protocol) {
    const jsonrpc = relay_api_1.RELAY_JSONRPC[protocol];
    if (typeof jsonrpc === "undefined") {
        throw new Error(`Relay Protocol not supported: ${protocol}`);
    }
    return jsonrpc;
}
//# sourceMappingURL=relayer.js.map