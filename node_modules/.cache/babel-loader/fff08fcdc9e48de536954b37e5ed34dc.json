{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst abi_coder_1 = require(\"@meterio/ethers/utils/abi-coder\");\n\nconst keccak_1 = require(\"./cry/keccak\");\n\nclass Coder extends abi_coder_1.AbiCoder {\n  constructor() {\n    super((type, value) => {\n      if (type.match(/^u?int/) && !Array.isArray(value) && typeof value !== 'object' || value._ethersType === 'BigNumber') {\n        return value.toString();\n      }\n\n      return value;\n    });\n  }\n\n  encode(types, values) {\n    try {\n      return super.encode(types, values);\n    } catch (err) {\n      if (err.reason) {\n        throw new Error(err.reason);\n      }\n\n      throw err;\n    }\n  }\n\n  decode(types, data) {\n    try {\n      return super.decode(types, data);\n    } catch (err) {\n      if (err.reason) {\n        throw new Error(err.reason);\n      }\n\n      throw err;\n    }\n  }\n\n}\n\nconst coder = new Coder();\n\nfunction formatSignature(fragment) {\n  try {\n    return abi_coder_1.formatSignature(fragment);\n  } catch (err) {\n    if (err.reason) {\n      throw new Error(err.reason);\n    }\n\n    throw err;\n  }\n}\n/** encode/decode parameters of contract function call, event log, according to ABI JSON */\n\n\nvar abi;\n\n(function (abi) {\n  /**\n   * encode single parameter\n   * @param type type of the parameter\n   * @param value value of the parameter\n   * @returns encoded value in hex string\n   */\n  function encodeParameter(type, value) {\n    return coder.encode([type], [value]);\n  }\n\n  abi.encodeParameter = encodeParameter;\n  /**\n   * decode single parameter\n   * @param type type of the parameter\n   * @param data encoded parameter in hex string\n   * @returns decoded value\n   */\n\n  function decodeParameter(type, data) {\n    return coder.decode([type], data)[0];\n  }\n\n  abi.decodeParameter = decodeParameter;\n  /**\n   * encode a group of parameters\n   * @param types type array\n   * @param values value array\n   * @returns encoded values in hex string\n   */\n\n  function encodeParameters(types, values) {\n    return coder.encode(types.map(p => p.type), values);\n  }\n\n  abi.encodeParameters = encodeParameters;\n  /**\n   * decode a group of parameters\n   * @param types type array\n   * @param data encoded values in hex string\n   * @returns decoded object\n   */\n\n  function decodeParameters(types, data) {\n    const result = coder.decode(types.map(p => p.type), data);\n    const decoded = {};\n    types.forEach((t, i) => {\n      decoded[i] = result[i];\n\n      if (t.name) {\n        decoded[t.name] = result[i];\n      }\n    });\n    return decoded;\n  }\n\n  abi.decodeParameters = decodeParameters;\n  /** for contract function */\n\n  class Function {\n    /**\n     * create a function object\n     * @param definition abi definition of the function\n     */\n    constructor(definition) {\n      this.definition = definition;\n      this.canonicalName = formatSignature(definition);\n      this.signature = '0x' + keccak_1.keccak256(this.canonicalName).slice(0, 4).toString('hex');\n    }\n    /**\n     * encode input parameters into call data\n     * @param args arguments for the function\n     */\n\n\n    encode(...args) {\n      return this.signature + encodeParameters(this.definition.inputs, args).slice(2);\n    }\n    /**\n     * decode output data\n     * @param outputData output data to decode\n     */\n\n\n    decode(outputData) {\n      return decodeParameters(this.definition.outputs, outputData);\n    }\n\n  }\n\n  abi.Function = Function;\n  /** for contract event */\n\n  class Event {\n    /** for contract event */\n    constructor(definition) {\n      this.definition = definition;\n      this.canonicalName = formatSignature(definition);\n      this.signature = '0x' + keccak_1.keccak256(this.canonicalName).toString('hex');\n    }\n    /**\n     * encode an object of indexed keys into topics.\n     * @param indexed an object contains indexed keys\n     */\n\n\n    encode(indexed) {\n      const topics = [];\n\n      if (!this.definition.anonymous) {\n        topics.push(this.signature);\n      }\n\n      for (const input of this.definition.inputs) {\n        if (!input.indexed) {\n          continue;\n        }\n\n        const value = indexed[input.name];\n\n        if (value === undefined || value === null) {\n          topics.push(null);\n        } else {\n          let topic;\n\n          if (isDynamicType(input.type)) {\n            if (input.type === 'string') {\n              topic = '0x' + keccak_1.keccak256(value).toString('hex');\n            } else {\n              if (typeof value === 'string' && /^0x[0-9a-f]+$/i.test(value) && value.length % 2 === 0) {\n                topic = '0x' + keccak_1.keccak256(Buffer.from(value.slice(2), 'hex')).toString('hex');\n              } else {\n                throw new Error(`invalid ${input.type} value`);\n              }\n            }\n          } else {\n            topic = encodeParameter(input.type, value);\n          }\n\n          topics.push(topic);\n        }\n      }\n\n      return topics;\n    }\n    /**\n     * decode event log\n     * @param data data in event output\n     * @param topics topics in event\n     */\n\n\n    decode(data, topics) {\n      if (!this.definition.anonymous) {\n        topics = topics.slice(1);\n      }\n\n      if (this.definition.inputs.filter(t => t.indexed).length !== topics.length) {\n        throw new Error('invalid topics count');\n      }\n\n      const decodedNonIndexed = coder.decode(this.definition.inputs.filter(t => !t.indexed).map(t => t.type), data);\n      const decoded = {};\n      this.definition.inputs.forEach((t, i) => {\n        if (t.indexed) {\n          const topic = topics.shift();\n          decoded[i] = isDynamicType(t.type) ? topic : decodeParameter(t.type, topic);\n        } else {\n          decoded[i] = decodedNonIndexed.shift();\n        }\n\n        if (t.name) {\n          decoded[t.name] = decoded[i];\n        }\n      });\n      return decoded;\n    }\n\n  }\n\n  abi.Event = Event;\n\n  function isDynamicType(type) {\n    return type === 'bytes' || type === 'string' || type.endsWith('[]');\n  }\n})(abi = exports.abi || (exports.abi = {}));","map":{"version":3,"sources":["../src/abi.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abi_coder_1 = require(\"@meterio/ethers/utils/abi-coder\");\nconst keccak_1 = require(\"./cry/keccak\");\nclass Coder extends abi_coder_1.AbiCoder {\n    constructor() {\n        super((type, value) => {\n            if ((type.match(/^u?int/) && !Array.isArray(value) && typeof value !== 'object') ||\n                value._ethersType === 'BigNumber') {\n                return value.toString();\n            }\n            return value;\n        });\n    }\n    encode(types, values) {\n        try {\n            return super.encode(types, values);\n        }\n        catch (err) {\n            if (err.reason) {\n                throw new Error(err.reason);\n            }\n            throw err;\n        }\n    }\n    decode(types, data) {\n        try {\n            return super.decode(types, data);\n        }\n        catch (err) {\n            if (err.reason) {\n                throw new Error(err.reason);\n            }\n            throw err;\n        }\n    }\n}\nconst coder = new Coder();\nfunction formatSignature(fragment) {\n    try {\n        return abi_coder_1.formatSignature(fragment);\n    }\n    catch (err) {\n        if (err.reason) {\n            throw new Error(err.reason);\n        }\n        throw err;\n    }\n}\n/** encode/decode parameters of contract function call, event log, according to ABI JSON */\nvar abi;\n(function (abi) {\n    /**\n     * encode single parameter\n     * @param type type of the parameter\n     * @param value value of the parameter\n     * @returns encoded value in hex string\n     */\n    function encodeParameter(type, value) {\n        return coder.encode([type], [value]);\n    }\n    abi.encodeParameter = encodeParameter;\n    /**\n     * decode single parameter\n     * @param type type of the parameter\n     * @param data encoded parameter in hex string\n     * @returns decoded value\n     */\n    function decodeParameter(type, data) {\n        return coder.decode([type], data)[0];\n    }\n    abi.decodeParameter = decodeParameter;\n    /**\n     * encode a group of parameters\n     * @param types type array\n     * @param values value array\n     * @returns encoded values in hex string\n     */\n    function encodeParameters(types, values) {\n        return coder.encode(types.map((p) => p.type), values);\n    }\n    abi.encodeParameters = encodeParameters;\n    /**\n     * decode a group of parameters\n     * @param types type array\n     * @param data encoded values in hex string\n     * @returns decoded object\n     */\n    function decodeParameters(types, data) {\n        const result = coder.decode(types.map((p) => p.type), data);\n        const decoded = {};\n        types.forEach((t, i) => {\n            decoded[i] = result[i];\n            if (t.name) {\n                decoded[t.name] = result[i];\n            }\n        });\n        return decoded;\n    }\n    abi.decodeParameters = decodeParameters;\n    /** for contract function */\n    class Function {\n        /**\n         * create a function object\n         * @param definition abi definition of the function\n         */\n        constructor(definition) {\n            this.definition = definition;\n            this.canonicalName = formatSignature(definition);\n            this.signature = '0x' + keccak_1.keccak256(this.canonicalName).slice(0, 4).toString('hex');\n        }\n        /**\n         * encode input parameters into call data\n         * @param args arguments for the function\n         */\n        encode(...args) {\n            return this.signature + encodeParameters(this.definition.inputs, args).slice(2);\n        }\n        /**\n         * decode output data\n         * @param outputData output data to decode\n         */\n        decode(outputData) {\n            return decodeParameters(this.definition.outputs, outputData);\n        }\n    }\n    abi.Function = Function;\n    /** for contract event */\n    class Event {\n        /** for contract event */\n        constructor(definition) {\n            this.definition = definition;\n            this.canonicalName = formatSignature(definition);\n            this.signature = '0x' + keccak_1.keccak256(this.canonicalName).toString('hex');\n        }\n        /**\n         * encode an object of indexed keys into topics.\n         * @param indexed an object contains indexed keys\n         */\n        encode(indexed) {\n            const topics = [];\n            if (!this.definition.anonymous) {\n                topics.push(this.signature);\n            }\n            for (const input of this.definition.inputs) {\n                if (!input.indexed) {\n                    continue;\n                }\n                const value = indexed[input.name];\n                if (value === undefined || value === null) {\n                    topics.push(null);\n                }\n                else {\n                    let topic;\n                    if (isDynamicType(input.type)) {\n                        if (input.type === 'string') {\n                            topic = '0x' + keccak_1.keccak256(value).toString('hex');\n                        }\n                        else {\n                            if (typeof value === 'string' &&\n                                /^0x[0-9a-f]+$/i.test(value) &&\n                                value.length % 2 === 0) {\n                                topic = '0x' + keccak_1.keccak256(Buffer.from(value.slice(2), 'hex')).toString('hex');\n                            }\n                            else {\n                                throw new Error(`invalid ${input.type} value`);\n                            }\n                        }\n                    }\n                    else {\n                        topic = encodeParameter(input.type, value);\n                    }\n                    topics.push(topic);\n                }\n            }\n            return topics;\n        }\n        /**\n         * decode event log\n         * @param data data in event output\n         * @param topics topics in event\n         */\n        decode(data, topics) {\n            if (!this.definition.anonymous) {\n                topics = topics.slice(1);\n            }\n            if (this.definition.inputs.filter((t) => t.indexed).length !== topics.length) {\n                throw new Error('invalid topics count');\n            }\n            const decodedNonIndexed = coder.decode(this.definition.inputs.filter((t) => !t.indexed).map((t) => t.type), data);\n            const decoded = {};\n            this.definition.inputs.forEach((t, i) => {\n                if (t.indexed) {\n                    const topic = topics.shift();\n                    decoded[i] = isDynamicType(t.type) ? topic : decodeParameter(t.type, topic);\n                }\n                else {\n                    decoded[i] = decodedNonIndexed.shift();\n                }\n                if (t.name) {\n                    decoded[t.name] = decoded[i];\n                }\n            });\n            return decoded;\n        }\n    }\n    abi.Event = Event;\n    function isDynamicType(type) {\n        return type === 'bytes' || type === 'string' || type.endsWith('[]');\n    }\n})(abi = exports.abi || (exports.abi = {}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWJpLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL2FiaS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLCtEQUFnRztBQUNoRyx5Q0FBeUM7QUFFekMsTUFBTSxLQUFNLFNBQVEsb0JBQVE7SUFDMUI7UUFDRSxLQUFLLENBQUMsQ0FBQyxJQUFJLEVBQUUsS0FBSyxFQUFFLEVBQUU7WUFDcEIsSUFDRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztnQkFDNUUsS0FBSyxDQUFDLFdBQVcsS0FBSyxXQUFXLEVBQ2pDO2dCQUNBLE9BQU8sS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO2FBQ3pCO1lBQ0QsT0FBTyxLQUFLLENBQUM7UUFDZixDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTSxNQUFNLENBQUMsS0FBZSxFQUFFLE1BQWE7UUFDMUMsSUFBSTtZQUNGLE9BQU8sS0FBSyxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUUsTUFBTSxDQUFDLENBQUM7U0FDcEM7UUFBQyxPQUFPLEdBQUcsRUFBRTtZQUNaLElBQUksR0FBRyxDQUFDLE1BQU0sRUFBRTtnQkFDZCxNQUFNLElBQUksS0FBSyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUM3QjtZQUNELE1BQU0sR0FBRyxDQUFDO1NBQ1g7SUFDSCxDQUFDO0lBRU0sTUFBTSxDQUFDLEtBQWUsRUFBRSxJQUFZO1FBQ3pDLElBQUk7WUFDRixPQUFPLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1NBQ2xDO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixJQUFJLEdBQUcsQ0FBQyxNQUFNLEVBQUU7Z0JBQ2QsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7YUFDN0I7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"]},"metadata":{},"sourceType":"script"}