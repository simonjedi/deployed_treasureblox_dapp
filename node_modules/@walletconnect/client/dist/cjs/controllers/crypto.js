"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Crypto = exports.KeyChain = void 0;
const tslib_1 = require("tslib");
const encoding = tslib_1.__importStar(require("@walletconnect/encoding"));
const logger_1 = require("@walletconnect/logger");
const safe_json_1 = require("@walletconnect/safe-json");
const utils_1 = require("@walletconnect/utils");
const constants_1 = require("../constants");
class KeyChain {
    constructor(client, logger) {
        this.client = client;
        this.logger = logger;
        this.keychain = new Map();
        this.name = constants_1.KEYCHAIN_CONTEXT;
        this.client = client;
        this.logger = logger_1.generateChildLogger(logger, this.name);
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.restore();
        });
    }
    has(tag, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.keychain.has(tag);
        });
    }
    set(tag, key, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.keychain.set(tag, key);
            yield this.persist();
        });
    }
    get(tag, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const key = this.keychain.get(tag);
            if (typeof key === "undefined") {
                throw new Error(utils_1.ERROR.NO_MATCHING_KEY.format({ tag }).message);
            }
            return key;
        });
    }
    del(tag, opts) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.keychain.delete(tag);
            yield this.persist();
        });
    }
    restore() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keychain = yield this.client.storage.getKeyChain(this.context);
            if (typeof keychain !== "undefined") {
                this.keychain = keychain;
            }
        });
    }
    persist() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.client.storage.setKeyChain(this.context, this.keychain);
        });
    }
}
exports.KeyChain = KeyChain;
class Crypto {
    constructor(client, logger, keychain) {
        this.client = client;
        this.logger = logger;
        this.name = constants_1.CRYPTO_CONTEXT;
        this.client = client;
        this.logger = logger_1.generateChildLogger(logger, this.name);
        this.keychain = keychain || new KeyChain(this.client, this.logger);
    }
    get context() {
        return logger_1.getLoggerContext(this.logger);
    }
    init() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.keychain.init();
        });
    }
    hasKeys(tag) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            return this.keychain.has(tag);
        });
    }
    generateKeyPair() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keyPair = utils_1.generateKeyPair();
            return this.setKeyPair(keyPair);
        });
    }
    generateSharedKey(self, peer, overrideTopic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keyPair = yield this.getKeyPair(self.publicKey);
            const sharedKey = utils_1.deriveSharedKey(keyPair.privateKey, peer.publicKey);
            return this.setEncryptionKeys({ sharedKey, publicKey: keyPair.publicKey }, overrideTopic);
        });
    }
    encrypt(topic, message) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { sharedKey, publicKey } = yield this.getEncryptionKeys(topic);
            const result = yield utils_1.encrypt({ message, sharedKey, publicKey });
            return result;
        });
    }
    decrypt(topic, encrypted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { sharedKey } = yield this.getEncryptionKeys(topic);
            const result = yield utils_1.decrypt({ encrypted, sharedKey });
            return result;
        });
    }
    encodeJsonRpc(topic, payload) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const message = safe_json_1.safeJsonStringify(payload);
            const hasKeys = yield this.hasKeys(topic);
            const result = hasKeys ? yield this.encrypt(topic, message) : encoding.utf8ToHex(message);
            return result;
        });
    }
    decodeJsonRpc(topic, encrypted) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const hasKeys = yield this.hasKeys(topic);
            const message = hasKeys ? yield this.decrypt(topic, encrypted) : encoding.hexToUtf8(encrypted);
            const payload = safe_json_1.safeJsonParse(message);
            return payload;
        });
    }
    concatKeys(keyA, keyB) {
        return encoding.arrayToHex(encoding.concatArrays(encoding.hexToArray(keyA), encoding.hexToArray(keyB)));
    }
    splitKeys(keys) {
        const arr = encoding.hexToArray(keys);
        return [encoding.arrayToHex(arr.slice(0, 32)), encoding.arrayToHex(arr.slice(32, 64))];
    }
    setKeyPair(keyPair) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const keys = this.concatKeys(keyPair.publicKey, keyPair.privateKey);
            yield this.keychain.set(keyPair.publicKey, keys);
            return keyPair.publicKey;
        });
    }
    getKeyPair(publicKey) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [_, privateKey] = this.splitKeys(yield this.keychain.get(publicKey));
            return { publicKey, privateKey };
        });
    }
    setEncryptionKeys(encryptionKeys, overrideTopic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const topic = overrideTopic || (yield utils_1.sha256(encryptionKeys.sharedKey));
            const keys = this.concatKeys(encryptionKeys.sharedKey, encryptionKeys.publicKey);
            yield this.keychain.set(topic, keys);
            return topic;
        });
    }
    getEncryptionKeys(topic) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const [sharedKey, publicKey] = this.splitKeys(yield this.keychain.get(topic));
            return { sharedKey, publicKey };
        });
    }
}
exports.Crypto = Crypto;
//# sourceMappingURL=crypto.js.map