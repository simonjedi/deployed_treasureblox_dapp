{"code":"(this[\"webpackJsonptreasure-blox\"]=this[\"webpackJsonptreasure-blox\"]||[]).push([[15],{1354:function(e,t,n){\"use strict\";n.r(t),n.d(t,\"InjectedConnector\",(function(){return p})),n.d(t,\"NoEthereumProviderError\",(function(){return l})),n.d(t,\"UserRejectedRequestError\",(function(){return m}));var r=n(631);function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(e[r]=n[r])}return e}).apply(this,arguments)}function i(e,t){e.prototype=Object.create(t.prototype),e.prototype.constructor=e,e.__proto__=t}function u(e){return(u=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function c(e,t){return(c=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function h(){if(\"undefined\"===typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if(\"function\"===typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}function a(e,t,n){return(a=h()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var o=new(Function.bind.apply(e,r));return n&&c(o,n.prototype),o}).apply(null,arguments)}function s(e){var t=\"function\"===typeof Map?new Map:void 0;return(s=function(e){if(null===e||(n=e,-1===Function.toString.call(n).indexOf(\"[native code]\")))return e;var n;if(\"function\"!==typeof e)throw new TypeError(\"Super expression must either be null or a function\");if(\"undefined\"!==typeof t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return a(e,arguments,u(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),c(r,e)})(e)}function d(e){if(void 0===e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return e}\"undefined\"!==typeof Symbol&&(Symbol.iterator||(Symbol.iterator=Symbol(\"Symbol.iterator\"))),\"undefined\"!==typeof Symbol&&(Symbol.asyncIterator||(Symbol.asyncIterator=Symbol(\"Symbol.asyncIterator\")));function f(e,t){try{var n=e()}catch(r){return t(r)}return n&&n.then?n.then(void 0,t):n}function w(e){return e.hasOwnProperty(\"result\")?e.result:e}var l=function(e){function t(){var t;return(t=e.call(this)||this).name=t.constructor.name,t.message=\"No Ethereum provider was found on window.ethereum.\",t}return i(t,e),t}(s(Error)),m=function(e){function t(){var t;return(t=e.call(this)||this).name=t.constructor.name,t.message=\"The user rejected the request.\",t}return i(t,e),t}(s(Error)),p=function(e){function t(t){var n;return(n=e.call(this,t)||this).handleNetworkChanged=n.handleNetworkChanged.bind(d(n)),n.handleChainChanged=n.handleChainChanged.bind(d(n)),n.handleAccountsChanged=n.handleAccountsChanged.bind(d(n)),n.handleClose=n.handleClose.bind(d(n)),n}i(t,e);var n=t.prototype;return n.handleChainChanged=function(e){this.emitUpdate({chainId:e,provider:window.ethereum})},n.handleAccountsChanged=function(e){0===e.length?this.emitDeactivate():this.emitUpdate({account:e[0]})},n.handleClose=function(e,t){this.emitDeactivate()},n.handleNetworkChanged=function(e){this.emitUpdate({chainId:e,provider:window.ethereum})},n.activate=function(){try{var e,t=function(t){if(n)return t;function r(){return o({provider:window.ethereum},e?{account:e}:{})}var i=function(){if(!e)return Promise.resolve(window.ethereum.enable().then((function(e){return e&&w(e)[0]}))).then((function(t){e=t}))}();return i&&i.then?i.then(r):r()},n=!1,r=this;if(!window.ethereum)throw new l;window.ethereum.on&&(window.ethereum.on(\"chainChanged\",r.handleChainChanged),window.ethereum.on(\"accountsChanged\",r.handleAccountsChanged),window.ethereum.on(\"close\",r.handleClose),window.ethereum.on(\"networkChanged\",r.handleNetworkChanged)),window.ethereum.isMetaMask&&(window.ethereum.autoRefreshOnNetworkChange=!1);var i=f((function(){return Promise.resolve(window.ethereum.send(\"eth_requestAccounts\").then((function(e){return w(e)[0]}))).then((function(t){e=t}))}),(function(e){if(4001===e.code)throw new m}));return Promise.resolve(i&&i.then?i.then(t):t(i))}catch(u){return Promise.reject(u)}},n.getProvider=function(){try{return Promise.resolve(window.ethereum)}catch(e){return Promise.reject(e)}},n.getChainId=function(){try{var e,t=function(){function t(){if(!e)try{e=w(window.ethereum.send({method:\"net_version\"}))}catch(t){}return e||(e=window.ethereum.isDapper?w(window.ethereum.cachedResults.net_version):window.ethereum.chainId||window.ethereum.netVersion||window.ethereum.networkVersion||window.ethereum._chainId),e}var n=function(){if(!e){var t=f((function(){return Promise.resolve(window.ethereum.send(\"net_version\").then(w)).then((function(t){e=t}))}),(function(){}));if(t&&t.then)return t.then((function(){}))}}();return n&&n.then?n.then(t):t()};if(!window.ethereum)throw new l;var n=f((function(){return Promise.resolve(window.ethereum.send(\"eth_chainId\").then(w)).then((function(t){e=t}))}),(function(){}));return Promise.resolve(n&&n.then?n.then(t):t())}catch(r){return Promise.reject(r)}},n.getAccount=function(){try{var e,t=function(){function t(){return e||(e=w(window.ethereum.send({method:\"eth_accounts\"}))[0]),e}var n=function(){if(!e){var t=f((function(){return Promise.resolve(window.ethereum.enable().then((function(e){return w(e)[0]}))).then((function(t){e=t}))}),(function(){}));if(t&&t.then)return t.then((function(){}))}}();return n&&n.then?n.then(t):t()};if(!window.ethereum)throw new l;var n=f((function(){return Promise.resolve(window.ethereum.send(\"eth_accounts\").then((function(e){return w(e)[0]}))).then((function(t){e=t}))}),(function(){}));return Promise.resolve(n&&n.then?n.then(t):t())}catch(r){return Promise.reject(r)}},n.deactivate=function(){window.ethereum&&window.ethereum.removeListener&&(window.ethereum.removeListener(\"chainChanged\",this.handleChainChanged),window.ethereum.removeListener(\"accountsChanged\",this.handleAccountsChanged),window.ethereum.removeListener(\"close\",this.handleClose),window.ethereum.removeListener(\"networkChanged\",this.handleNetworkChanged))},n.isAuthorized=function(){try{return window.ethereum?Promise.resolve(f((function(){return Promise.resolve(window.ethereum.send(\"eth_accounts\").then((function(e){return w(e).length>0})))}),(function(){return!1}))):Promise.resolve(!1)}catch(e){return Promise.reject(e)}},t}(r.a)},631:function(e,t,n){\"use strict\";n.d(t,\"a\",(function(){return i}));var r=n(59),o=n(70);var i=function(e){var t,n;function r(t){var n,r=(void 0===t?{}:t).supportedChainIds;return(n=e.call(this)||this).supportedChainIds=r,n}n=e,(t=r).prototype=Object.create(n.prototype),t.prototype.constructor=t,t.__proto__=n;var i=r.prototype;return i.emitUpdate=function(e){this.emit(o.a.Update,e)},i.emitError=function(e){this.emit(o.a.Error,e)},i.emitDeactivate=function(){this.emit(o.a.Deactivate)},r}(r.EventEmitter)}}]);","name":"static/js/15.32728fe7.chunk.js","map":{"version":3,"sources":["static/js/15.32728fe7.chunk.js"],"names":["this","push","module","__webpack_exports__","__webpack_require__","r","d","InjectedConnector","NoEthereumProviderError","UserRejectedRequestError","_web3_react_abstract_connector__WEBPACK_IMPORTED_MODULE_0__","_extends","Object","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","_inheritsLoose","subClass","superClass","create","constructor","__proto__","_getPrototypeOf","o","setPrototypeOf","getPrototypeOf","_setPrototypeOf","p","isNativeReflectConstruct","Reflect","construct","sham","Proxy","Date","toString","e","_construct","Parent","args","Class","a","instance","Function","bind","_wrapNativeSuper","_cache","Map","undefined","fn","indexOf","TypeError","has","get","set","Wrapper","value","enumerable","writable","configurable","_assertThisInitialized","self","ReferenceError","Symbol","iterator","asyncIterator","_catch","body","recover","result","then","parseSendReturn","sendReturn","_Error","_this","name","message","Error","_Error2","_this2","_AbstractConnector","kwargs","_this3","handleNetworkChanged","handleChainChanged","handleAccountsChanged","handleClose","_proto","chainId","emitUpdate","provider","window","ethereum","accounts","emitDeactivate","account","code","reason","networkId","activate","_temp5","_result","_exit2","_temp2","_temp","Promise","resolve","enable","_window$ethereum$enab","_this5","on","isMetaMask","autoRefreshOnNetworkChange","_temp6","send","_window$ethereum$send","error","reject","getProvider","getChainId","_temp12","_temp9","method","_unused","isDapper","cachedResults","net_version","netVersion","networkVersion","_chainId","_temp8","_temp14","_window$ethereum$send3","_temp13","_window$ethereum$send2","getAccount","_temp20","_temp17","_temp16","_temp22","_window$ethereum$enab2","_temp21","_window$ethereum$send4","deactivate","removeListener","isAuthorized","AbstractConnector","events__WEBPACK_IMPORTED_MODULE_0__","_web3_react_types__WEBPACK_IMPORTED_MODULE_1__","_EventEmitter","supportedChainIds","update","emit","Update","emitError","Deactivate"],"mappings":"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"},"input":"(this[\"webpackJsonptreasure-blox\"] = this[\"webpackJsonptreasure-blox\"] || []).push([[15],{\n\n/***/ 1354:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InjectedConnector\", function() { return InjectedConnector; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NoEthereumProviderError\", function() { return NoEthereumProviderError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UserRejectedRequestError\", function() { return UserRejectedRequestError; });\n/* harmony import */ var _web3_react_abstract_connector__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(631);\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nfunction _getPrototypeOf(o) {\n  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nfunction _setPrototypeOf(o, p) {\n  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    _construct = Reflect.construct;\n  } else {\n    _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) _setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nfunction _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !_isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return _construct(Class, arguments, _getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return _setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nfunction _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n} // A type of promise-like that resolves synchronously and supports only one observer\n\n\nvar _iteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.iterator || (Symbol.iterator = /*#__PURE__*/Symbol(\"Symbol.iterator\")) : \"@@iterator\"; // Asynchronously iterate through an object's values\n\n\nvar _asyncIteratorSymbol = /*#__PURE__*/typeof Symbol !== \"undefined\" ? Symbol.asyncIterator || (Symbol.asyncIterator = /*#__PURE__*/Symbol(\"Symbol.asyncIterator\")) : \"@@asyncIterator\"; // Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\n\n\nfunction _catch(body, recover) {\n  try {\n    var result = body();\n  } catch (e) {\n    return recover(e);\n  }\n\n  if (result && result.then) {\n    return result.then(void 0, recover);\n  }\n\n  return result;\n} // Asynchronously await a promise and pass the result to a finally continuation\n\n\nfunction parseSendReturn(sendReturn) {\n  return sendReturn.hasOwnProperty('result') ? sendReturn.result : sendReturn;\n}\n\nvar NoEthereumProviderError = /*#__PURE__*/function (_Error) {\n  _inheritsLoose(NoEthereumProviderError, _Error);\n\n  function NoEthereumProviderError() {\n    var _this;\n\n    _this = _Error.call(this) || this;\n    _this.name = _this.constructor.name;\n    _this.message = 'No Ethereum provider was found on window.ethereum.';\n    return _this;\n  }\n\n  return NoEthereumProviderError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar UserRejectedRequestError = /*#__PURE__*/function (_Error2) {\n  _inheritsLoose(UserRejectedRequestError, _Error2);\n\n  function UserRejectedRequestError() {\n    var _this2;\n\n    _this2 = _Error2.call(this) || this;\n    _this2.name = _this2.constructor.name;\n    _this2.message = 'The user rejected the request.';\n    return _this2;\n  }\n\n  return UserRejectedRequestError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nvar InjectedConnector = /*#__PURE__*/function (_AbstractConnector) {\n  _inheritsLoose(InjectedConnector, _AbstractConnector);\n\n  function InjectedConnector(kwargs) {\n    var _this3;\n\n    _this3 = _AbstractConnector.call(this, kwargs) || this;\n    _this3.handleNetworkChanged = _this3.handleNetworkChanged.bind(_assertThisInitialized(_this3));\n    _this3.handleChainChanged = _this3.handleChainChanged.bind(_assertThisInitialized(_this3));\n    _this3.handleAccountsChanged = _this3.handleAccountsChanged.bind(_assertThisInitialized(_this3));\n    _this3.handleClose = _this3.handleClose.bind(_assertThisInitialized(_this3));\n    return _this3;\n  }\n\n  var _proto = InjectedConnector.prototype;\n\n  _proto.handleChainChanged = function handleChainChanged(chainId) {\n    if (false) {}\n\n    this.emitUpdate({\n      chainId: chainId,\n      provider: window.ethereum\n    });\n  };\n\n  _proto.handleAccountsChanged = function handleAccountsChanged(accounts) {\n    if (false) {}\n\n    if (accounts.length === 0) {\n      this.emitDeactivate();\n    } else {\n      this.emitUpdate({\n        account: accounts[0]\n      });\n    }\n  };\n\n  _proto.handleClose = function handleClose(code, reason) {\n    if (false) {}\n\n    this.emitDeactivate();\n  };\n\n  _proto.handleNetworkChanged = function handleNetworkChanged(networkId) {\n    if (false) {}\n\n    this.emitUpdate({\n      chainId: networkId,\n      provider: window.ethereum\n    });\n  };\n\n  _proto.activate = function activate() {\n    try {\n      var _temp5 = function _temp5(_result) {\n        if (_exit2) return _result;\n\n        function _temp2() {\n          return _extends({\n            provider: window.ethereum\n          }, account ? {\n            account: account\n          } : {});\n        }\n\n        var _temp = function () {\n          if (!account) {\n            // if enable is successful but doesn't return accounts, fall back to getAccount (not happy i have to do this...)\n            return Promise.resolve(window.ethereum.enable().then(function (sendReturn) {\n              return sendReturn && parseSendReturn(sendReturn)[0];\n            })).then(function (_window$ethereum$enab) {\n              account = _window$ethereum$enab;\n            });\n          }\n        }(); // if unsuccessful, try enable\n\n\n        return _temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp);\n      };\n\n      var _exit2 = false;\n\n      var _this5 = this;\n\n      if (!window.ethereum) {\n        throw new NoEthereumProviderError();\n      }\n\n      if (window.ethereum.on) {\n        window.ethereum.on('chainChanged', _this5.handleChainChanged);\n        window.ethereum.on('accountsChanged', _this5.handleAccountsChanged);\n        window.ethereum.on('close', _this5.handleClose);\n        window.ethereum.on('networkChanged', _this5.handleNetworkChanged);\n      }\n\n      if (window.ethereum.isMetaMask) {\n        ;\n        window.ethereum.autoRefreshOnNetworkChange = false;\n      } // try to activate + get account via eth_requestAccounts\n\n\n      var account;\n\n      var _temp6 = _catch(function () {\n        return Promise.resolve(window.ethereum.send('eth_requestAccounts').then(function (sendReturn) {\n          return parseSendReturn(sendReturn)[0];\n        })).then(function (_window$ethereum$send) {\n          account = _window$ethereum$send;\n        });\n      }, function (error) {\n        if (error.code === 4001) {\n          throw new UserRejectedRequestError();\n        }\n\n         false ? undefined : void 0;\n      });\n\n      return Promise.resolve(_temp6 && _temp6.then ? _temp6.then(_temp5) : _temp5(_temp6));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getProvider = function getProvider() {\n    try {\n      return Promise.resolve(window.ethereum);\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getChainId = function getChainId() {\n    try {\n      var _temp12 = function _temp12() {\n        function _temp9() {\n          if (!chainId) {\n            try {\n              chainId = parseSendReturn(window.ethereum.send({\n                method: 'net_version'\n              }));\n            } catch (_unused) {\n               false ? undefined : void 0;\n            }\n          }\n\n          if (!chainId) {\n            if (window.ethereum.isDapper) {\n              chainId = parseSendReturn(window.ethereum.cachedResults.net_version);\n            } else {\n              chainId = window.ethereum.chainId || window.ethereum.netVersion || window.ethereum.networkVersion || window.ethereum._chainId;\n            }\n          }\n\n          return chainId;\n        }\n\n        var _temp8 = function () {\n          if (!chainId) {\n            var _temp14 = _catch(function () {\n              return Promise.resolve(window.ethereum.send('net_version').then(parseSendReturn)).then(function (_window$ethereum$send3) {\n                chainId = _window$ethereum$send3;\n              });\n            }, function () {\n               false ? undefined : void 0;\n            });\n\n            if (_temp14 && _temp14.then) return _temp14.then(function () {});\n          }\n        }();\n\n        return _temp8 && _temp8.then ? _temp8.then(_temp9) : _temp9(_temp8);\n      };\n\n      if (!window.ethereum) {\n        throw new NoEthereumProviderError();\n      }\n\n      var chainId;\n\n      var _temp13 = _catch(function () {\n        return Promise.resolve(window.ethereum.send('eth_chainId').then(parseSendReturn)).then(function (_window$ethereum$send2) {\n          chainId = _window$ethereum$send2;\n        });\n      }, function () {\n         false ? undefined : void 0;\n      });\n\n      return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(_temp12) : _temp12(_temp13));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.getAccount = function getAccount() {\n    try {\n      var _temp20 = function _temp20() {\n        function _temp17() {\n          if (!account) {\n            account = parseSendReturn(window.ethereum.send({\n              method: 'eth_accounts'\n            }))[0];\n          }\n\n          return account;\n        }\n\n        var _temp16 = function () {\n          if (!account) {\n            var _temp22 = _catch(function () {\n              return Promise.resolve(window.ethereum.enable().then(function (sendReturn) {\n                return parseSendReturn(sendReturn)[0];\n              })).then(function (_window$ethereum$enab2) {\n                account = _window$ethereum$enab2;\n              });\n            }, function () {\n               false ? undefined : void 0;\n            });\n\n            if (_temp22 && _temp22.then) return _temp22.then(function () {});\n          }\n        }();\n\n        return _temp16 && _temp16.then ? _temp16.then(_temp17) : _temp17(_temp16);\n      };\n\n      if (!window.ethereum) {\n        throw new NoEthereumProviderError();\n      }\n\n      var account;\n\n      var _temp21 = _catch(function () {\n        return Promise.resolve(window.ethereum.send('eth_accounts').then(function (sendReturn) {\n          return parseSendReturn(sendReturn)[0];\n        })).then(function (_window$ethereum$send4) {\n          account = _window$ethereum$send4;\n        });\n      }, function () {\n         false ? undefined : void 0;\n      });\n\n      return Promise.resolve(_temp21 && _temp21.then ? _temp21.then(_temp20) : _temp20(_temp21));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  _proto.deactivate = function deactivate() {\n    if (window.ethereum && window.ethereum.removeListener) {\n      window.ethereum.removeListener('chainChanged', this.handleChainChanged);\n      window.ethereum.removeListener('accountsChanged', this.handleAccountsChanged);\n      window.ethereum.removeListener('close', this.handleClose);\n      window.ethereum.removeListener('networkChanged', this.handleNetworkChanged);\n    }\n  };\n\n  _proto.isAuthorized = function isAuthorized() {\n    try {\n      if (!window.ethereum) {\n        return Promise.resolve(false);\n      }\n\n      return Promise.resolve(_catch(function () {\n        return Promise.resolve(window.ethereum.send('eth_accounts').then(function (sendReturn) {\n          if (parseSendReturn(sendReturn).length > 0) {\n            return true;\n          } else {\n            return false;\n          }\n        }));\n      }, function () {\n        return false;\n      }));\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  };\n\n  return InjectedConnector;\n}(_web3_react_abstract_connector__WEBPACK_IMPORTED_MODULE_0__[/* AbstractConnector */ \"a\"]);\n\n\n\n/***/ }),\n\n/***/ 631:\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"a\", function() { return AbstractConnector; });\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(59);\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(events__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _web3_react_types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(70);\n\n\n\nfunction _inheritsLoose(subClass, superClass) {\n  subClass.prototype = Object.create(superClass.prototype);\n  subClass.prototype.constructor = subClass;\n  subClass.__proto__ = superClass;\n}\n\nvar AbstractConnector = /*#__PURE__*/function (_EventEmitter) {\n  _inheritsLoose(AbstractConnector, _EventEmitter);\n\n  function AbstractConnector(_temp) {\n    var _this;\n\n    var _ref = _temp === void 0 ? {} : _temp,\n        supportedChainIds = _ref.supportedChainIds;\n\n    _this = _EventEmitter.call(this) || this;\n    _this.supportedChainIds = supportedChainIds;\n    return _this;\n  }\n\n  var _proto = AbstractConnector.prototype;\n\n  _proto.emitUpdate = function emitUpdate(update) {\n    if (false) {}\n\n    this.emit(_web3_react_types__WEBPACK_IMPORTED_MODULE_1__[/* ConnectorEvent */ \"a\"].Update, update);\n  };\n\n  _proto.emitError = function emitError(error) {\n    if (false) {}\n\n    this.emit(_web3_react_types__WEBPACK_IMPORTED_MODULE_1__[/* ConnectorEvent */ \"a\"].Error, error);\n  };\n\n  _proto.emitDeactivate = function emitDeactivate() {\n    if (false) {}\n\n    this.emit(_web3_react_types__WEBPACK_IMPORTED_MODULE_1__[/* ConnectorEvent */ \"a\"].Deactivate);\n  };\n\n  return AbstractConnector;\n}(events__WEBPACK_IMPORTED_MODULE_0__[\"EventEmitter\"]);\n\n\n\n/***/ })\n\n}]);","inputSourceMap":{"version":3,"sources":["../../../node_modules/babel-plugin-transform-async-to-promises/helpers.js","../src/index.ts"],"names":["_iteratorSymbol","Symbol","_asyncIteratorSymbol","result","body","recover","sendReturn","NoEthereumProviderError","UserRejectedRequestError","InjectedConnector","handleChainChanged","chainId","provider","window","ethereum","handleAccountsChanged","accounts","account","handleClose","handleNetworkChanged","parseSendReturn","error","warning","method","deactivate","AbstractConnector","supportedChainIds","emitUpdate","ConnectorEvent","emitError","emitDeactivate"],"mappings":"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","file":"x","sourcesContent":["// A type of promise-like that resolves synchronously and supports only one observer\nexport const _Pact = /*#__PURE__*/(function() {\n\tfunction _Pact() {}\n\t_Pact.prototype.then = function(onFulfilled, onRejected) {\n\t\tconst result = new _Pact();\n\t\tconst state = this.s;\n\t\tif (state) {\n\t\t\tconst callback = state & 1 ? onFulfilled : onRejected;\n\t\t\tif (callback) {\n\t\t\t\ttry {\n\t\t\t\t\t_settle(result, 1, callback(this.v));\n\t\t\t\t} catch (e) {\n\t\t\t\t\t_settle(result, 2, e);\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t} else {\n\t\t\t\treturn this;\n\t\t\t}\n\t\t}\n\t\tthis.o = function(_this) {\n\t\t\ttry {\n\t\t\t\tconst value = _this.v;\n\t\t\t\tif (_this.s & 1) {\n\t\t\t\t\t_settle(result, 1, onFulfilled ? onFulfilled(value) : value);\n\t\t\t\t} else if (onRejected) {\n\t\t\t\t\t_settle(result, 1, onRejected(value));\n\t\t\t\t} else {\n\t\t\t\t\t_settle(result, 2, value);\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(result, 2, e);\n\t\t\t}\n\t\t};\n\t\treturn result;\n\t}\n\treturn _Pact;\n})();\n\n// Settles a pact synchronously\nexport function _settle(pact, state, value) {\n\tif (!pact.s) {\n\t\tif (value instanceof _Pact) {\n\t\t\tif (value.s) {\n\t\t\t\tif (state & 1) {\n\t\t\t\t\tstate = value.s;\n\t\t\t\t}\n\t\t\t\tvalue = value.v;\n\t\t\t} else {\n\t\t\t\tvalue.o = _settle.bind(null, pact, state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tif (value && value.then) {\n\t\t\tvalue.then(_settle.bind(null, pact, state), _settle.bind(null, pact, 2));\n\t\t\treturn;\n\t\t}\n\t\tpact.s = state;\n\t\tpact.v = value;\n\t\tconst observer = pact.o;\n\t\tif (observer) {\n\t\t\tobserver(pact);\n\t\t}\n\t}\n}\n\nexport function _isSettledPact(thenable) {\n\treturn thenable instanceof _Pact && thenable.s & 1;\n}\n\n// Converts argument to a function that always returns a Promise\nexport function _async(f) {\n\treturn function() {\n\t\tfor (var args = [], i = 0; i < arguments.length; i++) {\n\t\t\targs[i] = arguments[i];\n\t\t}\n\t\ttry {\n\t\t\treturn Promise.resolve(f.apply(this, args));\n\t\t} catch(e) {\n\t\t\treturn Promise.reject(e);\n\t\t}\n\t}\n}\n\n// Awaits on a value that may or may not be a Promise (equivalent to the await keyword in ES2015, with continuations passed explicitly)\nexport function _await(value, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(value) : value;\n\t}\n\tif (!value || !value.then) {\n\t\tvalue = Promise.resolve(value);\n\t}\n\treturn then ? value.then(then) : value;\n}\n\n// Awaits on a value that may or may not be a Promise, then ignores it\nexport function _awaitIgnored(value, direct) {\n\tif (!direct) {\n\t\treturn value && value.then ? value.then(_empty) : Promise.resolve();\n\t}\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continue(value, then) {\n\treturn value && value.then ? value.then(then) : then(value);\n}\n\n// Proceeds after a value has resolved, or proceeds immediately if the value is not thenable\nexport function _continueIgnored(value) {\n\tif (value && value.then) {\n\t\treturn value.then(_empty);\n\t}\n}\n\n// Asynchronously iterate through an object that has a length property, passing the index as the first argument to the callback (even as the length property changes)\nexport function _forTo(array, body, check) {\n\tvar i = -1, pact, reject;\n\tfunction _cycle(result) {\n\t\ttry {\n\t\t\twhile (++i < array.length && (!check || !check())) {\n\t\t\t\tresult = body(i);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (pact) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t} else {\n\t\t\t\tpact = result;\n\t\t\t}\n\t\t} catch (e) {\n\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t}\n\t}\n\t_cycle();\n\treturn pact;\n}\n\n// Asynchronously iterate through an object's properties (including properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forIn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tkeys.push(key);\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\n// Asynchronously iterate through an object's own properties (excluding properties inherited from the prototype)\n// Uses a snapshot of the object's properties\nexport function _forOwn(target, body, check) {\n\tvar keys = [];\n\tfor (var key in target) {\n\t\tif (Object.prototype.hasOwnProperty.call(target, key)) {\n\t\t\tkeys.push(key);\n\t\t}\n\t}\n\treturn _forTo(keys, function(i) { return body(keys[i]); }, check);\n}\n\nexport const _iteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.iterator || (Symbol.iterator = Symbol(\"Symbol.iterator\"))) : \"@@iterator\";\n\n// Asynchronously iterate through an object's values\n// Uses for...of if the runtime supports it, otherwise iterates until length on a copy\nexport function _forOf(target, body, check) {\n\tif (typeof target[_iteratorSymbol] === \"function\") {\n\t\tvar iterator = target[_iteratorSymbol](), step, pact, reject;\n\t\tfunction _cycle(result) {\n\t\t\ttry {\n\t\t\t\twhile (!(step = iterator.next()).done && (!check || !check())) {\n\t\t\t\t\tresult = body(step.value);\n\t\t\t\t\tif (result && result.then) {\n\t\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tresult.then(_cycle, reject || (reject = _settle.bind(null, pact = new _Pact(), 2)));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (pact) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t} else {\n\t\t\t\t\tpact = result;\n\t\t\t\t}\n\t\t\t} catch (e) {\n\t\t\t\t_settle(pact || (pact = new _Pact()), 2, e);\n\t\t\t}\n\t\t}\n\t\t_cycle();\n\t\tif (iterator.return) {\n\t\t\tvar _fixup = function(value) {\n\t\t\t\ttry {\n\t\t\t\t\tif (!step.done) {\n\t\t\t\t\t\titerator.return();\n\t\t\t\t\t}\n\t\t\t\t} catch(e) {\n\t\t\t\t}\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tif (pact && pact.then) {\n\t\t\t\treturn pact.then(_fixup, function(e) {\n\t\t\t\t\tthrow _fixup(e);\n\t\t\t\t});\n\t\t\t}\n\t\t\t_fixup();\n\t\t}\n\t\treturn pact;\n\t}\n\t// No support for Symbol.iterator\n\tif (!(\"length\" in target)) {\n\t\tthrow new TypeError(\"Object is not iterable\");\n\t}\n\t// Handle live collections properly\n\tvar values = [];\n\tfor (var i = 0; i < target.length; i++) {\n\t\tvalues.push(target[i]);\n\t}\n\treturn _forTo(values, function(i) { return body(values[i]); }, check);\n}\n\nexport const _asyncIteratorSymbol = /*#__PURE__*/ typeof Symbol !== \"undefined\" ? (Symbol.asyncIterator || (Symbol.asyncIterator = Symbol(\"Symbol.asyncIterator\"))) : \"@@asyncIterator\";\n\n// Asynchronously iterate on a value using it's async iterator if present, or its synchronous iterator if missing\nexport function _forAwaitOf(target, body, check) {\n\tif (typeof target[_asyncIteratorSymbol] === \"function\") {\n\t\tvar pact = new _Pact();\n\t\tvar iterator = target[_asyncIteratorSymbol]();\n\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\treturn pact;\n\t\tfunction _resumeAfterBody(result) {\n\t\t\tif (check && check()) {\n\t\t\t\treturn _settle(pact, 1, iterator.return ? iterator.return().then(function() { return result; }) : result);\n\t\t\t}\n\t\t\titerator.next().then(_resumeAfterNext).then(void 0, _reject);\n\t\t}\n\t\tfunction _resumeAfterNext(step) {\n\t\t\tif (step.done) {\n\t\t\t\t_settle(pact, 1);\n\t\t\t} else {\n\t\t\t\tPromise.resolve(body(step.value)).then(_resumeAfterBody).then(void 0, _reject);\n\t\t\t}\n\t\t}\n\t\tfunction _reject(error) {\n\t\t\t_settle(pact, 2, iterator.return ? iterator.return().then(function() { return error; }) : error);\n\t\t}\n\t}\n\treturn Promise.resolve(_forOf(target, function(value) { return Promise.resolve(value).then(body); }, check));\n}\n\n// Asynchronously implement a generic for loop\nexport function _for(test, update, body) {\n\tvar stage;\n\tfor (;;) {\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t\tif (shouldContinue.then) {\n\t\t\tstage = 0;\n\t\t\tbreak;\n\t\t}\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.s;\n\t\t\t} else {\n\t\t\t\tstage = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (update) {\n\t\t\tvar updateValue = update();\n\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\tstage = 2;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tvar pact = new _Pact();\n\tvar reject = _settle.bind(null, pact, 2);\n\t(stage === 0 ? shouldContinue.then(_resumeAfterTest) : stage === 1 ? result.then(_resumeAfterBody) : updateValue.then(_resumeAfterUpdate)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tdo {\n\t\t\tif (update) {\n\t\t\t\tupdateValue = update();\n\t\t\t\tif (updateValue && updateValue.then && !_isSettledPact(updateValue)) {\n\t\t\t\t\tupdateValue.then(_resumeAfterUpdate).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tshouldContinue = test();\n\t\t\tif (!shouldContinue || (_isSettledPact(shouldContinue) && !shouldContinue.v)) {\n\t\t\t\t_settle(pact, 1, result);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t}\n\t\t} while (!result || !result.then);\n\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterBody(result);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n\tfunction _resumeAfterUpdate() {\n\t\tif (shouldContinue = test()) {\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t} else {\n\t\t\t\t_resumeAfterTest(shouldContinue);\n\t\t\t}\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a do ... while loop\nexport function _do(body, test) {\n\tvar awaitBody;\n\tdo {\n\t\tvar result = body();\n\t\tif (result && result.then) {\n\t\t\tif (_isSettledPact(result)) {\n\t\t\t\tresult = result.v;\n\t\t\t} else {\n\t\t\t\tawaitBody = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tvar shouldContinue = test();\n\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\tshouldContinue = shouldContinue.v;\n\t\t}\n\t\tif (!shouldContinue) {\n\t\t\treturn result;\n\t\t}\n\t} while (!shouldContinue.then);\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : shouldContinue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterBody(value) {\n\t\tresult = value;\n\t\tfor (;;) {\n\t\t\tshouldContinue = test();\n\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t}\n\t\t\tif (!shouldContinue) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (shouldContinue.then) {\n\t\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\tresult = result.v;\n\t\t\t\t} else {\n\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterTest(shouldContinue) {\n\t\tif (shouldContinue) {\n\t\t\tdo {\n\t\t\t\tresult = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tif (_isSettledPact(result)) {\n\t\t\t\t\t\tresult = result.v;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tshouldContinue = test();\n\t\t\t\tif (_isSettledPact(shouldContinue)) {\n\t\t\t\t\tshouldContinue = shouldContinue.v;\n\t\t\t\t}\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} while (!shouldContinue.then);\n\t\t\tshouldContinue.then(_resumeAfterTest).then(void 0, reject);\n\t\t} else {\n\t\t\t_settle(pact, 1, result);\n\t\t}\n\t}\n}\n\n// Asynchronously implement a switch statement\nexport function _switch(discriminant, cases) {\n\tvar dispatchIndex = -1;\n\tvar awaitBody;\n\touter: {\n\t\tfor (var i = 0; i < cases.length; i++) {\n\t\t\tvar test = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvar testValue = test();\n\t\t\t\tif (testValue && testValue.then) {\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tif (testValue === discriminant) {\n\t\t\t\t\tdispatchIndex = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Found the default case, set it as the pending dispatch case\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tif (dispatchIndex !== -1) {\n\t\t\tdo {\n\t\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\t\twhile (!body) {\n\t\t\t\t\tdispatchIndex++;\n\t\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t\t}\n\t\t\t\tvar result = body();\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tawaitBody = true;\n\t\t\t\t\tbreak outer;\n\t\t\t\t}\n\t\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\t\tdispatchIndex++;\n\t\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t\treturn result;\n\t\t}\n\t}\n\tconst pact = new _Pact();\n\tconst reject = _settle.bind(null, pact, 2);\n\t(awaitBody ? result.then(_resumeAfterBody) : testValue.then(_resumeAfterTest)).then(void 0, reject);\n\treturn pact;\n\tfunction _resumeAfterTest(value) {\n\t\tfor (;;) {\n\t\t\tif (value === discriminant) {\n\t\t\t\tdispatchIndex = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (++i === cases.length) {\n\t\t\t\tif (dispatchIndex !== -1) {\n\t\t\t\t\tbreak;\n\t\t\t\t} else {\n\t\t\t\t\t_settle(pact, 1, result);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\ttest = cases[i][0];\n\t\t\tif (test) {\n\t\t\t\tvalue = test();\n\t\t\t\tif (value && value.then) {\n\t\t\t\t\tvalue.then(_resumeAfterTest).then(void 0, reject);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdispatchIndex = i;\n\t\t\t}\n\t\t}\n\t\tdo {\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tvar result = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tdispatchIndex++;\n\t\t} while (fallthroughCheck && !fallthroughCheck());\n\t\t_settle(pact, 1, result);\n\t}\n\tfunction _resumeAfterBody(result) {\n\t\tfor (;;) {\n\t\t\tvar fallthroughCheck = cases[dispatchIndex][2];\n\t\t\tif (!fallthroughCheck || fallthroughCheck()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdispatchIndex++;\n\t\t\tvar body = cases[dispatchIndex][1];\n\t\t\twhile (!body) {\n\t\t\t\tdispatchIndex++;\n\t\t\t\tbody = cases[dispatchIndex][1];\n\t\t\t}\n\t\t\tresult = body();\n\t\t\tif (result && result.then) {\n\t\t\t\tresult.then(_resumeAfterBody).then(void 0, reject);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\t_settle(pact, 1, result);\n\t}\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _call(body, then, direct) {\n\tif (direct) {\n\t\treturn then ? then(body()) : body();\n\t}\n\ttry {\n\t\tvar result = Promise.resolve(body());\n\t\treturn then ? result.then(then) : result;\n\t} catch (e) {\n\t\treturn Promise.reject(e);\n\t}\n}\n\n// Asynchronously call a function and swallow the result\nexport function _callIgnored(body, direct) {\n\treturn _call(body, _empty, direct);\n}\n\n// Asynchronously call a function and pass the result to explicitly passed continuations\nexport function _invoke(body, then) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(then);\n\t}\n\treturn then(result);\n}\n\n// Asynchronously call a function and swallow the result\nexport function _invokeIgnored(body) {\n\tvar result = body();\n\tif (result && result.then) {\n\t\treturn result.then(_empty);\n\t}\n}\n\n// Asynchronously call a function and send errors to recovery continuation\nexport function _catch(body, recover) {\n\ttry {\n\t\tvar result = body();\n\t} catch(e) {\n\t\treturn recover(e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(void 0, recover);\n\t}\n\treturn result;\n}\n\n// Asynchronously await a promise and pass the result to a finally continuation\nexport function _finallyRethrows(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer(true, e);\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer.bind(null, false), finalizer.bind(null, true));\n\t}\n\treturn finalizer(false, result);\n}\n\n// Asynchronously await a promise and invoke a finally continuation that always overrides the result\nexport function _finally(body, finalizer) {\n\ttry {\n\t\tvar result = body();\n\t} catch (e) {\n\t\treturn finalizer();\n\t}\n\tif (result && result.then) {\n\t\treturn result.then(finalizer, finalizer);\n\t}\n\treturn finalizer();\n}\n\n// Rethrow or return a value from a finally continuation\nexport function _rethrow(thrown, value) {\n\tif (thrown)\n\t\tthrow value;\n\treturn value;\n}\n\n// Empty function to implement break and other control flow that ignores asynchronous results\nexport function _empty() {\n}\n\n// Sentinel value for early returns in generators \nexport const _earlyReturn = /*#__PURE__*/ {};\n\n// Asynchronously call a function and send errors to recovery continuation, skipping early returns\nexport function _catchInGenerator(body, recover) {\n\treturn _catch(body, function(e) {\n\t\tif (e === _earlyReturn) {\n\t\t\tthrow e;\n\t\t}\n\t\treturn recover(e);\n\t});\n}\n\n// Asynchronous generator class; accepts the entrypoint of the generator, to which it passes itself when the generator should start\nexport const _AsyncGenerator = /*#__PURE__*/(function() {\n\tfunction _AsyncGenerator(entry) {\n\t\tthis._entry = entry;\n\t\tthis._pact = null;\n\t\tthis._resolve = null;\n\t\tthis._return = null;\n\t\tthis._promise = null;\n\t}\n\n\tfunction _wrapReturnedValue(value) {\n\t\treturn { value: value, done: true };\n\t}\n\tfunction _wrapYieldedValue(value) {\n\t\treturn { value: value, done: false };\n\t}\n\n\t_AsyncGenerator.prototype._yield = function(value) {\n\t\t// Yield the value to the pending next call\n\t\tthis._resolve(value && value.then ? value.then(_wrapYieldedValue) : _wrapYieldedValue(value));\n\t\t// Return a pact for an upcoming next/return/throw call\n\t\treturn this._pact = new _Pact();\n\t};\n\t_AsyncGenerator.prototype.next = function(value) {\n\t\t// Advance the generator, starting it if it has yet to be started\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tconst _entry = _this._entry;\n\t\t\t\tif (_entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the next call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Start the generator\n\t\t\t\t_this._entry = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\tfunction returnValue(value) {\n\t\t\t\t\t_this._resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t_this._resolve = null;\n\t\t\t\t}\n\t\t\t\tvar result = _entry(_this);\n\t\t\t\tif (result && result.then) {\n\t\t\t\t\tresult.then(returnValue, function(error) {\n\t\t\t\t\t\tif (error === _earlyReturn) {\n\t\t\t\t\t\t\treturnValue(_this._return);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst pact = new _Pact();\n\t\t\t\t\t\t\t_this._resolve(pact);\n\t\t\t\t\t\t\t_this._pact = null;\n\t\t\t\t\t\t\t_this._resolve = null;\n\t\t\t\t\t\t\t_resolve(pact, 2, error);\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} else {\n\t\t\t\t\treturnValue(result);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Generator is started and a yield expression is pending, settle it\n\t\t\t\t_this._pact = null;\n\t\t\t\t_this._resolve = resolve;\n\t\t\t\t_settle(_pact, 1, value);\n\t\t\t}\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.return = function(value) {\n\t\t// Early return from the generator if started, otherwise abandons the generator\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the return call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return the specified value\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn resolve(value && value.then ? value.then(_wrapReturnedValue) : _wrapReturnedValue(value));\n\t\t\t}\n\t\t\t// Settle the yield expression with a rejected \"early return\" value\n\t\t\t_this._return = value;\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, _earlyReturn);\n\t\t});\n\t};\n\t_AsyncGenerator.prototype.throw = function(error) {\n\t\t// Inject an exception into the pending yield expression\n\t\tconst _this = this;\n\t\treturn _this._promise = new Promise(function (resolve, reject) {\n\t\t\tconst _pact = _this._pact;\n\t\t\tif (_pact === null) {\n\t\t\t\tif (_this._entry === null) {\n\t\t\t\t\t// Generator is started, but not awaiting a yield expression\n\t\t\t\t\t// Abandon the throw call!\n\t\t\t\t\treturn resolve(_this._promise);\n\t\t\t\t}\n\t\t\t\t// Generator is not started, abandon it and return a rejected Promise containing the error\n\t\t\t\t_this._entry = null;\n\t\t\t\treturn reject(error);\n\t\t\t}\n\t\t\t// Settle the yield expression with the value as a rejection\n\t\t\t_this._resolve = resolve;\n\t\t\t_this._pact = null;\n\t\t\t_settle(_pact, 2, error);\n\t\t});\n\t};\n\n\t_AsyncGenerator.prototype[_asyncIteratorSymbol] = function() {\n\t\treturn this;\n\t};\n\t\n\treturn _AsyncGenerator;\n})();\n","import { EventEmitter } from 'events'\nimport { AbstractConnectorArguments, ConnectorUpdate, ConnectorEvent } from '@web3-react/types'\n\nexport abstract class AbstractConnector extends EventEmitter {\n  public readonly supportedChainIds?: number[]\n\n  constructor({ supportedChainIds }: AbstractConnectorArguments = {}) {\n    super()\n    this.supportedChainIds = supportedChainIds\n  }\n\n  public abstract async activate(): Promise<ConnectorUpdate>\n  public abstract async getProvider(): Promise<any>\n  public abstract async getChainId(): Promise<number | string>\n  public abstract async getAccount(): Promise<null | string>\n  public abstract deactivate(): void\n\n  protected emitUpdate(update: ConnectorUpdate): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Update}' with payload`, update)\n    }\n    this.emit(ConnectorEvent.Update, update)\n  }\n\n  protected emitError(error: Error): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Error}' with payload`, error)\n    }\n    this.emit(ConnectorEvent.Error, error)\n  }\n\n  protected emitDeactivate(): void {\n    if (__DEV__) {\n      console.log(`Emitting '${ConnectorEvent.Deactivate}'`)\n    }\n    this.emit(ConnectorEvent.Deactivate)\n  }\n}\n"]}}