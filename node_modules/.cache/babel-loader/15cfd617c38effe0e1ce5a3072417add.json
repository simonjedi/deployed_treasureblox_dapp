{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst crypto_1 = require(\"crypto\");\n\nconst elliptic_1 = require(\"elliptic\");\n\nconst curve = new elliptic_1.ec('secp256k1');\nconst N = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst ZERO = Buffer.alloc(32, 0);\n\nfunction isValidPrivateKey(key) {\n  return !key.equals(ZERO) && key.compare(N) < 0;\n}\n/** secp256k1 methods set */\n\n\nvar secp256k1;\n\n(function (secp256k1) {\n  /** generate private key  */\n  function generatePrivateKey() {\n    for (;;) {\n      const privKey = crypto_1.randomBytes(32);\n\n      if (isValidPrivateKey(privKey)) {\n        return privKey;\n      }\n    }\n  }\n\n  secp256k1.generatePrivateKey = generatePrivateKey;\n  /**\n   * derive public key(uncompressed) from private key\n   * @param privKey the private key\n   */\n\n  function derivePublicKey(privKey) {\n    const keyPair = curve.keyFromPrivate(privKey);\n    return Buffer.from(keyPair.getPublic().encode('array', false));\n  }\n\n  secp256k1.derivePublicKey = derivePublicKey;\n  /**\n   * sign a message using elliptic curve algorithm on the curve secp256k1\n   * @param msgHash hash of message\n   * @param privKey serialized private key\n   */\n\n  function sign(msgHash, privKey) {\n    const keyPair = curve.keyFromPrivate(privKey);\n    const sig = keyPair.sign(msgHash, {\n      canonical: true\n    });\n    const r = Buffer.from(sig.r.toArray('be'));\n    const s = Buffer.from(sig.s.toArray('be'));\n    return Buffer.concat([r, s, Buffer.from([sig.recoveryParam])]);\n  }\n\n  secp256k1.sign = sign;\n  /**\n   * recovery signature to public key\n   * @param msgHash hash of message\n   * @param sig signature\n   */\n\n  function recover(msgHash, sig) {\n    if (sig.length !== 65) {\n      throw new Error('invalid signature');\n    }\n\n    const recovery = sig[64];\n\n    if (recovery !== 0 && recovery !== 1) {\n      throw new Error('invalid signature recovery');\n    }\n\n    const r = sig.slice(0, 32);\n    const s = sig.slice(32, 64);\n    return Buffer.from(curve.recoverPubKey(msgHash, {\n      r,\n      s\n    }, recovery).encode('array', false));\n  }\n\n  secp256k1.recover = recover;\n})(secp256k1 = exports.secp256k1 || (exports.secp256k1 = {}));","map":{"version":3,"sources":["../../src/cry/secp256k1.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst crypto_1 = require(\"crypto\");\nconst elliptic_1 = require(\"elliptic\");\nconst curve = new elliptic_1.ec('secp256k1');\nconst N = Buffer.from('fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst ZERO = Buffer.alloc(32, 0);\nfunction isValidPrivateKey(key) {\n    return !key.equals(ZERO) && key.compare(N) < 0;\n}\n/** secp256k1 methods set */\nvar secp256k1;\n(function (secp256k1) {\n    /** generate private key  */\n    function generatePrivateKey() {\n        for (;;) {\n            const privKey = crypto_1.randomBytes(32);\n            if (isValidPrivateKey(privKey)) {\n                return privKey;\n            }\n        }\n    }\n    secp256k1.generatePrivateKey = generatePrivateKey;\n    /**\n     * derive public key(uncompressed) from private key\n     * @param privKey the private key\n     */\n    function derivePublicKey(privKey) {\n        const keyPair = curve.keyFromPrivate(privKey);\n        return Buffer.from(keyPair.getPublic().encode('array', false));\n    }\n    secp256k1.derivePublicKey = derivePublicKey;\n    /**\n     * sign a message using elliptic curve algorithm on the curve secp256k1\n     * @param msgHash hash of message\n     * @param privKey serialized private key\n     */\n    function sign(msgHash, privKey) {\n        const keyPair = curve.keyFromPrivate(privKey);\n        const sig = keyPair.sign(msgHash, { canonical: true });\n        const r = Buffer.from(sig.r.toArray('be'));\n        const s = Buffer.from(sig.s.toArray('be'));\n        return Buffer.concat([r, s, Buffer.from([sig.recoveryParam])]);\n    }\n    secp256k1.sign = sign;\n    /**\n     * recovery signature to public key\n     * @param msgHash hash of message\n     * @param sig signature\n     */\n    function recover(msgHash, sig) {\n        if (sig.length !== 65) {\n            throw new Error('invalid signature');\n        }\n        const recovery = sig[64];\n        if (recovery !== 0 && recovery !== 1) {\n            throw new Error('invalid signature recovery');\n        }\n        const r = sig.slice(0, 32);\n        const s = sig.slice(32, 64);\n        return Buffer.from(curve.recoverPubKey(msgHash, { r, s }, recovery).encode('array', false));\n    }\n    secp256k1.recover = recover;\n})(secp256k1 = exports.secp256k1 || (exports.secp256k1 = {}));\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VjcDI1NmsxLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NyeS9zZWNwMjU2azEudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxtQ0FBcUM7QUFDckMsdUNBQW9DO0FBRXBDLE1BQU0sS0FBSyxHQUFHLElBQUksYUFBRSxDQUFDLFdBQVcsQ0FBQyxDQUFDO0FBRWxDLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsa0VBQWtFLENBQUMsQ0FBQztBQUMxRixNQUFNLElBQUksR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztBQUVqQyxTQUFTLGlCQUFpQixDQUFDLEdBQVc7SUFDcEMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLElBQUksR0FBRyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUVELDRCQUE0QjtBQUM1QixJQUFpQixTQUFTLENBc0R6QjtBQXRERCxXQUFpQixTQUFTO0lBQ3hCLDRCQUE0QjtJQUM1QixTQUFnQixrQkFBa0I7UUFDaEMsU0FBUztZQUNQLE1BQU0sT0FBTyxHQUFHLG9CQUFXLENBQUMsRUFBRSxDQUFDLENBQUM7WUFDaEMsSUFBSSxpQkFBaUIsQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDOUIsT0FBTyxPQUFPLENBQUM7YUFDaEI7U0FDRjtJQUNILENBQUM7SUFQZSw0QkFBa0IscUJBT2pDLENBQUE7SUFFRDs7O09BR0c7SUFDSCxTQUFnQixlQUFlLENBQUMsT0FBZTtRQUM3QyxNQUFNLE9BQU8sR0FBRyxLQUFLLENBQUMsY0FBYyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQzlDLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLENBQUMsTUFBTSxDQUFDLE9BQU8sRUFBRSxLQUFLLENBQVEsQ0FBQyxDQUFDO0lBQ3hFLENBQUM7SUFIZSx5QkFBZSxrQkFHOUIsQ0FBQTtJQUVEOzs7O09BSUc7SUFDSCxTQUFnQixJQUFJLENBQUMsT0FBZSxFQUFFLE9BQWU7UUFDbkQsTUFBTSxPQUFPLEdBQUcsS0FBSyxDQUFDLGNBQWMsQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUM5QyxNQUFNLEdBQUcsR0FBRyxPQUFPLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBRXZELE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztRQUMzQyxNQUFNLENBQUMsR0FBRyxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUM7UUFFM0MsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxDQUFDLGFBQWMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ2xFLENBQUM7SUFSZSxjQUFJLE9BUW5CLENBQUE7SUFFRDs7OztPQUlHO0lBQ0gsU0FBZ0IsT0FBTyxDQUFDLE9BQWUsRUFBRSxHQUFXO1FBQ2xELElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxFQUFFLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsQ0FBQyxDQUFDO1NBQ3RDO1FBQ0QsTUFBTSxRQUFRLEdBQUcsR0FBRyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ3pCLElBQUksUUFBUSxLQUFLLENBQUMsSUFBSSxRQUFRLEtBQUssQ0FBQyxFQUFFO1lBQ3BDLE1BQU0sSUFBSSxLQUFLLENBQUMsNEJBQTRCLENBQUMsQ0FBQztTQUMvQztRQUVELE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzNCLE1BQU0sQ0FBQyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBRTVCLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsYUFBYSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxRQUFRLENBQUMsQ0FBQyxNQUFNLENBQUMsT0FBTyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDOUYsQ0FBQztJQWJlLGlCQUFPLFVBYXRCLENBQUE7QUFDSCxDQUFDLEVBdERnQixTQUFTLEdBQVQsaUJBQVMsS0FBVCxpQkFBUyxRQXNEekIifQ=="]},"metadata":{},"sourceType":"script"}