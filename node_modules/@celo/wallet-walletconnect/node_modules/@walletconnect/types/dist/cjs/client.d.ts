import { Logger } from "pino";
import { IKeyValueStorage, KeyValueStorageOptions } from "keyvaluestorage";
import { IJsonRpcProvider, JsonRpcResponse, IEvents } from "@walletconnect/jsonrpc-types";
import { IRelayer, RelayerTypes } from "./relayer";
import { ISession, SessionTypes } from "./session";
import { IPairing } from "./pairing";
import { SignalTypes, AppMetadata, Reason } from "./misc";
import { ICrypto, IKeyChain } from "./crypto";
import { IStorage } from "./storage";
import { PairingTypes } from ".";
export interface ClientOptions {
    name?: string;
    apiKey?: string;
    controller?: boolean;
    metadata?: AppMetadata;
    logger?: string | Logger;
    keychain?: IKeyChain;
    storage?: IKeyValueStorage;
    relayProvider?: string | IJsonRpcProvider;
    storageOptions?: KeyValueStorageOptions;
}
export declare abstract class IClient extends IEvents {
    readonly protocol = "wc";
    readonly version = 2;
    abstract logger: Logger;
    abstract crypto: ICrypto;
    abstract relayer: IRelayer;
    abstract storage: IStorage;
    abstract pairing: IPairing;
    abstract session: ISession;
    abstract name: string;
    abstract readonly context: string;
    abstract readonly controller: boolean;
    abstract metadata: AppMetadata | undefined;
    abstract apiKey: string | undefined;
    constructor(opts?: ClientOptions);
    abstract connect(params: ClientTypes.ConnectParams): Promise<SessionTypes.Settled>;
    abstract pair(params: ClientTypes.PairParams): Promise<PairingTypes.Settled>;
    abstract approve(params: ClientTypes.ApproveParams): Promise<SessionTypes.Settled>;
    abstract reject(params: ClientTypes.RejectParams): Promise<void>;
    abstract upgrade(params: ClientTypes.UpgradeParams): Promise<void>;
    abstract update(params: ClientTypes.UpdateParams): Promise<void>;
    abstract request(params: ClientTypes.RequestParams): Promise<any>;
    abstract respond(params: ClientTypes.RespondParams): Promise<void>;
    abstract ping(params: ClientTypes.PingParams): Promise<void>;
    abstract notify(params: ClientTypes.NotifyParams): Promise<void>;
    abstract disconnect(params: ClientTypes.DisconnectParams): Promise<void>;
}
export declare namespace ClientTypes {
    interface ConnectParams {
        permissions: SessionTypes.BasePermissions;
        metadata?: AppMetadata;
        relay?: RelayerTypes.ProtocolOptions;
        pairing?: SignalTypes.ParamsPairing;
    }
    interface PairParams {
        uri: string;
    }
    interface ResponseInput {
        state: SessionTypes.State;
        metadata?: AppMetadata;
    }
    interface ApproveParams {
        proposal: SessionTypes.Proposal;
        response: ResponseInput;
    }
    interface RejectParams {
        proposal: SessionTypes.Proposal;
        reason?: Reason;
    }
    type UpgradeParams = SessionTypes.UpgradeParams;
    type UpdateParams = SessionTypes.UpdateParams;
    type RequestParams = SessionTypes.RequestParams;
    interface RespondParams {
        topic: string;
        response: JsonRpcResponse;
    }
    interface PingParams {
        topic: string;
        timeout?: number;
    }
    type NotifyParams = SessionTypes.NotifyParams;
    type DisconnectParams = SessionTypes.DeleteParams;
}
//# sourceMappingURL=client.d.ts.map