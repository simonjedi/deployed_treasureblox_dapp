{"ast":null,"code":"\"use strict\";\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n  result[\"default\"] = mod;\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n}); // See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\n\nvar errors = __importStar(require(\"../errors\")); // The English language word list.\n// For additional word lists, please see /src.tc/wordlists/\n\n\nvar lang_en_1 = require(\"../wordlists/lang-en\"); // Automatically register English?\n//import { register } from '../wordlists/wordlist';\n//register(langEn);\n\n\nvar basex_1 = require(\"./basex\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar bignumber_1 = require(\"./bignumber\");\n\nvar utf8_1 = require(\"./utf8\");\n\nvar pbkdf2_1 = require(\"./pbkdf2\");\n\nvar hmac_1 = require(\"./hmac\");\n\nvar properties_1 = require(\"./properties\");\n\nvar secp256k1_1 = require(\"./secp256k1\");\n\nvar sha2_1 = require(\"./sha2\");\n\nvar N = bignumber_1.bigNumberify(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"); // \"Bitcoin seed\"\n\nvar MasterSecret = utf8_1.toUtf8Bytes('Bitcoin seed');\nvar HardenedBit = 0x80000000; // Returns a byte with the MSB bits set\n\nfunction getUpperMask(bits) {\n  return (1 << bits) - 1 << 8 - bits;\n} // Returns a byte with the LSB bits set\n\n\nfunction getLowerMask(bits) {\n  return (1 << bits) - 1;\n}\n\nfunction bytes32(value) {\n  return bytes_1.hexZeroPad(bytes_1.hexlify(value), 32);\n}\n\nfunction base58check(data) {\n  var checksum = bytes_1.hexDataSlice(sha2_1.sha256(sha2_1.sha256(data)), 0, 4);\n  return basex_1.Base58.encode(bytes_1.concat([data, checksum]));\n}\n\nvar _constructorGuard = {};\nexports.defaultPath = \"m/44'/60'/0'/0/0\";\n\nvar HDNode = function () {\n  /**\n   *  This constructor should not be called directly.\n   *\n   *  Please use:\n   *   - fromMnemonic\n   *   - fromSeed\n   */\n  function HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonic, path) {\n    errors.checkNew(this, HDNode);\n\n    if (constructorGuard !== _constructorGuard) {\n      throw new Error('HDNode constructor cannot be called directly');\n    }\n\n    if (privateKey) {\n      var keyPair = new secp256k1_1.KeyPair(privateKey);\n      properties_1.defineReadOnly(this, 'privateKey', keyPair.privateKey);\n      properties_1.defineReadOnly(this, 'publicKey', keyPair.compressedPublicKey);\n    } else {\n      properties_1.defineReadOnly(this, 'privateKey', null);\n      properties_1.defineReadOnly(this, 'publicKey', bytes_1.hexlify(publicKey));\n    }\n\n    properties_1.defineReadOnly(this, 'parentFingerprint', parentFingerprint);\n    properties_1.defineReadOnly(this, 'fingerprint', bytes_1.hexDataSlice(sha2_1.ripemd160(sha2_1.sha256(this.publicKey)), 0, 4));\n    properties_1.defineReadOnly(this, 'address', secp256k1_1.computeAddress(this.publicKey));\n    properties_1.defineReadOnly(this, 'chainCode', chainCode);\n    properties_1.defineReadOnly(this, 'index', index);\n    properties_1.defineReadOnly(this, 'depth', depth);\n    properties_1.defineReadOnly(this, 'mnemonic', mnemonic);\n    properties_1.defineReadOnly(this, 'path', path);\n    properties_1.setType(this, 'HDNode');\n  }\n\n  Object.defineProperty(HDNode.prototype, \"extendedKey\", {\n    get: function () {\n      // We only support the mainnet values for now, but if anyone needs\n      // testnet values, let me know. I believe current senitment is that\n      // we should always use mainnet, and use BIP-44 to derive the network\n      //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n      //   - Testnet: public=0x043587CF, private=0x04358394\n      if (this.depth >= 256) {\n        throw new Error(\"Depth too large!\");\n      }\n\n      return base58check(bytes_1.concat([this.privateKey != null ? \"0x0488ADE4\" : \"0x0488B21E\", bytes_1.hexlify(this.depth), this.parentFingerprint, bytes_1.hexZeroPad(bytes_1.hexlify(this.index), 4), this.chainCode, this.privateKey != null ? bytes_1.concat([\"0x00\", this.privateKey]) : this.publicKey]));\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  HDNode.prototype.neuter = function () {\n    return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, null, this.path);\n  };\n\n  HDNode.prototype._derive = function (index) {\n    if (index > 0xffffffff) {\n      throw new Error(\"invalid index - \" + String(index));\n    } // Base path\n\n\n    var path = this.path;\n\n    if (path) {\n      path += '/' + (index & ~HardenedBit);\n    }\n\n    var data = new Uint8Array(37);\n\n    if (index & HardenedBit) {\n      if (!this.privateKey) {\n        throw new Error('cannot derive child of neutered node');\n      } // Data = 0x00 || ser_256(k_par)\n\n\n      data.set(bytes_1.arrayify(this.privateKey), 1); // Hardened path\n\n      if (path) {\n        path += \"'\";\n      }\n    } else {\n      // Data = ser_p(point(k_par))\n      data.set(bytes_1.arrayify(this.publicKey));\n    } // Data += ser_32(i)\n\n\n    for (var i = 24; i >= 0; i -= 8) {\n      data[33 + (i >> 3)] = index >> 24 - i & 0xff;\n    }\n\n    var I = hmac_1.computeHmac(hmac_1.SupportedAlgorithms.sha512, this.chainCode, data);\n    var IL = I.slice(0, 32);\n    var IR = I.slice(32); // The private key\n\n    var ki = null; // The public key\n\n    var Ki = null;\n\n    if (this.privateKey) {\n      ki = bytes32(bignumber_1.bigNumberify(IL).add(this.privateKey).mod(N));\n    } else {\n      var ek = new secp256k1_1.KeyPair(bytes_1.hexlify(IL));\n      Ki = ek._addPoint(this.publicKey);\n    }\n\n    return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, this.mnemonic, path);\n  };\n\n  HDNode.prototype.derivePath = function (path) {\n    var components = path.split('/');\n\n    if (components.length === 0 || components[0] === 'm' && this.depth !== 0) {\n      throw new Error('invalid path - ' + path);\n    }\n\n    if (components[0] === 'm') {\n      components.shift();\n    }\n\n    var result = this;\n\n    for (var i = 0; i < components.length; i++) {\n      var component = components[i];\n\n      if (component.match(/^[0-9]+'$/)) {\n        var index = parseInt(component.substring(0, component.length - 1));\n\n        if (index >= HardenedBit) {\n          throw new Error('invalid path index - ' + component);\n        }\n\n        result = result._derive(HardenedBit + index);\n      } else if (component.match(/^[0-9]+$/)) {\n        var index = parseInt(component);\n\n        if (index >= HardenedBit) {\n          throw new Error('invalid path index - ' + component);\n        }\n\n        result = result._derive(index);\n      } else {\n        throw new Error('invlaid path component - ' + component);\n      }\n    }\n\n    return result;\n  };\n\n  HDNode.isHDNode = function (value) {\n    return properties_1.isType(value, 'HDNode');\n  };\n\n  return HDNode;\n}();\n\nexports.HDNode = HDNode;\n\nfunction fromExtendedKey(extendedKey) {\n  var bytes = basex_1.Base58.decode(extendedKey);\n\n  if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n    errors.throwError(\"invalid extended key\", errors.INVALID_ARGUMENT, {\n      argument: \"extendedKey\",\n      value: \"[REDACTED]\"\n    });\n  }\n\n  var depth = bytes[4];\n  var parentFingerprint = bytes_1.hexlify(bytes.slice(5, 9));\n  var index = parseInt(bytes_1.hexlify(bytes.slice(9, 13)).substring(2), 16);\n  var chainCode = bytes_1.hexlify(bytes.slice(13, 45));\n  var key = bytes.slice(45, 78);\n\n  switch (bytes_1.hexlify(bytes.slice(0, 4))) {\n    // Public Key\n    case \"0x0488b21e\":\n    case \"0x043587cf\":\n      return new HDNode(_constructorGuard, null, bytes_1.hexlify(key), parentFingerprint, chainCode, index, depth, null, null);\n    // Private Key\n\n    case \"0x0488ade4\":\n    case \"0x04358394 \":\n      if (key[0] !== 0) {\n        break;\n      }\n\n      return new HDNode(_constructorGuard, bytes_1.hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null, null);\n  }\n\n  return errors.throwError(\"invalid extended key\", errors.INVALID_ARGUMENT, {\n    argument: \"extendedKey\",\n    value: \"[REDACTED]\"\n  });\n}\n\nexports.fromExtendedKey = fromExtendedKey;\n\nfunction _fromSeed(seed, mnemonic) {\n  var seedArray = bytes_1.arrayify(seed);\n\n  if (seedArray.length < 16 || seedArray.length > 64) {\n    throw new Error('invalid seed');\n  }\n\n  var I = bytes_1.arrayify(hmac_1.computeHmac(hmac_1.SupportedAlgorithms.sha512, MasterSecret, seedArray));\n  return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic, 'm');\n}\n\nfunction fromMnemonic(mnemonic, wordlist, password) {\n  // Check that the checksum s valid (will throw an error)\n  mnemonicToEntropy(mnemonic, wordlist);\n  return _fromSeed(mnemonicToSeed(mnemonic, password), mnemonic);\n}\n\nexports.fromMnemonic = fromMnemonic;\n\nfunction fromSeed(seed) {\n  return _fromSeed(seed, null);\n}\n\nexports.fromSeed = fromSeed;\n\nfunction mnemonicToSeed(mnemonic, password) {\n  if (!password) {\n    password = '';\n  }\n\n  var salt = utf8_1.toUtf8Bytes('mnemonic' + password, utf8_1.UnicodeNormalizationForm.NFKD);\n  return bytes_1.hexlify(pbkdf2_1.pbkdf2(utf8_1.toUtf8Bytes(mnemonic, utf8_1.UnicodeNormalizationForm.NFKD), salt, 2048, 64, 'sha512'));\n}\n\nexports.mnemonicToSeed = mnemonicToSeed;\n\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n  if (!wordlist) {\n    wordlist = lang_en_1.langEn;\n  }\n\n  errors.checkNormalize();\n  var words = wordlist.split(mnemonic);\n\n  if (words.length % 3 !== 0) {\n    throw new Error('invalid mnemonic');\n  }\n\n  var entropy = bytes_1.arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n  var offset = 0;\n\n  for (var i = 0; i < words.length; i++) {\n    var index = wordlist.getWordIndex(words[i].normalize('NFKD'));\n\n    if (index === -1) {\n      throw new Error('invalid mnemonic');\n    }\n\n    for (var bit = 0; bit < 11; bit++) {\n      if (index & 1 << 10 - bit) {\n        entropy[offset >> 3] |= 1 << 7 - offset % 8;\n      }\n\n      offset++;\n    }\n  }\n\n  var entropyBits = 32 * words.length / 3;\n  var checksumBits = words.length / 3;\n  var checksumMask = getUpperMask(checksumBits);\n  var checksum = bytes_1.arrayify(sha2_1.sha256(entropy.slice(0, entropyBits / 8)))[0];\n  checksum &= checksumMask;\n\n  if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n    throw new Error('invalid checksum');\n  }\n\n  return bytes_1.hexlify(entropy.slice(0, entropyBits / 8));\n}\n\nexports.mnemonicToEntropy = mnemonicToEntropy;\n\nfunction entropyToMnemonic(entropy, wordlist) {\n  entropy = bytes_1.arrayify(entropy);\n\n  if (entropy.length % 4 !== 0 || entropy.length < 16 || entropy.length > 32) {\n    throw new Error('invalid entropy');\n  }\n\n  var indices = [0];\n  var remainingBits = 11;\n\n  for (var i = 0; i < entropy.length; i++) {\n    // Consume the whole byte (with still more to go)\n    if (remainingBits > 8) {\n      indices[indices.length - 1] <<= 8;\n      indices[indices.length - 1] |= entropy[i];\n      remainingBits -= 8; // This byte will complete an 11-bit index\n    } else {\n      indices[indices.length - 1] <<= remainingBits;\n      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits; // Start the next word\n\n      indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n      remainingBits += 3;\n    }\n  } // Compute the checksum bits\n\n\n  var checksum = bytes_1.arrayify(sha2_1.sha256(entropy))[0];\n  var checksumBits = entropy.length / 4;\n  checksum &= getUpperMask(checksumBits); // Shift the checksum into the word indices\n\n  indices[indices.length - 1] <<= checksumBits;\n  indices[indices.length - 1] |= checksum >> 8 - checksumBits;\n\n  if (!wordlist) {\n    wordlist = lang_en_1.langEn;\n  }\n\n  return wordlist.join(indices.map(function (index) {\n    return wordlist.getWord(index);\n  }));\n}\n\nexports.entropyToMnemonic = entropyToMnemonic;\n\nfunction isValidMnemonic(mnemonic, wordlist) {\n  try {\n    mnemonicToEntropy(mnemonic, wordlist);\n    return true;\n  } catch (error) {}\n\n  return false;\n}\n\nexports.isValidMnemonic = isValidMnemonic;","map":{"version":3,"sources":["/Users/jedi/Desktop/Education/REACT/deployed_treasureblox_dapp/node_modules/@meterio/ethers/utils/hdnode.js"],"names":["__importStar","mod","__esModule","result","k","Object","hasOwnProperty","call","defineProperty","exports","value","errors","require","lang_en_1","basex_1","bytes_1","bignumber_1","utf8_1","pbkdf2_1","hmac_1","properties_1","secp256k1_1","sha2_1","N","bigNumberify","MasterSecret","toUtf8Bytes","HardenedBit","getUpperMask","bits","getLowerMask","bytes32","hexZeroPad","hexlify","base58check","data","checksum","hexDataSlice","sha256","Base58","encode","concat","_constructorGuard","defaultPath","HDNode","constructorGuard","privateKey","publicKey","parentFingerprint","chainCode","index","depth","mnemonic","path","checkNew","Error","keyPair","KeyPair","defineReadOnly","compressedPublicKey","ripemd160","computeAddress","setType","prototype","get","enumerable","configurable","neuter","_derive","String","Uint8Array","set","arrayify","i","I","computeHmac","SupportedAlgorithms","sha512","IL","slice","IR","ki","Ki","add","ek","_addPoint","fingerprint","derivePath","components","split","length","shift","component","match","parseInt","substring","isHDNode","isType","fromExtendedKey","extendedKey","bytes","decode","throwError","INVALID_ARGUMENT","argument","key","_fromSeed","seed","seedArray","fromMnemonic","wordlist","password","mnemonicToEntropy","mnemonicToSeed","fromSeed","salt","UnicodeNormalizationForm","NFKD","pbkdf2","langEn","checkNormalize","words","entropy","Math","ceil","offset","getWordIndex","normalize","bit","entropyBits","checksumBits","checksumMask","entropyToMnemonic","indices","remainingBits","push","join","map","getWord","isValidMnemonic","error"],"mappings":"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","sourcesContent":["\"use strict\";\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\n    result[\"default\"] = mod;\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// See: https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\n// See: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki\nvar errors = __importStar(require(\"../errors\"));\n// The English language word list.\n// For additional word lists, please see /src.tc/wordlists/\nvar lang_en_1 = require(\"../wordlists/lang-en\");\n// Automatically register English?\n//import { register } from '../wordlists/wordlist';\n//register(langEn);\nvar basex_1 = require(\"./basex\");\nvar bytes_1 = require(\"./bytes\");\nvar bignumber_1 = require(\"./bignumber\");\nvar utf8_1 = require(\"./utf8\");\nvar pbkdf2_1 = require(\"./pbkdf2\");\nvar hmac_1 = require(\"./hmac\");\nvar properties_1 = require(\"./properties\");\nvar secp256k1_1 = require(\"./secp256k1\");\nvar sha2_1 = require(\"./sha2\");\nvar N = bignumber_1.bigNumberify(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\");\n// \"Bitcoin seed\"\nvar MasterSecret = utf8_1.toUtf8Bytes('Bitcoin seed');\nvar HardenedBit = 0x80000000;\n// Returns a byte with the MSB bits set\nfunction getUpperMask(bits) {\n    return ((1 << bits) - 1) << (8 - bits);\n}\n// Returns a byte with the LSB bits set\nfunction getLowerMask(bits) {\n    return (1 << bits) - 1;\n}\nfunction bytes32(value) {\n    return bytes_1.hexZeroPad(bytes_1.hexlify(value), 32);\n}\nfunction base58check(data) {\n    var checksum = bytes_1.hexDataSlice(sha2_1.sha256(sha2_1.sha256(data)), 0, 4);\n    return basex_1.Base58.encode(bytes_1.concat([data, checksum]));\n}\nvar _constructorGuard = {};\nexports.defaultPath = \"m/44'/60'/0'/0/0\";\nvar HDNode = /** @class */ (function () {\n    /**\n     *  This constructor should not be called directly.\n     *\n     *  Please use:\n     *   - fromMnemonic\n     *   - fromSeed\n     */\n    function HDNode(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonic, path) {\n        errors.checkNew(this, HDNode);\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error('HDNode constructor cannot be called directly');\n        }\n        if (privateKey) {\n            var keyPair = new secp256k1_1.KeyPair(privateKey);\n            properties_1.defineReadOnly(this, 'privateKey', keyPair.privateKey);\n            properties_1.defineReadOnly(this, 'publicKey', keyPair.compressedPublicKey);\n        }\n        else {\n            properties_1.defineReadOnly(this, 'privateKey', null);\n            properties_1.defineReadOnly(this, 'publicKey', bytes_1.hexlify(publicKey));\n        }\n        properties_1.defineReadOnly(this, 'parentFingerprint', parentFingerprint);\n        properties_1.defineReadOnly(this, 'fingerprint', bytes_1.hexDataSlice(sha2_1.ripemd160(sha2_1.sha256(this.publicKey)), 0, 4));\n        properties_1.defineReadOnly(this, 'address', secp256k1_1.computeAddress(this.publicKey));\n        properties_1.defineReadOnly(this, 'chainCode', chainCode);\n        properties_1.defineReadOnly(this, 'index', index);\n        properties_1.defineReadOnly(this, 'depth', depth);\n        properties_1.defineReadOnly(this, 'mnemonic', mnemonic);\n        properties_1.defineReadOnly(this, 'path', path);\n        properties_1.setType(this, 'HDNode');\n    }\n    Object.defineProperty(HDNode.prototype, \"extendedKey\", {\n        get: function () {\n            // We only support the mainnet values for now, but if anyone needs\n            // testnet values, let me know. I believe current senitment is that\n            // we should always use mainnet, and use BIP-44 to derive the network\n            //   - Mainnet: public=0x0488B21E, private=0x0488ADE4\n            //   - Testnet: public=0x043587CF, private=0x04358394\n            if (this.depth >= 256) {\n                throw new Error(\"Depth too large!\");\n            }\n            return base58check(bytes_1.concat([\n                ((this.privateKey != null) ? \"0x0488ADE4\" : \"0x0488B21E\"),\n                bytes_1.hexlify(this.depth),\n                this.parentFingerprint,\n                bytes_1.hexZeroPad(bytes_1.hexlify(this.index), 4),\n                this.chainCode,\n                ((this.privateKey != null) ? bytes_1.concat([\"0x00\", this.privateKey]) : this.publicKey),\n            ]));\n        },\n        enumerable: true,\n        configurable: true\n    });\n    HDNode.prototype.neuter = function () {\n        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, null, this.path);\n    };\n    HDNode.prototype._derive = function (index) {\n        if (index > 0xffffffff) {\n            throw new Error(\"invalid index - \" + String(index));\n        }\n        // Base path\n        var path = this.path;\n        if (path) {\n            path += '/' + (index & ~HardenedBit);\n        }\n        var data = new Uint8Array(37);\n        if (index & HardenedBit) {\n            if (!this.privateKey) {\n                throw new Error('cannot derive child of neutered node');\n            }\n            // Data = 0x00 || ser_256(k_par)\n            data.set(bytes_1.arrayify(this.privateKey), 1);\n            // Hardened path\n            if (path) {\n                path += \"'\";\n            }\n        }\n        else {\n            // Data = ser_p(point(k_par))\n            data.set(bytes_1.arrayify(this.publicKey));\n        }\n        // Data += ser_32(i)\n        for (var i = 24; i >= 0; i -= 8) {\n            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);\n        }\n        var I = hmac_1.computeHmac(hmac_1.SupportedAlgorithms.sha512, this.chainCode, data);\n        var IL = I.slice(0, 32);\n        var IR = I.slice(32);\n        // The private key\n        var ki = null;\n        // The public key\n        var Ki = null;\n        if (this.privateKey) {\n            ki = bytes32(bignumber_1.bigNumberify(IL).add(this.privateKey).mod(N));\n        }\n        else {\n            var ek = new secp256k1_1.KeyPair(bytes_1.hexlify(IL));\n            Ki = ek._addPoint(this.publicKey);\n        }\n        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, this.mnemonic, path);\n    };\n    HDNode.prototype.derivePath = function (path) {\n        var components = path.split('/');\n        if (components.length === 0 || (components[0] === 'm' && this.depth !== 0)) {\n            throw new Error('invalid path - ' + path);\n        }\n        if (components[0] === 'm') {\n            components.shift();\n        }\n        var result = this;\n        for (var i = 0; i < components.length; i++) {\n            var component = components[i];\n            if (component.match(/^[0-9]+'$/)) {\n                var index = parseInt(component.substring(0, component.length - 1));\n                if (index >= HardenedBit) {\n                    throw new Error('invalid path index - ' + component);\n                }\n                result = result._derive(HardenedBit + index);\n            }\n            else if (component.match(/^[0-9]+$/)) {\n                var index = parseInt(component);\n                if (index >= HardenedBit) {\n                    throw new Error('invalid path index - ' + component);\n                }\n                result = result._derive(index);\n            }\n            else {\n                throw new Error('invlaid path component - ' + component);\n            }\n        }\n        return result;\n    };\n    HDNode.isHDNode = function (value) {\n        return properties_1.isType(value, 'HDNode');\n    };\n    return HDNode;\n}());\nexports.HDNode = HDNode;\nfunction fromExtendedKey(extendedKey) {\n    var bytes = basex_1.Base58.decode(extendedKey);\n    if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {\n        errors.throwError(\"invalid extended key\", errors.INVALID_ARGUMENT, {\n            argument: \"extendedKey\",\n            value: \"[REDACTED]\"\n        });\n    }\n    var depth = bytes[4];\n    var parentFingerprint = bytes_1.hexlify(bytes.slice(5, 9));\n    var index = parseInt(bytes_1.hexlify(bytes.slice(9, 13)).substring(2), 16);\n    var chainCode = bytes_1.hexlify(bytes.slice(13, 45));\n    var key = bytes.slice(45, 78);\n    switch (bytes_1.hexlify(bytes.slice(0, 4))) {\n        // Public Key\n        case \"0x0488b21e\":\n        case \"0x043587cf\":\n            return new HDNode(_constructorGuard, null, bytes_1.hexlify(key), parentFingerprint, chainCode, index, depth, null, null);\n        // Private Key\n        case \"0x0488ade4\":\n        case \"0x04358394 \":\n            if (key[0] !== 0) {\n                break;\n            }\n            return new HDNode(_constructorGuard, bytes_1.hexlify(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null, null);\n    }\n    return errors.throwError(\"invalid extended key\", errors.INVALID_ARGUMENT, {\n        argument: \"extendedKey\",\n        value: \"[REDACTED]\"\n    });\n}\nexports.fromExtendedKey = fromExtendedKey;\nfunction _fromSeed(seed, mnemonic) {\n    var seedArray = bytes_1.arrayify(seed);\n    if (seedArray.length < 16 || seedArray.length > 64) {\n        throw new Error('invalid seed');\n    }\n    var I = bytes_1.arrayify(hmac_1.computeHmac(hmac_1.SupportedAlgorithms.sha512, MasterSecret, seedArray));\n    return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, \"0x00000000\", bytes32(I.slice(32)), 0, 0, mnemonic, 'm');\n}\nfunction fromMnemonic(mnemonic, wordlist, password) {\n    // Check that the checksum s valid (will throw an error)\n    mnemonicToEntropy(mnemonic, wordlist);\n    return _fromSeed(mnemonicToSeed(mnemonic, password), mnemonic);\n}\nexports.fromMnemonic = fromMnemonic;\nfunction fromSeed(seed) {\n    return _fromSeed(seed, null);\n}\nexports.fromSeed = fromSeed;\nfunction mnemonicToSeed(mnemonic, password) {\n    if (!password) {\n        password = '';\n    }\n    var salt = utf8_1.toUtf8Bytes('mnemonic' + password, utf8_1.UnicodeNormalizationForm.NFKD);\n    return bytes_1.hexlify(pbkdf2_1.pbkdf2(utf8_1.toUtf8Bytes(mnemonic, utf8_1.UnicodeNormalizationForm.NFKD), salt, 2048, 64, 'sha512'));\n}\nexports.mnemonicToSeed = mnemonicToSeed;\nfunction mnemonicToEntropy(mnemonic, wordlist) {\n    if (!wordlist) {\n        wordlist = lang_en_1.langEn;\n    }\n    errors.checkNormalize();\n    var words = wordlist.split(mnemonic);\n    if ((words.length % 3) !== 0) {\n        throw new Error('invalid mnemonic');\n    }\n    var entropy = bytes_1.arrayify(new Uint8Array(Math.ceil(11 * words.length / 8)));\n    var offset = 0;\n    for (var i = 0; i < words.length; i++) {\n        var index = wordlist.getWordIndex(words[i].normalize('NFKD'));\n        if (index === -1) {\n            throw new Error('invalid mnemonic');\n        }\n        for (var bit = 0; bit < 11; bit++) {\n            if (index & (1 << (10 - bit))) {\n                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));\n            }\n            offset++;\n        }\n    }\n    var entropyBits = 32 * words.length / 3;\n    var checksumBits = words.length / 3;\n    var checksumMask = getUpperMask(checksumBits);\n    var checksum = bytes_1.arrayify(sha2_1.sha256(entropy.slice(0, entropyBits / 8)))[0];\n    checksum &= checksumMask;\n    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {\n        throw new Error('invalid checksum');\n    }\n    return bytes_1.hexlify(entropy.slice(0, entropyBits / 8));\n}\nexports.mnemonicToEntropy = mnemonicToEntropy;\nfunction entropyToMnemonic(entropy, wordlist) {\n    entropy = bytes_1.arrayify(entropy);\n    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {\n        throw new Error('invalid entropy');\n    }\n    var indices = [0];\n    var remainingBits = 11;\n    for (var i = 0; i < entropy.length; i++) {\n        // Consume the whole byte (with still more to go)\n        if (remainingBits > 8) {\n            indices[indices.length - 1] <<= 8;\n            indices[indices.length - 1] |= entropy[i];\n            remainingBits -= 8;\n            // This byte will complete an 11-bit index\n        }\n        else {\n            indices[indices.length - 1] <<= remainingBits;\n            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);\n            // Start the next word\n            indices.push(entropy[i] & getLowerMask(8 - remainingBits));\n            remainingBits += 3;\n        }\n    }\n    // Compute the checksum bits\n    var checksum = bytes_1.arrayify(sha2_1.sha256(entropy))[0];\n    var checksumBits = entropy.length / 4;\n    checksum &= getUpperMask(checksumBits);\n    // Shift the checksum into the word indices\n    indices[indices.length - 1] <<= checksumBits;\n    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));\n    if (!wordlist) {\n        wordlist = lang_en_1.langEn;\n    }\n    return wordlist.join(indices.map(function (index) { return wordlist.getWord(index); }));\n}\nexports.entropyToMnemonic = entropyToMnemonic;\nfunction isValidMnemonic(mnemonic, wordlist) {\n    try {\n        mnemonicToEntropy(mnemonic, wordlist);\n        return true;\n    }\n    catch (error) { }\n    return false;\n}\nexports.isValidMnemonic = isValidMnemonic;\n"]},"metadata":{},"sourceType":"script"}