{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseSolidityStringArray = exports.stringToBoolean = void 0;\n\nvar stringToBoolean = function (inputString) {\n  var lowercasedInput = inputString.toLowerCase().trim();\n\n  if (lowercasedInput === 'true') {\n    return true;\n  } else if (lowercasedInput === 'false') {\n    return false;\n  }\n\n  throw new Error(\"Unable to parse '\" + inputString + \"' as boolean\");\n};\n\nexports.stringToBoolean = stringToBoolean;\n/**\n * Parses an \"array of strings\" that is returned from a Solidity function\n *\n * @param stringLengths length of each string in bytes\n * @param data 0x-prefixed, hex-encoded string data in utf-8 bytes\n */\n\nvar parseSolidityStringArray = function (stringLengths, data) {\n  if (data === null) {\n    data = '0x';\n  }\n\n  var ret = [];\n  var offset = 0; // @ts-ignore\n\n  var rawData = Buffer.from(data.slice(2), 'hex'); // tslint:disable-next-line:prefer-for-of\n\n  for (var i = 0; i < stringLengths.length; i++) {\n    var string = rawData.toString('utf-8', offset, offset + stringLengths[i]);\n    offset += stringLengths[i];\n    ret.push(string);\n  }\n\n  return ret;\n};\n\nexports.parseSolidityStringArray = parseSolidityStringArray;","map":{"version":3,"sources":["../src/parsing.ts"],"names":[],"mappings":";;;;;;;AAAO,IAAM,eAAe,GAAG,UAAC,WAAD,EAAoB;AACjD,MAAM,eAAe,GAAG,WAAW,CAAC,WAAZ,GAA0B,IAA1B,EAAxB;;AACA,MAAI,eAAe,KAAK,MAAxB,EAAgC;AAC9B,WAAO,IAAP;AACD,GAFD,MAEO,IAAI,eAAe,KAAK,OAAxB,EAAiC;AACtC,WAAO,KAAP;AACD;;AACD,QAAM,IAAI,KAAJ,CAAU,sBAAoB,WAApB,GAA+B,cAAzC,CAAN;AACD,CARM;;AAAM,OAAA,CAAA,eAAA,GAAe,eAAf;AAUb;;;;;AAKG;;AACI,IAAM,wBAAwB,GAAG,UAAC,aAAD,EAA0B,IAA1B,EAAsC;AAC5E,MAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,IAAA,IAAI,GAAG,IAAP;AACD;;AACD,MAAM,GAAG,GAAa,EAAtB;AACA,MAAI,MAAM,GAAG,CAAb,CAL4E,CAM5E;;AACA,MAAM,OAAO,GAAG,MAAM,CAAC,IAAP,CAAY,IAAI,CAAC,KAAL,CAAW,CAAX,CAAZ,EAA2B,KAA3B,CAAhB,CAP4E,CAQ5E;;AACA,OAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,aAAa,CAAC,MAAlC,EAA0C,CAAC,EAA3C,EAA+C;AAC7C,QAAM,MAAM,GAAG,OAAO,CAAC,QAAR,CAAiB,OAAjB,EAA0B,MAA1B,EAAkC,MAAM,GAAG,aAAa,CAAC,CAAD,CAAxD,CAAf;AACA,IAAA,MAAM,IAAI,aAAa,CAAC,CAAD,CAAvB;AACA,IAAA,GAAG,CAAC,IAAJ,CAAS,MAAT;AACD;;AACD,SAAO,GAAP;AACD,CAfM;;AAAM,OAAA,CAAA,wBAAA,GAAwB,wBAAxB","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseSolidityStringArray = exports.stringToBoolean = void 0;\nvar stringToBoolean = function (inputString) {\n    var lowercasedInput = inputString.toLowerCase().trim();\n    if (lowercasedInput === 'true') {\n        return true;\n    }\n    else if (lowercasedInput === 'false') {\n        return false;\n    }\n    throw new Error(\"Unable to parse '\" + inputString + \"' as boolean\");\n};\nexports.stringToBoolean = stringToBoolean;\n/**\n * Parses an \"array of strings\" that is returned from a Solidity function\n *\n * @param stringLengths length of each string in bytes\n * @param data 0x-prefixed, hex-encoded string data in utf-8 bytes\n */\nvar parseSolidityStringArray = function (stringLengths, data) {\n    if (data === null) {\n        data = '0x';\n    }\n    var ret = [];\n    var offset = 0;\n    // @ts-ignore\n    var rawData = Buffer.from(data.slice(2), 'hex');\n    // tslint:disable-next-line:prefer-for-of\n    for (var i = 0; i < stringLengths.length; i++) {\n        var string = rawData.toString('utf-8', offset, offset + stringLengths[i]);\n        offset += stringLengths[i];\n        ret.push(string);\n    }\n    return ret;\n};\nexports.parseSolidityStringArray = parseSolidityStringArray;\n//# sourceMappingURL=parsing.js.map"]},"metadata":{},"sourceType":"script"}